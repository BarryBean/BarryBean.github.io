<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="BarryBean">
  <meta name="keywords" content="">
  <title>MySQL - BarryBean&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/github-gist.min.css" />


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_ijqayz9ro8k.css">




<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>BarryBean's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              首页</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">
              <i class="iconfont icon-archive-fill"></i>
              归档</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">
              <i class="iconfont icon-category-fill"></i>
              分类</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">
              <i class="iconfont icon-tags-fill"></i>
              标签</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              关于</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/links/">
              <i class="iconfont icon-link-fill"></i>
              友链</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/sky.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2020-05-08 21:04">
                    星期五, 五月 8日 2020, 9:04 晚上
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    5.5k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    60
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p>详细介绍MySQL的索引、事务、锁机制、多版本并发控制、架构和数据库优化。</p>
<a id="more"></a>

<h1 id="1-基础理论"><a href="#1-基础理论" class="headerlink" title="1. 基础理论"></a>1. 基础理论</h1><h2 id="1-1-三大范式"><a href="#1-1-三大范式" class="headerlink" title="1.1 三大范式"></a>1.1 三大范式</h2><ul>
<li>第一范式：每个列都不能再分；</li>
<li>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能依赖主键的一部分；</li>
<li>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</li>
</ul>
<h2 id="1-2-存储过程"><a href="#1-2-存储过程" class="headerlink" title="1.2 存储过程"></a>1.2 存储过程</h2><p>答：存储过程是一个预编译的SQL语句，只要创建一次，就可以多次调用。</p>
<p>优点</p>
<ul>
<li>预编译过的，执行效率高；</li>
<li>可重复使用；</li>
<li>存储过程代码放在数据库里，通过存储过程名可以直接调用。</li>
</ul>
<p>缺点</p>
<ul>
<li>引用关系对象改变，受影响的存储过程要重新编译；</li>
<li>维护麻烦。</li>
</ul>
<h2 id="1-3-触发器"><a href="#1-3-触发器" class="headerlink" title="1.3 触发器"></a>1.3 触发器</h2><p>答：触发器是用户定义在关系表上的一类由事件驱动的特殊存储过程。通俗理解就是，一段触发某事件后自动执行的代码。</p>
<p>在insert、update、delete前后都能加入触发器。</p>
<h2 id="1-4-数据类型"><a href="#1-4-数据类型" class="headerlink" title="1.4 数据类型"></a>1.4 数据类型</h2><ol>
<li>整数类型。tinyint,smallint,mediumint,int,bigint =&gt; 1,2,3,4,8字节。</li>
<li>实数类型。float,double,decimal。</li>
<li>字符串类型。varchar(变长),char(定长),text,blob。</li>
<li>枚举类型。enum用来代替常用字符串类型。</li>
<li>日期和时间类型。timestamp,datetime。</li>
</ol>
<h2 id="1-5-int-10-char-10-varchar-10-区别"><a href="#1-5-int-10-char-10-varchar-10-区别" class="headerlink" title="1.5 int(10) char(10) varchar(10)区别"></a>1.5 int(10) char(10) varchar(10)区别</h2><ul>
<li>int(10)表示显示的数据长度，还是4字节存储；</li>
<li>char(10)表示存储定长的10个字符，不够就用空格补齐；</li>
<li>varchar(10)表示存储变长的10个字符，存储多少个就是多少个。</li>
</ul>
<h2 id="1-6-count-count-1-和count-col"><a href="#1-6-count-count-1-和count-col" class="headerlink" title="1.6 count(*),count(1)和count(col)"></a>1.6 count(*),count(1)和count(col)</h2><ol>
<li>执行效果上<ul>
<li>count(*)和count(1)相当于统计行数，不忽略列值为null的；</li>
<li>count(col)统计col列，忽略null值。</li>
</ul>
</li>
<li>执行效率上<ul>
<li>count(*)mysql做了优化处理，有主键的情况下，效率更优</li>
<li>count(1)当没有主键时使用。</li>
<li>count(col)最慢，因为不走索引。</li>
</ul>
</li>
</ol>
<h1 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2. 存储引擎"></a>2. 存储引擎</h1><p>答：MySQL是一个关系型数据库，默认端口号是3306。5.5前用MyISAM，5.5后用InnoDB。</p>
<h2 id="2-1-InnoDB"><a href="#2-1-InnoDB" class="headerlink" title="2.1 InnoDB"></a>2.1 InnoDB</h2><p>答：5.5版本后的默认引擎。默认可重复读的事务隔离级别，主索引是聚簇索引，内部做了诸多优化(插入缓冲区、哈希索引等)，支持热备份。</p>
<h2 id="2-2-MyISAM"><a href="#2-2-MyISAM" class="headerlink" title="2.2 MyISAM"></a>2.2 MyISAM</h2><p>答：5.5版本前的默认引擎。全文搜索用 match against。</p>
<h2 id="2-3-MyISAM和InnoDB区别"><a href="#2-3-MyISAM和InnoDB区别" class="headerlink" title="2.3 MyISAM和InnoDB区别"></a>2.3 MyISAM和InnoDB区别</h2><p>答：区别如下：</p>
<ul>
<li>行级锁。MyISAM只支持表级锁，InnoDB支持表级锁和行级锁。</li>
<li>事务支持。MyISAM不支持事务，InnoDB提供事务支持和崩溃恢复。</li>
<li>外键。MyISAM不支持外键，InnoDB支持外键。</li>
<li>InnoDB支持多版本并发控制MVVC，可以处理大量数据。</li>
<li>MyISAM支持全文索引。</li>
</ul>
<p>总结一下：<strong>InnoDB支持行+表级锁、事务、外键、多版本并发控制</strong>。</p>
<h1 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h1><p>索引是一种数据结构，提供指向存储在表的指定列中数据值的指针，能加快检索速度，但同时索引也需要空间存储和定期维护。(通俗理解为书本的目录)</p>
<h2 id="3-1-类型"><a href="#3-1-类型" class="headerlink" title="3.1 类型"></a>3.1 类型</h2><ul>
<li>主键索引：数据列不允许重复，不允许null，一个表主键唯一；</li>
<li>唯一索引：数据列不允许重复，允许null，一个表允许多个唯一索引。</li>
<li>普通索引：允许null，无唯一性要求。</li>
<li>全文索引：搜索时使用。</li>
</ul>
<h3 id="3-1-1-唯一索引影响插入速度，提高查找速度"><a href="#3-1-1-唯一索引影响插入速度，提高查找速度" class="headerlink" title="3.1.1 唯一索引影响插入速度，提高查找速度"></a>3.1.1 唯一索引影响插入速度，提高查找速度</h3><p>前提：当使用辅助索引时，先判断插入索引页是否在内存，不在则先放在 Change Buffer 中，然后以一定频率进行合并操作。</p>
<ol>
<li>插入速度慢<ul>
<li>唯一索引的插入无法利用Change Buffer。</li>
<li>因为唯一索引为了保证唯一性，要将数据页全部加载进内存，不用进入缓存。</li>
</ul>
</li>
<li>查找速度快<ul>
<li>普通索引在找到满足条件的第一条记录后，还需要继续查找，直到第一条不满足条件的记录出现；</li>
<li>唯一索引在找到满足条件的第一条记录后，直接返回。</li>
</ul>
</li>
</ol>
<h2 id="3-2-InnoDB索引类型"><a href="#3-2-InnoDB索引类型" class="headerlink" title="3.2 InnoDB索引类型"></a>3.2 InnoDB索引类型</h2><h3 id="3-2-1-B-Tree索引"><a href="#3-2-1-B-Tree索引" class="headerlink" title="3.2.1 B+ Tree索引"></a>3.2.1 B+ Tree索引</h3><p>答：<strong>InnoDB默认的索引方式</strong>。有序索引，将相邻数据都存在一起，把随机IO变成顺序IO。</p>
<h4 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h4><ul>
<li>B树，叶子和非叶子节点都存放数据；B+树，只在叶子节点存放数据。</li>
<li>B+树的叶子节点有一条链相连，能进行顺序索引，而B树的叶子节点各自独立。</li>
</ul>
<h4 id="数据库为什么用B-树"><a href="#数据库为什么用B-树" class="headerlink" title="数据库为什么用B+树"></a>数据库为什么用B+树</h4><p>答：总结：</p>
<ul>
<li>B+树支持<strong>随机和顺序索引</strong>，B树只支持随机索引；</li>
<li>B+树查询效率稳定。B+树数据存储在叶子结点中，B树存储在叶子 + 非叶子节点，所以B+树的<strong>查询是从root到叶子节点，不会中断</strong>。</li>
<li>B+树<strong>内部结点更小</strong>，没有指向关键字的指针，读写消耗小。</li>
</ul>
<h4 id="为什么MongoDB使用B树"><a href="#为什么MongoDB使用B树" class="headerlink" title="为什么MongoDB使用B树"></a>为什么MongoDB使用B树</h4><p>答：MySQL是关系型数据库，更多使用范围查询，所以用B+树；MongoDB是非关系型数据库，数据遍历的操作少，常用单一查询，所以用B树。</p>
<h3 id="3-2-2-哈希索引"><a href="#3-2-2-哈希索引" class="headerlink" title="3.2.2 哈希索引"></a>3.2.2 哈希索引</h3><p>答：类似哈希表，将数据库字段转换成hash值和行指针放进hash表。以O(1)时间搜索，但无法排序分组，<strong>只能精准查找</strong>。</p>
<p>自适应哈希索引：当某个索引被频繁引用时，在B+树索引上再创建一个哈希索引，提供快速查找。<br> 。</p>
<h2 id="3-3-聚簇索引-主索引-和非聚簇索引-辅助索引"><a href="#3-3-聚簇索引-主索引-和非聚簇索引-辅助索引" class="headerlink" title="3.3 聚簇索引(主索引)和非聚簇索引(辅助索引)"></a>3.3 聚簇索引(主索引)和非聚簇索引(辅助索引)</h2><p>答：B+ Tree索引分为主索引和辅助索引。</p>
<ul>
<li>聚簇索引/主索引：叶子<strong>结点存储数据</strong>。直接找key就能获得数据。一个表只能包含一个主索引。</li>
<li>非聚簇索引/辅助索引：叶子<strong>结点存储主键</strong>的值。需要先取得主键，再用此主键走一遍主索引。(回表，若全部命中索引，也可以不用回表)</li>
</ul>
<h2 id="3-4-索引优化"><a href="#3-4-索引优化" class="headerlink" title="3.4 索引优化"></a>3.4 索引优化</h2><h3 id="3-4-1-索引列顺序"><a href="#3-4-1-索引列顺序" class="headerlink" title="3.4.1 索引列顺序"></a>3.4.1 索引列顺序</h3><p>答：把<strong>选择性最强/使用最频繁的索引放在前面</strong>。索引选择性=不重复的索引值 / 记录总数。</p>
<h3 id="3-4-2-覆盖索引"><a href="#3-4-2-覆盖索引" class="headerlink" title="3.4.2 覆盖索引"></a>3.4.2 覆盖索引</h3><p>答：覆盖索引是select的数据列只用从索引中就能够取得，不必读取数据行，即查询列要被所建的索引覆盖。</p>
<h3 id="3-4-3-前缀索引"><a href="#3-4-3-前缀索引" class="headerlink" title="3.4.3 前缀索引"></a>3.4.3 前缀索引</h3><p>答：根据选择性，只<strong>索引</strong>字符串的<strong>最左M个字符</strong>，前提是前缀的标识度高。</p>
<h3 id="3-4-4-索引下推"><a href="#3-4-4-索引下推" class="headerlink" title="3.4.4 索引下推"></a>3.4.4 索引下推</h3><p>答：<strong>联合索引</strong>时，先对其余其他字段判断，<strong>过滤不满足条件的记录</strong>，减少回表次数和数据数量。</p>
<h3 id="3-4-5-最左前缀匹配原则"><a href="#3-4-5-最左前缀匹配原则" class="headerlink" title="3.4.5 最左前缀匹配原则"></a>3.4.5 最左前缀匹配原则</h3><p>联合索引时，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)停止，所以要注意联合索引的顺序。</p>
<h2 id="3-5-SQL语句"><a href="#3-5-SQL语句" class="headerlink" title="3.5 SQL语句"></a>3.5 SQL语句</h2><pre><code class="hljs java"><span class="hljs-comment">//增加索引</span>
alter table user add index/unique/<span class="hljs-function">fulltext <span class="hljs-title">user_id</span><span class="hljs-params">(id)</span> </span>
<span class="hljs-function">create index/unique user_id on <span class="hljs-title">user</span><span class="hljs-params">(id)</span></span>
<span class="hljs-function"></span>
<span class="hljs-function"><span class="hljs-comment">//删除索引</span></span>
<span class="hljs-function">alter table user drop key user_id</span></code></pre>


<h2 id="3-6-小知识"><a href="#3-6-小知识" class="headerlink" title="3.6 小知识"></a>3.6 小知识</h2><h3 id="3-6-1-回表"><a href="#3-6-1-回表" class="headerlink" title="3.6.1 回表"></a>3.6.1 回表</h3><p>答：回表就是指普通索引查询，先搜索普通索引树获得主键值，再到主键索引树搜索一次。</p>
<h3 id="3-6-2-百万级数据删除"><a href="#3-6-2-百万级数据删除" class="headerlink" title="3.6.2 百万级数据删除"></a>3.6.2 百万级数据删除</h3><p>答：百万级以上的数据一定存在索引，CRUD时都会对索引有影响，所以先删除索引，再删无用数据，循环。</p>
<h1 id="4-事务"><a href="#4-事务" class="headerlink" title="4. 事务"></a>4. 事务</h1><p>答：事务就是逻辑上的一组操作，要么都执行，要么都不执行，执行结果必须让数据库从一种一致性状态到另一种一致性状态。</p>
<h2 id="4-1-四大特性ACID"><a href="#4-1-四大特性ACID" class="headerlink" title="4.1 四大特性ACID"></a>4.1 四大特性ACID</h2><p>答：ACID。</p>
<ul>
<li><strong>原子性</strong>(Atomicity)：事务是最小的执行单位，要么全部执行，要么全部不执行。</li>
<li><strong>一致性</strong>(Consistency)：保证数据库状态要一致，多个事务对同一数据读取结果是相同的。</li>
<li><strong>隔离性</strong>(Isolation)：多个事务并发，各个事务是不受其他事务干扰的。</li>
<li><strong>持久性</strong>(Durability)：一个事务一旦提交，此修改在数据库中是持久保存的。</li>
</ul>
<p>持久性应对系统GG，只有一致性才能保证执行结果正确，并发才要隔离性，原子性是最基础的。</p>
<h2 id="4-2-并发事务的问题"><a href="#4-2-并发事务的问题" class="headerlink" title="4.2 并发事务的问题"></a>4.2 并发事务的问题</h2><ul>
<li><strong>脏读</strong>(Dirty read)：事务A读取了事务B修改未提交的数据，B回滚，A的数据不一致。</li>
<li><strong>丢失修改</strong>(Lost to modify)：事务A和B同时读取数据，A修改后先提交，B修改后再提交会将A的修改覆盖。</li>
<li><strong>不可重复读</strong>(Unrepeatable read)：事务A两次读取数据间，有事务B修改更新，导致两次读取数据不一致。</li>
<li><strong>幻读</strong>(Phantom read)：事务A两次读取数据间，有事务B增加了记录，导致两次读取数据记录数不一致。</li>
</ul>
<p>注：<strong>幻读指结构</strong>上发生变化。<strong>不可重复读指数值</strong>上发生变化。</p>
<h2 id="4-3-隔离级别"><a href="#4-3-隔离级别" class="headerlink" title="4.3 隔离级别"></a>4.3 隔离级别</h2><p>答：MySQL定义了四个隔离级别。</p>
<ul>
<li><strong>读未提交</strong>(Read-Uncommitted)：最低级别，允许读取尚未提交的数据。会发生脏读、幻读、不可重复读。</li>
<li><strong>读已提交</strong>(Read-Committed)：允许读取已经提交的数据。阻止脏读。<strong>oracle默认</strong></li>
<li><strong>可重复读</strong>(Repeatable-Read)：读事务时禁止写事务，写事务时阻止一切。阻止脏读和不可重复读。<strong>InnoDB默认隔离级别</strong>。</li>
<li><strong>可串行化</strong>(Serialization)：最高级别。所有事务依次执行，不会互相干扰。阻止三个事务问题。</li>
</ul>
<h1 id="5-锁机制"><a href="#5-锁机制" class="headerlink" title="5. 锁机制"></a>5. 锁机制</h1><p>锁机制是在并发时，确保数据访问次序的。</p>
<h2 id="5-1-按粒度分"><a href="#5-1-按粒度分" class="headerlink" title="5.1 按粒度分"></a>5.1 按粒度分</h2><p>答：分为表级锁，行级锁和页级锁。</p>
<ul>
<li><strong>表级锁</strong>：粒度最大的锁。<strong>对整张表加锁</strong>，资源消耗少，加锁快，不会死锁，但锁冲突概率高。</li>
<li><strong>行级锁</strong>：粒度最小的锁。<strong>对</strong>当前<strong>操作行加锁</strong>，加锁慢，开销大，会死锁，但大大减少冲突。</li>
<li><strong>页级锁</strong>：介于行级锁和表级锁中间的锁。<strong>一次锁定相邻的一组记录</strong>，会死锁，其他均属于中等。</li>
</ul>
<h3 id="5-1-1-常见行级锁"><a href="#5-1-1-常见行级锁" class="headerlink" title="5.1.1 常见行级锁"></a>5.1.1 常见行级锁</h3><p>答：有三种。</p>
<ul>
<li>Record Lock：单行锁，锁定符合条件的行。</li>
<li>Gap Lock：间隙锁，锁定一个范围，不含记录本身。防止幻读。</li>
<li><strong>Next-key Lock：Record+Gap，锁定一个范围，含记录本身</strong>。</li>
</ul>
<h3 id="5-1-2-表级锁使用场景"><a href="#5-1-2-表级锁使用场景" class="headerlink" title="5.1.2 表级锁使用场景"></a>5.1.2 表级锁使用场景</h3><p>答：当事务比较复杂，使用行级锁容易死锁回滚。更新大表的大部分数据，表级锁效率更好。</p>
<h3 id="5-1-3-行级锁何时会锁住整张表"><a href="#5-1-3-行级锁何时会锁住整张表" class="headerlink" title="5.1.3 行级锁何时会锁住整张表"></a>5.1.3 行级锁何时会锁住整张表</h3><p>答：更新的列没有建立索引，会直接锁住整张表。</p>
<h2 id="5-2-按是否可写分"><a href="#5-2-按是否可写分" class="headerlink" title="5.2 按是否可写分"></a>5.2 按是否可写分</h2><p>答：可以进一步划分为共享锁和排他锁。</p>
<ul>
<li><strong>共享锁</strong>(Shared Lock)：读锁。锁定的资源能被其他用户读取，但不能修改，直到资源上的S锁全部被释放。</li>
<li><strong>排他锁</strong>(Exclusive Lock)：写锁。事务T对数据A加X锁，则只允许T读取修改，直到X锁释放。在更新操作，如insert、update 或 delete时，始终应用排它锁。</li>
</ul>
<h3 id="5-2-1-意向锁"><a href="#5-2-1-意向锁" class="headerlink" title="5.2.1 意向锁"></a>5.2.1 意向锁</h3><p>意向锁都是表锁，表示事务想在表中某数据行上加 S 或 X 锁。</p>
<ul>
<li>事务想加 X 锁，先检测表A有无 X/IX/S/IS锁，有则加互斥锁失败；</li>
<li>想加 S 锁，先检测表A有无 X/IX，有则加读锁失败。</li>
<li>IS 和 IX 之间是相互兼容的，因为是意向，并没有真正加锁。</li>
</ul>
<h2 id="5-3-死锁"><a href="#5-3-死锁" class="headerlink" title="5.3 死锁"></a>5.3 死锁</h2><p>答：MySQL中的死锁是<strong>多个事务使用行级锁对某行数据加锁造成</strong>。</p>
<h3 id="5-3-1-解决方案"><a href="#5-3-1-解决方案" class="headerlink" title="5.3.1 解决方案"></a>5.3.1 解决方案</h3><p>答：分为两个方面。<br>业务层面：</p>
<ul>
<li>指定锁的获取资源顺序。(操作系统中的哲学家就餐问题)</li>
<li>同一个事务一次锁定尽可能多的资源。</li>
<li>事务拆分成小事务。</li>
</ul>
<p>数据库设置：</p>
<ul>
<li>设置超时时间。InnoDB默认是50s。</li>
<li>开启死锁检测。发生死锁时，回归死锁链上一个事务，让其他事务继续执行。</li>
</ul>
<h2 id="5-4-悲观锁和乐观锁"><a href="#5-4-悲观锁和乐观锁" class="headerlink" title="5.4 悲观锁和乐观锁"></a>5.4 悲观锁和乐观锁</h2><p>答：悲观锁和乐观锁是数据库管理系统并发控制的手段。</p>
<ul>
<li><strong>悲观锁</strong>：<strong>利用数据库的锁机制</strong>实现，在整个数据处理过程都加锁，<strong>保证排他性</strong>。</li>
<li><strong>乐观锁</strong>：<strong>CAS/版本号实现</strong>。假定不会发生冲突，在提交时检查是否违反数据完整性。</li>
</ul>
<h3 id="5-4-1-乐观锁的ABA问题"><a href="#5-4-1-乐观锁的ABA问题" class="headerlink" title="5.4.1 乐观锁的ABA问题"></a>5.4.1 乐观锁的ABA问题</h3><p>答：加入<strong>数据版本记录机制</strong>或者使用时间戳。</p>
<p>ABA问题：事务X读取数据A时，事务Y修改成B，又修改回A，事实上数据发生过改变的，存在并发问题，但事务X无法得到数据发生过变化。</p>
<h3 id="5-4-2-使用场景"><a href="#5-4-2-使用场景" class="headerlink" title="5.4.2 使用场景"></a>5.4.2 使用场景</h3><p>答：多读用乐观，多写用悲观。</p>
<h1 id="6-MySQL架构和执行流程"><a href="#6-MySQL架构和执行流程" class="headerlink" title="6. MySQL架构和执行流程"></a>6. MySQL架构和执行流程</h1><h2 id="6-1-基础架构"><a href="#6-1-基础架构" class="headerlink" title="6.1 基础架构"></a>6.1 基础架构</h2><p>答：MySQL主要分为Server层和存储引擎层。</p>
<ul>
<li><strong>Server层</strong>：跨存储引擎的功能都在此实现，如视图、触发器、函数等，有一个binlog日志。</li>
<li><strong>存储引擎</strong>：负责数据的存储和读取。常用的是InnoDB，自带redolog模块。</li>
</ul>
<h2 id="6-2-基本组件"><a href="#6-2-基本组件" class="headerlink" title="6.2 基本组件"></a>6.2 基本组件</h2><p>答：Server层有五个主要组件。</p>
<ul>
<li>连接器：身份验证和权限设置。</li>
<li>查询缓存：执行查询语句前，先查有没有缓存的结果集。(8.0后废弃)</li>
<li>分析器：没有命中缓存，则进入分析器进行词法和语法分析。</li>
<li>优化器：按照MySQL认为最优的方案执行。</li>
<li>执行器：用户有权限，则调用存储引擎，执行语句。</li>
</ul>
<h2 id="6-3-执行流程"><a href="#6-3-执行流程" class="headerlink" title="6.3 执行流程"></a>6.3 执行流程</h2><h3 id="6-3-1-查询语句"><a href="#6-3-1-查询语句" class="headerlink" title="6.3.1 查询语句"></a>6.3.1 查询语句</h3><p>权限校验—-&gt;查询缓存—-&gt;分析器—-&gt;优化器—-&gt;权限校验—-&gt;执行器—-&gt;引擎</p>
<h3 id="6-3-2-更新语句"><a href="#6-3-2-更新语句" class="headerlink" title="6.3.2 更新语句"></a>6.3.2 更新语句</h3><p>分析器—-&gt;权限校验—-&gt;执行器—-&gt;引擎—-&gt;redo log prepare—-&gt;binlog—-&gt;redo log commit</p>
<p>以修改张三的年龄为例：</p>
<ul>
<li>先查询到张三这条数据，如果有缓存，用缓存。</li>
<li>拿到查询的语句，把 age 改为 19。</li>
<li>调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态。</li>
<li>通知执行器，执行完成，可以提交。</li>
<li>执行器收到通知后记录 binlog，调用引擎接口，提交 redo log 为提交状态。</li>
<li>更新完成。</li>
</ul>
<h2 id="6-4-日志模块"><a href="#6-4-日志模块" class="headerlink" title="6.4 日志模块"></a>6.4 日志模块</h2><p>答：MySQL主要有redolog和binlog。</p>
<ul>
<li><strong>redolog(重做日志)</strong>：InnoDB特有，物理日志。<strong>记录哪个数据页做了修改</strong>。</li>
<li><strong>binlog(归档日志)</strong>：Server层自带，逻辑日志，<strong>记录本次修改的SQL语句</strong>。通常使用row二进制格式，保证数据记录的准确性。</li>
</ul>
<h3 id="6-4-1-两阶段提交"><a href="#6-4-1-两阶段提交" class="headerlink" title="6.4.1 两阶段提交"></a>6.4.1 两阶段提交</h3><p>答：保证数据一致性。</p>
<p><strong>redolog prepare引擎数据保存 -&gt; binlog执行器收到信号 -&gt; redolog commit执行器调用</strong></p>
<p>异常时，MySQL先判断redolog是否完整，完整则直接提交。redolog只是prepare状态，查看binlog是否完整，完整就继续提交redolog，否则回滚事务。</p>
<h3 id="6-4-2-MySQL为什么会突然慢一下"><a href="#6-4-2-MySQL为什么会突然慢一下" class="headerlink" title="6.4.2 MySQL为什么会突然慢一下"></a>6.4.2 MySQL为什么会突然慢一下</h3><p>答：更新数据库时，先写日志，等合适时间再更新磁盘。当redolog写满，需要<strong>flush脏页</strong>，将数据写入磁盘，这是会使执行速度慢一下。</p>
<h1 id="7-多版本并发控制"><a href="#7-多版本并发控制" class="headerlink" title="7. 多版本并发控制"></a>7. 多版本并发控制</h1><p><strong>MVCC</strong> 多版本并发控制是 InnoDB 实现隔离级别的方式，<strong>用于读已提交和可重复读</strong>。</p>
<blockquote>
<p>提一嘴，Next-Key Locks 解决幻读，锁自己Record+锁范围Gap。</p>
</blockquote>
<h2 id="7-1-基本思想"><a href="#7-1-基本思想" class="headerlink" title="7.1 基本思想"></a>7.1 基本思想</h2><p>事务的修改操作会为数据行新增一个版本快照，<strong>写操作更新最新的版本快照，读操作去读旧版本快照</strong>。</p>
<blockquote>
<p>注：脏读和不可重复读的原因是事务读取到其他事务未提交的修改。</p>
</blockquote>
<h2 id="7-2-Undo日志"><a href="#7-2-Undo日志" class="headerlink" title="7.2 Undo日志"></a>7.2 Undo日志</h2><p>多版本就是指多个版本的快照，快照存储在 Undo 日志中，通过回滚指针把一个数据行的所有快照连接起来。</p>
<ul>
<li>系统版本号SYS_ID：递增数字，每一个新事务，就++；</li>
<li>事务版本号TRX_ID：事务开始时的系统版本号。</li>
</ul>
<h2 id="7-3-ReadView"><a href="#7-3-ReadView" class="headerlink" title="7.3 ReadView"></a>7.3 ReadView</h2><p>MVCC 维护了 ReadView 结构，包含当前系统未提交的事务列表TRX_IDs，列表的最大值和最小值。</p>
<h2 id="7-4-SELECT"><a href="#7-4-SELECT" class="headerlink" title="7.4 SELECT"></a>7.4 SELECT</h2><p>根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：</p>
<ol>
<li>TRX_ID &lt; TRX_ID_MIN，表示该数据行快照是在当前所有未提交事务之前进行更改的，因此可以使用。</li>
<li>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li>
<li>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：<ul>
<li>提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li>
<li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li>
</ul>
</li>
</ol>
<p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。</p>
<p>此节参考：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E4%BA%94%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">CyC2018数据库系统原理-多版本并发控制</a></p>
<h1 id="8-优化"><a href="#8-优化" class="headerlink" title="8. 优化"></a>8. 优化</h1><h2 id="8-1-结构优化"><a href="#8-1-结构优化" class="headerlink" title="8.1 结构优化"></a>8.1 结构优化</h2><ol>
<li>拆表。把使用频率低的列单独分离成表。</li>
<li>增加中间表。把经常联合查询数据插入中间表。</li>
<li>增加冗余字段。</li>
</ol>
<h2 id="8-2-SQL优化"><a href="#8-2-SQL优化" class="headerlink" title="8.2 SQL优化"></a>8.2 SQL优化</h2><h3 id="8-2-1-超大分页"><a href="#8-2-1-超大分页" class="headerlink" title="8.2.1 超大分页"></a>8.2.1 超大分页</h3><p>答：两个思路。</p>
<ul>
<li>减少load的数据，如先定位id再关联；</li>
<li>增加缓存，如redis。</li>
</ul>
<h3 id="8-2-2-慢查询日志"><a href="#8-2-2-慢查询日志" class="headerlink" title="8.2.2 慢查询日志"></a>8.2.2 慢查询日志</h3><p>答：当执行时间超过临界值时，将SQL计入日志。慢查询优化主要从三方面入手。</p>
<ul>
<li>load了额外数据；</li>
<li>没有命中索引；</li>
<li>数据量太大，需要切分。</li>
</ul>
<h3 id="8-2-3-语句优化"><a href="#8-2-3-语句优化" class="headerlink" title="8.2.3 语句优化"></a>8.2.3 语句优化</h3><p>参考 <a href="https://www.cnblogs.com/huchong/p/10219318.html" target="_blank" rel="noopener">https://www.cnblogs.com/huchong/p/10219318.html</a> 作者：听风。</p>
<h2 id="8-3-大表优化"><a href="#8-3-大表优化" class="headerlink" title="8.3 大表优化"></a>8.3 大表优化</h2><p>答：单表记录数过大时，数据库性能下降明显，需要进行一系列的优化。</p>
<h3 id="8-3-1-限定数据范围"><a href="#8-3-1-限定数据范围" class="headerlink" title="8.3.1 限定数据范围"></a>8.3.1 限定数据范围</h3><p>最简单的手段，限制数据范围条件来查询数据。</p>
<h3 id="8-3-2-读写分离"><a href="#8-3-2-读写分离" class="headerlink" title="8.3.2 读写分离"></a>8.3.2 读写分离</h3><p><strong>主服务器处理写操作</strong>或实时性高的读操作，<strong>从服务器处理读操作</strong>。</p>
<ul>
<li>实现方式：增设代理服务器，决定将应用传来的请求转发到哪个服务器。</li>
<li>原因：极大减少了锁的争用；用冗余换可用性；从服务器可用MyISAM节约资源。<br><img src="/img/db/%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93.png" srcset="/img/loading.gif" alt="主从数据库"></li>
</ul>
<h3 id="8-3-3-缓存"><a href="#8-3-3-缓存" class="headerlink" title="8.3.3 缓存"></a>8.3.3 缓存</h3><p>对基本不更新的数据使用应用级别的缓存。</p>
<h3 id="8-3-4-水平拆分"><a href="#8-3-4-水平拆分" class="headerlink" title="8.3.4 水平拆分"></a>8.3.4 水平拆分</h3><p>水平拆分将一张表A拆分成多个相同结构的表a1,a2,a3存储，每个子表只占一部分数据。<br>又细分为库内分表和分库分表。</p>
<ul>
<li><strong>库内分表</strong>：子表仍在一个数据库实例中，仍要竞争同一个物理机资源。</li>
<li><strong>分库分表</strong>：子表分散在不同数据库中。</li>
</ul>
<p>优点：业务改造简单；解决了单表数据量过大的问题。<br>缺点：跨库的一致性难保证；join关联性能差；扩容和维护难度过大。</p>
<h3 id="8-3-5-垂直拆分"><a href="#8-3-5-垂直拆分" class="headerlink" title="8.3.5 垂直拆分"></a>8.3.5 垂直拆分</h3><p>又细分为垂直分库和垂直分表。</p>
<ul>
<li><strong>垂直分库</strong>：基于业务划分数据库，让每个业务都有独立数据库。</li>
<li><strong>垂直分表</strong>：基于数据表的列切分，把一张列1-7的表拆成列1-4和列1 5-7的表。</li>
</ul>
<p>优点：业务解耦；高并发下提升了性能。<br>缺点：增加了业务复杂度；<strong>主键冗余</strong>；数据量过大仍未解决，需要配合水平拆分。</p>
<h2 id="8-4-拆分后的问题"><a href="#8-4-拆分后的问题" class="headerlink" title="8.4 拆分后的问题"></a>8.4 拆分后的问题</h2><ol>
<li>事务一致性<br>两阶段提交性能较差。通常<strong>追求最终一致性</strong>，出现问题进行事务补偿。</li>
<li>分页和排序<br>字段排序，需要先在每个节点内排序，再将结果汇总再次排序，最后返回给用户。</li>
<li>全局唯一主键<br>拆分后属于分布式应用，需要使用<strong>分布式ID用作全局唯一主键</strong>。一般用雪花模型。</li>
</ol>
<p>注：所以推荐使用成熟的中间件，如sharding-jdbc，Atlas，Cobar</p>
<h2 id="8-5-分布式ID"><a href="#8-5-分布式ID" class="headerlink" title="8.5 分布式ID"></a>8.5 分布式ID</h2><ol>
<li>UUID：生成简单，但不推荐！长度过长，不适合实际的业务需求。<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; 
       String uuid = UUID.randomUUID().toString().replaceAll(<span class="hljs-string">"-"</span>,<span class="hljs-string">""</span>);
       System.out.println(uuid);
 &#125;</code></pre></li>
<li>数据库自增ID：用一个单独数据库实例生成ID，需要ID时，向表中插入记录并返回ID。<ul>
<li>MySQL本身性能是瓶颈，而且存在宕机风险。</li>
</ul>
</li>
<li>数据库集群：对每个MySQL实例的自增ID设置起始值和自增步长，保证不冲突。<ul>
<li>后续扩容问题大，无法满足高并发。</li>
</ul>
</li>
<li>数据库号段模式：每次从数据库获取一个号段范围，具体业务将号段生成对应自增ID加载到内存。一批号段ID用完，再向数据库申请新的。<ul>
<li>用版本号乐观锁更新；不频繁访问数据库。</li>
</ul>
</li>
<li><strong>雪花算法</strong>：twitter公司开源的算法。<ul>
<li>Snowflake生成Long型<strong>64位ID</strong>。</li>
<li>组成结构：正数位（1bit，默认0）+ 时间戳（41bit，存储 当前-固定开始 的差值）+ 机器ID（5bit）+ 数据中心（5bit）+ 自增值（12bit，1ms支持同一节点生成4096个ID）</li>
</ul>
</li>
</ol>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/MySQL/">MySQL</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/05/08/%E6%AF%8F%E5%91%A8%E4%BB%BB%E5%8A%A1/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">每周任务</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/05/08/%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E5%92%8C%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/">
                        <span class="hidden-mobile">认证授权和网络攻击</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>






<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "MySQL&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















</body>
</html>
