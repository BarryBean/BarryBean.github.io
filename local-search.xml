<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Socket相关</title>
    <link href="/2020/04/28/Socket%E7%9B%B8%E5%85%B3/"/>
    <url>/2020/04/28/Socket%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-IO模型"><a href="#1-IO模型" class="headerlink" title="1. IO模型"></a>1. IO模型</h1><p>Socket的输入操作有两步。</p><ol><li>wait for data - 等待网络传输数据到达，到达后复制到内核缓冲区；</li><li>copy data from kernel to user - 把数据从内核缓冲区复制到应用进程缓冲区。</li></ol><p>涉及到两个对象：application调用这个IO的进程/线程，kernel系统内核。</p><h2 id="1-1-同步阻塞IO"><a href="#1-1-同步阻塞IO" class="headerlink" title="1.1 同步阻塞IO"></a>1.1 同步阻塞IO</h2><p>用户线程发出请求后就一直被阻塞，直到数据到达并从内核缓冲区复制到进程缓冲区才返回。</p><p><img src="82107380196C4FDBBE75E51BB58B49F4" srcset="/img/loading.gif" alt="阻塞式IO"></p><h2 id="1-2-同步非阻塞IO"><a href="#1-2-同步非阻塞IO" class="headerlink" title="1.2 同步非阻塞IO"></a>1.2 同步非阻塞IO</h2><p>用户线程发出请求后，内核立即返回错误码，但用户线程需要不断发出IO请求询问内核数据到达没，到达了才进行第二阶段。这个过程叫做轮询。</p><p><img src="90691756132E4631AC3EDE615FCA3D1F" srcset="/img/loading.gif" alt="非阻塞IO"></p><h2 id="1-3-IO多路复用-异步阻塞IO"><a href="#1-3-IO多路复用-异步阻塞IO" class="headerlink" title="1.3 IO多路复用/异步阻塞IO"></a>1.3 IO多路复用/异步阻塞IO</h2><p>又称为事件驱动IO，单个进程有处理多个IO的能力，避免一个socket一个线程的开销和切换。用户注册多个socket，reactor一对多监听，不断调用select读取激活的socket，再一对多分发给对应处理器处理。</p><p><img src="AE833320E6B645EFB32CE0BB00DAAD82" srcset="/img/loading.gif" alt="IO多路复用"></p><p>使用了 Reactor 反应堆模型。</p><ul><li>将用户线程轮询IO操作状态的工作交给事件处理器，用户线程可以继续执行做其他的工作，Reactor线程负责调用内核的select函数检查socket状态。</li><li>当有socket被激活时，则通知相应的用户线程，执行handle_event进行数据读取、处理的工作。</li><li>由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。</li></ul><h2 id="1-4-信号驱动IO-异步非阻塞IO"><a href="#1-4-信号驱动IO-异步非阻塞IO" class="headerlink" title="1.4 信号驱动IO/异步非阻塞IO"></a>1.4 信号驱动IO/异步非阻塞IO</h2><p>sigaction系统调用，内核立即返回，应用进程可以去干其他事，当数据到达时，内核发送SIGIO信号给应用进程通知应用进程可以进行IO的数据复制。</p><p>相比于轮询方式，CPU利用率更高。<br><img src="BE248B862A5C4864ADD43206817336FB" srcset="/img/loading.gif" alt="信号驱动IO"></p><h2 id="1-5-异步IO"><a href="#1-5-异步IO" class="headerlink" title="1.5 异步IO"></a>1.5 异步IO</h2><p>aio_read系统调用立即返回，应用进程可以去干其他事，内核在完成所有操作后发送信号，通知应用进程IO已经完成。<br><img src="7E6AF64F5C054B4CA69DBB263E0F42CE" srcset="/img/loading.gif" alt="异步IO"></p><h2 id="1-6-比较"><a href="#1-6-比较" class="headerlink" title="1.6 比较"></a>1.6 比较</h2><ul><li>同步IO：将数据从内核缓冲区复制到应用进程缓冲区时，应用进程会阻塞。</li><li>异步IO：第二阶段不会阻塞。</li><li>阻塞IO：第一阶段就阻塞线程，直到获得数据。</li><li>非阻塞IO：线程发出请求立即返回，但需要轮询或者再次进行系统调用进行第二阶段。</li></ul><h1 id="2-wakeup-callback机制"><a href="#2-wakeup-callback机制" class="headerlink" title="2. wakeup callback机制"></a>2. wakeup callback机制</h1><p>Linux 内核的事件唤醒回调机制是IO多路复用的本质。</p><p>概括来说，Linux<strong>通过睡眠队列管理所有等待 Socket 事件的线程，通过 wakeup 机制异步唤醒整个睡眠队列上等待事件的线程，通知线程事件发生</strong>。</p><ol><li>睡眠等待<ul><li>select、poll、epoll 陷入内核，判断监控的 socket 是否有关心的事件发生，如果没，则为当前 process 构建一个 wait_entry 节点，插入到监控 socket 的 sleep_list；</li><li>进入循环的 schedule 直到关心的事件发生；</li><li>事件发生后，将当前线程的 wait_entry 节点从 socket 的 sleep_list 中删除。</li></ul></li><li>异步唤醒<ul><li>socket 顺序遍历其睡眠队列，依次调用每个节点的 callback 函数；</li><li>直到完成遍历或者遇到某个排他节点。</li></ul></li></ol><h1 id="3-IO复用机制"><a href="#3-IO复用机制" class="headerlink" title="3. IO复用机制"></a>3. IO复用机制</h1><p>fd 文件描述符，用于表述指向文件的引用的抽象化概念。</p><h2 id="3-1-Select"><a href="#3-1-Select" class="headerlink" title="3.1 Select"></a>3.1 Select</h2><p>底层通过一个long类型的数组 fd_set，存放文件句柄。</p><p>每次调用select时，把 fd_set 集合从用户态复制到内核态，在内核轮询遍历集合，且对集合有 1024 的大小限制。</p><p>内部的轮询，是通过为每个 socket 添加 poll 逻辑，用来收集该 socket 发生的事件。轮询就是遍历 socket 调用 poll 逻辑，直到有事件发生。</p><p>所以存在三个问题：</p><ol><li>fd 集合限制为 1024；</li><li>fd 集合每次都要从用户态拷贝到内核态；</li><li>每次都在遍历集合收集可读数据。</li></ol><h2 id="3-2-poll"><a href="#3-2-poll" class="headerlink" title="3.2 poll"></a>3.2 poll</h2><p>本质上和select一样，解决了 fd 集合大小限制问题。底层通过链表形式 pollfd 实现，所以没有最大连接数的限制。</p><p>其他两个缺点并没有改进，不适用大并发场景。</p><h2 id="3-3-epoll"><a href="#3-3-epoll" class="headerlink" title="3.3 epoll"></a>3.3 epoll</h2><p>只适用于Linux。</p><ol><li>针对集合拷贝。<ul><li>使用事件回调通知，通过 epoll_ctl() 注册fd进行增删改，调用 epoll_wait() 等待事件产生。</li><li>内核 2.6.8 之前底层使用哈希表存储，之后使用红黑树</li><li>epoll_wait() 通过将内核空间和用户空间(都是虚拟地址)映射到同一块物理内存地址，用来减少用户态和内核态间的数据交换。</li></ul></li><li>针对集合遍历。<ul><li>引入中间层，为每个 socket 提供单独的回调函数，当其就绪时将自身加入准备队列 ready_list 中；</li><li>等待线程的回调函数遍历 ready_list 上所有的 socket，调用 poll 逻辑收集事件，唤醒线程。</li></ul></li></ol><h3 id="3-3-1-工作模式"><a href="#3-3-1-工作模式" class="headerlink" title="3.3.1 工作模式"></a>3.3.1 工作模式</h3><ul><li>Level Triggered 水平触发。默认模式，只要fd还有事件，每次 epoll_wait() 都会再次通知进程。</li><li>Edge Triggered 边沿触发。通知之后进程必须立即处理事件，下次 epoll_wait() 不会收到该fd的通知。</li></ul><h2 id="3-4-比较"><a href="#3-4-比较" class="headerlink" title="3.4 比较"></a>3.4 比较</h2><p> 方式 |select | poll | epoll|<br>|—|—|—|—|<br>操作方式|遍历 |遍历|回调|<br>底层实现|数组| 链表|哈希表/红黑树|<br>最大连接数|1024 or 2048| 无上限|无上限|<br>IO效率|轮询O(n)|轮询O(n)|事件回调，将就绪的fd放进就绪队列，每次只用判断队列是否为空O(1)<br>fd拷贝|每次调用都把fd集合从用户态拷贝到内核态|每次调用都把fd集合从用户态拷贝到内核态|调用epoll_ctl()时fd拷贝进内核并保存</p><h2 id="2-5-适用场景"><a href="#2-5-适用场景" class="headerlink" title="2.5 适用场景"></a>2.5 适用场景</h2><ol><li>select的时间精度是微秒，适用实时性要求高的场景。</li><li>poll没有最大描述符限制，若实时性要求不高且平台支持，用poll。</li><li>epoll适用Linux平台，且有大量描述符需要同时轮询。</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发</title>
    <link href="/2020/04/28/Java%E5%B9%B6%E5%8F%91/"/>
    <url>/2020/04/28/Java%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2020/04/28/MySQL/"/>
    <url>/2020/04/28/MySQL/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2020/04/27/Redis/"/>
    <url>/2020/04/27/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><h2 id="1-1-NoSQL"><a href="#1-1-NoSQL" class="headerlink" title="1.1 NoSQL"></a>1.1 NoSQL</h2><p>答：NoSQL(Not Only SQL)，泛指非关系型的数据库，目的是解决高并发、高拓展和大数据储存问题。细分为：键值型(Redis)，列存储(HBase)，文档型(MongoDB)，图形(Neo4j)。</p><h2 id="1-2-Redis"><a href="#1-2-Redis" class="headerlink" title="1.2 Redis"></a>1.2 Redis</h2><p>答：Redis(Remote Dictionary Server远程字典服务)是一款<strong>高性能、高并发</strong>的<strong>key-value型分布式内存数据库</strong>，基于内存运行且支持<strong>持久化</strong>的NoSQL数据库。常被用于缓存和消息队列。</p><h3 id="1-2-1-优缺点"><a href="#1-2-1-优缺点" class="headerlink" title="1.2.1 优缺点"></a>1.2.1 优缺点</h3><p>优点</p><ul><li>高性能/读写性能优异。用户第一次访问数据后，数据存储在缓存中，之后再访问直接从缓存中获得，相当于直接操作内存。</li><li>高并发。操作缓存能承受的请求远大于直接访问数据库，将部分数据放在redis中，能提高并发程度。</li><li>支持数据持久化，AOF和RDB两种方式。</li><li>支持事务，所有操作都是原子性的。</li><li>数据类型丰富，string、hash、set、list、sorted set。</li><li>支持集群模式，如主从复制做到读写分离。</li></ul><p>缺点</p><ul><li>数据库容量受到物理内存的限制；</li><li>不具备自动容错和恢复功能。如主机宕机，部分数据未能同步到从机，切换IP后会导致数据不一致；</li><li>扩容难。</li></ul><h3 id="1-2-2-为什么执行速度快"><a href="#1-2-2-为什么执行速度快" class="headerlink" title="1.2.2 为什么执行速度快"></a>1.2.2 为什么执行速度快</h3><p>答：总结如下：</p><ul><li>基于内存实现，轻量级数据库；</li><li>单线程操作，避免切换上下文，也没有线程安全问题；</li><li>多路IO复用模型，一个线程监控多个IO流，事件放队列，派发器分发，对应处理器处理。</li></ul><h3 id="1-2-3-Redis和map区别"><a href="#1-2-3-Redis和map区别" class="headerlink" title="1.2.3 Redis和map区别"></a>1.2.3 Redis和map区别</h3><p>答：缓存分为本地缓存和分布式缓存。</p><ul><li>map是本地缓存，优点是轻量快速，缺点是多实例情况下，每个实例都有一个缓存。</li><li>Redis是分布式缓存，多实例情况下，每个实例共用一个缓存，具有一致性，缺点是架构复杂。</li></ul><h3 id="1-2-4-Redis和memcached区别"><a href="#1-2-4-Redis和memcached区别" class="headerlink" title="1.2.4 Redis和memcached区别"></a>1.2.4 Redis和memcached区别</h3><p>答：主要是四点：</p><ul><li>Redis数据类型丰富，memcached只支持String类型；</li><li>Redis支持数据持久化，RDB和AOF，memcached全部存在内存；</li><li>Redis支持集群模式(主从，哨兵)，memcached没有原生的集群模式；</li><li>Redis是单线程的多路IO复用模型，memcached是多线程的非阻塞IO复用模型</li></ul><h2 id="1-3-数据类型和应用场景"><a href="#1-3-数据类型和应用场景" class="headerlink" title="1.3 数据类型和应用场景"></a>1.3 数据类型和应用场景</h2><p>答：支持五种数据类型作为value，key值都是字符串类型。</p><ul><li>string：最大为512M。用作计数器，缓存，用户的Session等；</li><li>list：有序列表，基于链表实现。用作分页查询，列表功能，消息队列/异步队列(左进右出)；</li><li>set：自动去重的列表。用作全局去重等功能，比如共同好友；</li><li>sorted set：多了权重参数。用来做排序，比如排行榜Top10功能，延时队列(时间戳做排序，内容做key，消费者根据score获取数据)；</li><li>hash：存储特定结构的信息/结构化数据。比如用户信息。</li><li>pub/sub：主题订阅者模式，实现1:N的消息队列，但消费者下线后，生产的消息就丢失了。</li></ul><h2 id="1-4-底层数据类型"><a href="#1-4-底层数据类型" class="headerlink" title="1.4 底层数据类型"></a>1.4 底层数据类型</h2><p>Redis底层的数据类型有</p><ol><li>动态字符串SDS：Redis封装的字符串，具有良好的伸缩性。O(1)获取字符串长度，空间预分配防止溢出。</li><li>链表：顺序存储对象信息，双端链表，保证无环。</li><li>字典：key-value 存储方式。通过hash值计算存储位置，使用拉链法解决哈希冲突，容量过大rehash重新分配。</li><li>跳跃表：sort set 的底层实现之一，基于多个有序链表实现。查找时，从上层指针开始，找到对应的区间后再到下一层查找。因为不用旋转维护平衡所以，插入速度比红黑树快。<br><img src="/img/db/%E8%B7%B3%E8%B7%83%E8%A1%A8%E6%9F%A5%E6%89%BE.png" srcset="/img/loading.gif" alt="跳跃表查找"></li><li>整数集合：只能存储少量整数数据的特殊集合。</li><li>压缩列表：为节约内存而存在的结构，当列表项为小整数或短字符串，就用压缩列表。列表键和哈希键的底层实现之一。</li></ol><h2 id="1-5-Redis线程模型"><a href="#1-5-Redis线程模型" class="headerlink" title="1.5 Redis线程模型"></a>1.5 Redis线程模型</h2><p>答：Redis是<strong>单线程</strong>的。</p><ul><li>内部使用了单线程的<strong>文件事件处理器</strong> file event handler。</li><li>采用<strong>IO多路复用</strong>机制同时监听多个socket，将socket上的事件放入队列，事件派发器每次从队列中取出一个事件，交给对应的事件处理器处理。</li><li>文件事件处理器包含4个部分：多个socket，IO多路复用程序，文件事件派发器，事件处理器。</li></ul><p>总结：<strong>一对多监听，事件放队列，派发器分发，对应处理器处理</strong></p><h1 id="2-持久化"><a href="#2-持久化" class="headerlink" title="2. 持久化"></a>2. 持久化</h1><p>答：把内存数据写入磁盘，保证宕机再重启数据能恢复。有RDB和AOF两种持久化方式。</p><h2 id="2-1-RDB-快照持久化"><a href="#2-1-RDB-快照持久化" class="headerlink" title="2.1 RDB-快照持久化"></a>2.1 RDB-快照持久化</h2><p>答：<strong>将内存中的数据集以快照形式写入磁盘，恢复时载入快照到内存。</strong> Redies<strong>默认采用</strong>。</p><h3 id="2-1-1-触发方式"><a href="#2-1-1-触发方式" class="headerlink" title="2.1.1 触发方式"></a>2.1.1 触发方式</h3><ul><li>自动触发：每隔多少秒，有多少数据发生变化，就自动触发持久化；</li><li>手动触发：bgsave命令，异步进行创建快照。</li></ul><h3 id="2-1-2-优缺点"><a href="#2-1-2-优缺点" class="headerlink" title="2.1.2 优缺点"></a>2.1.2 优缺点</h3><ul><li>优点：只有一个.rdb文件，恢复快，随时可以转移，性能好。</li><li>缺点：安全性差，没法实时持久化。(隔段时间持久化一次，频繁手动性能低)</li></ul><h3 id="2-1-3-原理"><a href="#2-1-3-原理" class="headerlink" title="2.1.3 原理"></a>2.1.3 原理</h3><ul><li>fork：redis通过创建子进程来进行RDB操作</li><li>cow：copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</li><li>当父进程要更改其中某片数据时（如执行一个写命令），操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的RDB文件存储的是执行fork一刻的内存数据。</li></ul><h2 id="2-2-AOF-增量持久化"><a href="#2-2-AOF-增量持久化" class="headerlink" title="2.2 AOF-增量持久化"></a>2.2 AOF-增量持久化</h2><p>答：<strong>将redis执行的所有写命令记录到日志文件中，恢复时将AOF文件载入内存。</strong>一般采用<strong>每秒钟同步一次</strong>everysec的方式。默认关闭，appendonly yes 开启配置。</p><h3 id="2-2-1-AOF重写"><a href="#2-2-1-AOF重写" class="headerlink" title="2.2.1 AOF重写"></a>2.2.1 AOF重写</h3><p>答：AOF文件随着服务器运行时间增长而越来越大，AOF重写能<strong>减小文件大小</strong>，而且<strong>数据库状态一致</strong>。</p><ul><li>读取数据库现有的键值对状态，<strong>用一条命令替代</strong>之前对键值对操作的<strong>多条命令</strong>，再用bgrewriteaof实现重写。</li><li>在<strong>子进程中执行</strong>。redis会维护一个AOF重写缓冲区，在子进程创建AOF期间，记录写命令；当子进程重写完成后，服务器将重写缓冲区内的内容添加到AOF文件的末尾，以保持状态一致。</li></ul><p>流程</p><ul><li>从主进程中fork出子进程，并拿到fork时的AOF文件数据写到一个临时AOF文件中</li><li>在重写过程中，redis收到的命令会同时写到AOF缓冲区和重写缓冲区中，这样保证重写不丢失重写过程中的命令</li><li>重写完成后通知主进程，主进程会将AOF缓冲区中的数据追加到子进程生成的文件中</li><li>redis会原子的将旧文件替换为新文件，并开始将数据写入到新的aof文件上</li></ul><p>总结：<strong>用个缓冲区，暂时存操作，完成重写后，再添文件末。</strong></p><h3 id="2-2-2-优缺点"><a href="#2-2-2-优缺点" class="headerlink" title="2.2.2 优缺点"></a>2.2.2 优缺点</h3><ul><li>优点：安全性好，秒级持久化。</li><li>缺点：需要更多的IO资源，AOF文件也较大，恢复慢；</li></ul><p>注：redis4.0后，支持RDB和AOF的混合持久化，RDB作为全量备份，AOF作为增量备份。</p><h1 id="3-过期策略和内存淘汰"><a href="#3-过期策略和内存淘汰" class="headerlink" title="3. 过期策略和内存淘汰"></a>3. 过期策略和内存淘汰</h1><p>Redis是键值型数据库，缓存的key总是会有过期时间，过期策略就是回收这些过期的key。</p><p>内存淘汰是在Redis缓存内存不足时，又有新写入，需要淘汰过期内存的策略。</p><p><strong>注：过期回收针对过期key，内存淘汰针对内存不足。</strong></p><h2 id="3-1-过期回收策略"><a href="#3-1-过期回收策略" class="headerlink" title="3.1 过期回收策略"></a>3.1 过期回收策略</h2><p>答：redis中的数据过期使用了<strong>定期删除和惰性删除相结合</strong>的方式。</p><ul><li>定期删除：redis默认每隔100ms就随机抽取一定量的数据判断是否过期，过期就删除；</li><li>惰性删除：在获取一个key时，redis会检查这个key是否过期，若过期则删除。</li></ul><p>如果定期删除漏掉很多过期key，用户也没及时去查，没用惰性删除，导致大量过期key积压在内存中，消耗资源，所以需要内存淘汰。</p><h2 id="3-2-内存淘汰-保存热点数据"><a href="#3-2-内存淘汰-保存热点数据" class="headerlink" title="3.2 内存淘汰/保存热点数据"></a>3.2 内存淘汰/保存热点数据</h2><h3 id="3-2-1-淘汰策略"><a href="#3-2-1-淘汰策略" class="headerlink" title="3.2.1 淘汰策略"></a>3.2.1 淘汰策略</h3><p>答：redis提供了6种数据淘汰策略。</p><p>设置过期时间的key</p><ul><li><strong>volatile-lru</strong>：用LRU算法移除设置了过期时间的key；</li><li><strong>volatile-ttl</strong>：移除设置了过期时间的有更早过期时间的key；</li><li><strong>volatile-random</strong>：随机移除设置了过期时间的key；</li></ul><p>全局的key</p><ul><li><strong>allkeys-lru</strong>：内存不足时，用LRU算法移除任意key；</li><li><strong>allkeys-random</strong>：随机移除任意key；</li><li><strong>no-eviction</strong>：不移除任何key，只返回错误信息。默认。</li></ul><h3 id="3-2-2-回收流程"><a href="#3-2-2-回收流程" class="headerlink" title="3.2.2 回收流程"></a>3.2.2 回收流程</h3><ol><li>客户端执行新命令</li><li>Redis检查内存使用情况，大于maxmemory则按设定的内存淘汰策略回收内存</li><li>继续执行命令</li></ol><h1 id="4-事务"><a href="#4-事务" class="headerlink" title="4. 事务"></a>4. 事务</h1><h2 id="4-1-Redis事务"><a href="#4-1-Redis事务" class="headerlink" title="4.1 Redis事务"></a>4.1 Redis事务</h2><p>答：redis事务本质是通过MULTI、EXEC、WATCH和DISCARD等一组命令集合执行。执行过程是<strong>一次性的</strong>(不会中断一直运行)，<strong>顺序性的</strong>(串行化执行)，<strong>排他性的</strong>(不会在中间插入别的命令)。</p><h2 id="4-2-相关命令"><a href="#4-2-相关命令" class="headerlink" title="4.2 相关命令"></a>4.2 相关命令</h2><ul><li>MULTI：标记一个事务块的开始。</li><li>EXEC：执行所有事务块内的命令。</li><li>DISCARD：取消事务，放弃执行事务块内的所有命令。</li><li>UNWATCH：取消 WATCH 命令对所有 key 的监视。</li><li>WATCH key [key …]：监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</li></ul><h2 id="4-3-内部实现"><a href="#4-3-内部实现" class="headerlink" title="4.3 内部实现"></a>4.3 内部实现</h2><ol><li>redis<strong>不支持回滚，不保证原子性</strong>，事务失败也继续执行。</li><li>单条命令是原子性，但整个事务不是原子性。</li><li>命令语法错误或操作类型不规范才停止执行。</li></ol><h1 id="5-集群方案"><a href="#5-集群方案" class="headerlink" title="5. 集群方案"></a>5. 集群方案</h1><h2 id="5-1-主从复制机制"><a href="#5-1-主从复制机制" class="headerlink" title="5.1 主从复制机制"></a>5.1 主从复制机制</h2><p>答：主从(Master-Slave)机制，主机以写为主，从机以读为主，有效避免单点故障导致的数据丢失，主从数据库的数据实时同步。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol><li>从数据库启动，向主数据库发送同步请求；</li><li>主数据库收到后，进行RDB快照，并将快照过程中的收到命令缓存起来；</li><li>快照完成后，将.rdb文件和所有缓存的命令发给从数据库；</li><li>从数据库收到后，进行快照同步并执行收到的缓存命令。<br><img src="/img/db/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></li></ol><h2 id="5-2-哨兵模式"><a href="#5-2-哨兵模式" class="headerlink" title="5.2 哨兵模式"></a>5.2 哨兵模式</h2><p>答：哨兵(Sentinel)模式，用于管理多个Redis服务器。哨兵至少需要3个实例才能保持健壮性。一般都使用哨兵 + 主从架构保证<strong>高可用</strong>。</p><h3 id="5-2-1-功能"><a href="#5-2-1-功能" class="headerlink" title="5.2.1 功能"></a>5.2.1 功能</h3><p>主要有三个功能：</p><ul><li><strong>监控</strong>：哨兵会不断检查主机和从机是否运行正常；</li><li><strong>通知</strong>：当被监控的某个redis发生问题，哨兵会发送通知；</li><li><strong>故障迁移</strong>：当主机不能正常工作，哨兵会选择主机的一个从机升级为主机，让其他从机改为复制新主机。旧主机复活时，将其变为新主机的从机，最后向客户端通知主机的变化。</li></ul><h3 id="5-2-2-节点下线"><a href="#5-2-2-节点下线" class="headerlink" title="5.2.2 节点下线"></a>5.2.2 节点下线</h3><ul><li>主观下线：哨兵认为此redis节点发生了故障，就主观下线该节点。通过心跳包检测实现。</li><li>客观下线：所有哨兵中的多数(&gt;quorum)认为此redis节点主观下线，则该节点客观下线。</li></ul><h3 id="5-2-3-Leader选举"><a href="#5-2-3-Leader选举" class="headerlink" title="5.2.3 Leader选举"></a>5.2.3 Leader选举</h3><p>故障转移时，需要哨兵选出一个leader进行后续操作。</p><p>流程为：每个主管下线的哨兵向其他哨兵发出设置他为Leader的命令，当票数达到设定值时，称为领导者。若有多个哨兵当选Leader，则等待一段时间再选举。<br><img src="/img/db/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" srcset="/img/loading.gif" alt=""></p><h1 id="6-分布式锁"><a href="#6-分布式锁" class="headerlink" title="6. 分布式锁"></a>6. 分布式锁</h1><p>当多客户端并发操作Redis，可能出现并发竞争，需要分布式锁帮助管理顺序。</p><h2 id="6-1-实现"><a href="#6-1-实现" class="headerlink" title="6.1 实现"></a>6.1 实现</h2><ul><li>用 setnx (set if not exists)争抢锁。key不存在就设为value，存在不做动作。</li><li>抢到后，用 expire 给锁加一个过期时间防止锁忘记了释放。</li><li>可以通过参数将setnx和expire合成一条指令。</li></ul><h2 id="6-2-举例"><a href="#6-2-举例" class="headerlink" title="6.2 举例"></a>6.2 举例</h2><ol><li>每个系统通过 Zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个Key。</li><li>写入/查询MySQL时必须保存一个时间戳，每次都要判断当前 Value 的时间戳是否比缓存里的 Value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</li></ol><h1 id="7-缓存异常"><a href="#7-缓存异常" class="headerlink" title="7. 缓存异常"></a>7. 缓存异常</h1><h2 id="7-1-缓存雪崩"><a href="#7-1-缓存雪崩" class="headerlink" title="7.1 缓存雪崩"></a>7.1 缓存雪崩</h2><p>答：缓存雪崩是指缓存同一时间大面积失效，这时有一波请求访问数据库，导致数据库崩掉。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>事前：保证redis服务器的高可用，发现宕机就立马补上，内部选择恰当的内存淘汰机制，设置随机的key失效时间(保证不会同时大面积失效)；</li><li>事中：本地ehcache缓存 + 限流和降级处理，避免数据库崩溃；</li><li>事后：redis持久化尽快恢复缓存数据。<br><img src="/img/db/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></li></ul><h2 id="7-2-缓存穿透"><a href="#7-2-缓存穿透" class="headerlink" title="7.2 缓存穿透"></a>7.2 缓存穿透</h2><p>答：故意请求不在缓存也不在数据库中的数据，导致大量请求直接打到数据库上，导致崩溃。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>参数校验：将不合法的参数请求直接抛异常。</li><li>缓存无效key：若缓存和数据库都查不到数据，就写一个到redis中并设置过期时间。</li><li><strong>布隆过滤器</strong>：把所有可能的请求值放在布隆过滤器中，用户请求时先判断是否存在，不存在直接返回错误信息。<br><img src="/img/db/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F+%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></li></ul><h2 id="7-3-缓存击穿"><a href="#7-3-缓存击穿" class="headerlink" title="7.3 缓存击穿"></a>7.3 缓存击穿</h2><p>答：缓存击穿是指缓存中没有但数据库中有的数据，同时大并发去数据库查询同一条数据，导致崩溃。比如缓存热点数据key失效后的处理。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>设置热点数据永不过期</li><li>对缓存查询加互斥锁。key不存在就加锁查DB写缓存，然后解锁；其他进程发现有锁就等待，等解锁后从缓存中拿数据。</li></ul><h2 id="7-4-缓存降级"><a href="#7-4-缓存降级" class="headerlink" title="7.4 缓存降级"></a>7.4 缓存降级</h2><p>答：缓存降级是指服务出现问题或非核心服务影响到核心流程的性能时，弃车保帅，保证核心服务可用，即使是有损服务。</p><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>必须对系统进行梳理排序，从而确定可以降级的模块。</li><li>一般对不重要的缓存数据，可以直接返回默认值，而不去访问数据库。</li></ul><h2 id="7-5-双写一致性"><a href="#7-5-双写一致性" class="headerlink" title="7.5 双写一致性"></a>7.5 双写一致性</h2><p>答：高并发情况下很容易因为操作失败而导致数据不一致。</p><h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p>强一致性：<strong>读写请求串行化</strong>，每次只能进行一个操作，保证数据库和缓存时刻相同。</p></li><li><p>最终一致性：数据库和缓存可以存在不一致的情况。</p><ul><li><strong>双删延迟</strong>：先删除缓存数据，再更新数据库数据，最后隔段时间再删除缓存。</li><li>原理：如果数据库更新失败，那么数据库中是旧数据，缓存中是空的，数据不会不一致。因为读的时候没有缓存，所以去读了数据库中的旧数据，然后更新到缓存中。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合</title>
    <link href="/2020/04/27/Java%E9%9B%86%E5%90%88/"/>
    <url>/2020/04/27/Java%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><h2 id="1-1-List-Set-Map区别"><a href="#1-1-List-Set-Map区别" class="headerlink" title="1.1 List,Set,Map区别"></a>1.1 List,Set,Map区别</h2><p>答：Java容器分为Collection和Map两大类。List和Set是Collection的子接口。</p><ul><li>List（解决顺序问题）：存储一组有序可重复的对象，实现类有ArrayList、LinkedList和Stack等。</li><li>Set（元素独一无二）：不存在重复的元素，实现类有HashSet、TreeSet等。</li><li>Map（Key值搜索）：键值对存储，Key值不能重复，但能引用相同的对象，实现类有HashMap、ConcurrentHashMap等。</li></ul><h2 id="1-2-快速失败"><a href="#1-2-快速失败" class="headerlink" title="1.2 快速失败"></a>1.2 快速失败</h2><p>答：快速失败(fail-fast)是Java集合中的<strong>错误检测机制</strong>。遍历集合过程中，若线程对集合进行增删改，会抛出并发修改异常。</p><p>原理</p><ul><li>迭代器遍历过程中，使用一个modCount变量。若集合在遍历期间发生改变，modCount就会变化。hasNext()前都会检测modCount变量是否为exceptedModCount值，不是就抛出异常。</li><li>无法处理并发。</li><li>可以在所有涉及改变modCount的地方加synchronized同步锁避免fail-fast。</li></ul><p>还可以将其理解为一种设计原则，当有某种条件导致模块无法正常运行，就立即终止运行，避免下游脏数据/便于排查。</p><h2 id="1-3-安全失败"><a href="#1-3-安全失败" class="headerlink" title="1.3 安全失败"></a>1.3 安全失败</h2><p>答：安全失败(fail-safe)的集合(JUC包)是多线程下使用的。遍历前先拷贝原有集合内容，在拷贝的集合上遍历。</p><ul><li>迭代时是对拷贝集合操作，不会出现并发修改异常；</li><li>无法保证读取的数据是最新的数据。(迭代器只有开始遍历时才拿到拷贝，之后原数据发生变动是不知道的)</li></ul><p>还可以理解为一种设计原则，当模块遇到错误，不终止执行，而是采用降级策略，尽量往下走。适用于主模块的分支流程。</p><h1 id="2-Map接口"><a href="#2-Map接口" class="headerlink" title="2.Map接口"></a>2.Map接口</h1><h2 id="2-1-HashMap"><a href="#2-1-HashMap" class="headerlink" title="2.1 HashMap"></a>2.1 HashMap</h2><p>答：HashMap是基于Hash算法实现的由数组和链表组合的数据结构，允许使用null值和null键。</p><p>总结：用数组存储，将冲突的key对象放入链表中，再发生冲突就在链表中顺序做对比。</p><h3 id="2-1-1-插入元素"><a href="#2-1-1-插入元素" class="headerlink" title="2.1.1 插入元素"></a>2.1.1 插入元素</h3><ul><li>put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标；</li><li>如果出现hash值相同的key，若key相同，则覆盖原始值；若key不同即出现冲突，则将当前的key-value放入链表中</li><li>java8前用头插法，新来的值代替原有值，原有值被往后推。问题是，扩容后容易形成环形链表。</li><li>java8后用尾插法。在扩容同时保证链表元素原来的顺序，避免形成环。</li></ul><h3 id="2-1-2-读取元素"><a href="#2-1-2-读取元素" class="headerlink" title="2.1.2 读取元素"></a>2.1.2 读取元素</h3><ul><li>get元素时，找hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li></ul><h3 id="2-1-3-多线程"><a href="#2-1-3-多线程" class="headerlink" title="2.1.3 多线程"></a>2.1.3 多线程</h3><p>答：hashmap线程不安全。put/get方法没有同步锁，容易出现上一秒put值，下一秒get的还是原值。</p><h2 id="2-2-HashMap和HashTable的区别"><a href="#2-2-HashMap和HashTable的区别" class="headerlink" title="2.2 HashMap和HashTable的区别"></a>2.2 HashMap和HashTable的区别</h2><ol><li>线程安全：HashMap线程不安全；HashTable内部使用synchronized关键字，线程安全。</li><li>Null Key支持：HashMap中null可作为Key；HashTable中null不能作key也不能作value。</li><li>效率：HashMap比HashTable效率高一点，而且HashTable基本淘汰了。</li><li>初始容量：HashMap是16，HashTable是11。</li><li>扩容机制：HashMap是当前容量翻倍，Hashtable是当前容量翻倍+1。</li></ol><h3 id="2-2-1-为什么HashTable的null不能做key和value"><a href="#2-2-1-为什么HashTable的null不能做key和value" class="headerlink" title="2.2.1 为什么HashTable的null不能做key和value"></a>2.2.1 为什么HashTable的null不能做key和value</h3><p>答：两点原因。</p><ul><li>HashTable在put空值时会抛空指针异常。HashMap做了三目运算的处理，null就设0。</li><li>安全失败机制。让此次读取的数据不一定是最新，同时key为null就无法判断key是不存在还是空。</li></ul><h3 id="2-2-2-线程不安全"><a href="#2-2-2-线程不安全" class="headerlink" title="2.2.2 线程不安全"></a>2.2.2 线程不安全</h3><ul><li>HashMap线程不安全。因为多线程环境下扩容，导致hash规则变化，可能形成环形链表，死循环。</li><li>HashTable线程安全。因为内部实现put和remove方法时使用synchronized同步，所以对单个方法的使用是线程安全的。但对多个方法复合操作时，无法保证安全性。</li></ul><h2 id="2-3-HashMap的底层结构"><a href="#2-3-HashMap的底层结构" class="headerlink" title="2.3 HashMap的底层结构"></a>2.3 HashMap的底层结构</h2><p>答：JDK1.8之前，用数组+链表用链地址法实现。所谓拉链法，就是数组链表，数组的每一格就是一个链表，遇到哈希冲突，则将冲突值加入链表。</p><p>JDK1.8之后使用数组+链表+红黑树实现，解决链表过长而查询速度变慢。<br><img src="/img/java/HashMap.png" srcset="/img/loading.gif" alt="HashMap"></p><p>流程：</p><ul><li>hash后算出下标，没有冲突就直接放进node；</li><li>有冲突，链地址法，用链表链接相同hash值的数据；</li><li>链表长度&gt;8且数组长度&lt;64，先进行扩容；</li><li>链表长度&gt;8且数组长度&gt;64，转为红黑树，加速遍历。</li></ul><h2 id="2-4-扩容"><a href="#2-4-扩容" class="headerlink" title="2.4 扩容"></a>2.4 扩容</h2><p>答：HashMap的<strong>初始容量16，加载因子0.75，扩容增量是原容量的1倍</strong>。HashMap中的元素个数超过 初始容量16 * 加载因子0.75 = 12 后进行扩容。扩容分为两步。</p><ul><li>创建新数组：创建原来HashMap大小两倍的bucket数组。</li><li>ReHash：遍历原数组，将对象重新hash后放入新数组中。</li></ul><h3 id="2-4-1-为啥要rehash"><a href="#2-4-1-为啥要rehash" class="headerlink" title="2.4.1 为啥要rehash"></a>2.4.1 为啥要rehash</h3><p>答：因为长度扩大后，hash规则也改变。key &amp; (length-1)</p><h3 id="2-4-2-长度为什么是2的幂-初始长度为什么是16"><a href="#2-4-2-长度为什么是2的幂-初始长度为什么是16" class="headerlink" title="2.4.2 长度为什么是2的幂/初始长度为什么是16"></a>2.4.2 长度为什么是2的幂/初始长度为什么是16</h3><p>答：有助于减少碰撞次数，提高查询效率。 </p><ul><li><strong>hash%length == hash&amp;(length-1)的前提是 length 是2^n</strong>。</li><li>扩容后也能降低计算新的下标的复杂度。</li></ul><p>eg.一个key的hash在第5位，为0则扩容后，位置不变，为1则扩容后，原位置+16。</p><ul><li>2的幂时，length-1所有位都是1，哈希结果等同hashCode后四位的值，只要hashcode本身均匀，hash结果就均匀。即实现均匀分布。</li></ul><p>eg.length为15，则length-1为14，对应二进制为1110，进行与操作后，最后一位为0，则最后一位为1的位置都不能存放元素。</p><h3 id="2-4-3-加载因子为什么是0-75"><a href="#2-4-3-加载因子为什么是0-75" class="headerlink" title="2.4.3 加载因子为什么是0.75"></a>2.4.3 加载因子为什么是0.75</h3><p>从结果来推导，加载因子为0.75时，能保证和任何2的幂乘积结果都是整数，即负载因子*容量的结果是一个整数，</p><h2 id="2-5-一致性哈希"><a href="#2-5-一致性哈希" class="headerlink" title="2.5 一致性哈希"></a>2.5 一致性哈希</h2><p>答：就是哈希环。服务器平均放环上，一个服务器负责自己顺时针的一片hash区域上的对象。通过增加虚拟节点防止hash环偏移。</p><h2 id="2-6-ConcurrentHashMap"><a href="#2-6-ConcurrentHashMap" class="headerlink" title="2.6 ConcurrentHashMap"></a>2.6 ConcurrentHashMap</h2><ul><li><strong>底层数据结构</strong>：ConcurrentHashMap是数组+链表+红黑树</li><li><strong>实现线程安全</strong>：</li></ul><ol><li><p>在JDK1.8之前，ConcurrentHashMap使用分段锁将Hash表分割为16个桶，每个分段锁维护着几个桶，多线程访问不同分段锁上的桶，提高并发度。(并发度就是分段锁个数)<br><img src="/img/java/Segment.png" srcset="/img/loading.gif" alt="Segment"></p></li><li><p>在JDK1.8之后，使用Node数组+链表+红黑树的数据结构，并发控制用synchronized和CAS操作。</p></li></ol><p><strong>synchronized锁定当前链表/红黑树的头节点，只要hash不碰撞，就不会并发</strong>，效率大幅提升。</p><p><img src="/img/java/ConcurrentHashMap.png" srcset="/img/loading.gif" alt="ConcurrentHashMap"></p><h3 id="2-6-1-put操作流程"><a href="#2-6-1-put操作流程" class="headerlink" title="2.6.1 put操作流程"></a>2.6.1 put操作流程</h3><ul><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。</li><li>如果都不满足，则利用 synchronized 锁写入数据。</li><li>如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。</li></ul><h3 id="2-6-2-get操作流程"><a href="#2-6-2-get操作流程" class="headerlink" title="2.6.2 get操作流程"></a>2.6.2 get操作流程</h3><ul><li>根据算出的hashcode寻址，在桶上就直接返回值。</li><li>如果是红黑树，就按树的方式获取值。</li><li>都不满足，就是按链表遍历获取值。</li></ul><h3 id="2-6-3-为什么用synchronized"><a href="#2-6-3-为什么用synchronized" class="headerlink" title="2.6.3 为什么用synchronized"></a>2.6.3 为什么用synchronized</h3><p>答：JAVA8优化了同步锁，最初都是轻量级锁慢慢升级为重量级锁。</p><ul><li>先用偏向锁，优先同一线程获取锁。</li><li>失败，就升级为CAS，失败后短暂自旋。</li><li>都失败，就升级为重量级锁。</li></ul><h2 id="2-7-LinkedHashMap和LinkedHashSet"><a href="#2-7-LinkedHashMap和LinkedHashSet" class="headerlink" title="2.7 LinkedHashMap和LinkedHashSet"></a>2.7 LinkedHashMap和LinkedHashSet</h2><p>答：</p><ul><li>LinkedHashMap能记录元素的插入顺序和访问顺序。</li></ul><p>具体实现：</p><ol><li>内部通过<strong>双向链表</strong>，保证元素的插入顺序。</li><li>accessOrder默认为false，维护插入顺序，若为true，指定LRU(最近最少使用)顺序。</li><li>afterNodeAccess() 节点被访问后，将该节点移到链表末尾，保证链表首部为最近最久未使用节点；</li><li>afterNodeInsertion() 移除最近最久未使用节点，保证缓存空间足够。</li></ol><ul><li>LinkedHashSet底层使用LinkedHashMap实现。</li><li>二者关系类似HashMap和HashSet。</li></ul><h2 id="2-8-HashSet-HashMap和TreeSet区别"><a href="#2-8-HashSet-HashMap和TreeSet区别" class="headerlink" title="2.8 HashSet,HashMap和TreeSet区别"></a>2.8 HashSet,HashMap和TreeSet区别</h2><p>答：总结如下：</p><ul><li>HashMap底层使用Hash表实现，通过元素的hashCode值和equals()方法保证元素唯一性；</li><li>TreeSet底层使用红黑树实现，通过comparable或comparator接口保证元素唯一性；</li><li>HashSet底层是基于HashMap实现的，基本都是调用hashmap的方法。</li></ul><h2 id="2-9-TreeMap-红黑树"><a href="#2-9-TreeMap-红黑树" class="headerlink" title="2.9 TreeMap/红黑树"></a>2.9 TreeMap/红黑树</h2><p>TreeMap存储键值对，底层是红黑树，可以实现元素的自动排序。了解 TreeMap 必须理解红黑树！</p><p>红黑树是一种二叉搜索树，也是均衡二叉树，当不满足红黑树规则时，自动调整节点平衡。</p><p>规则有：</p><ul><li>节点分为红色和黑色；</li><li>根节点必为黑色；</li><li>叶子节点都为黑色，且都为null；</li><li>连接红色节点的两个子节点都为黑色，即不出现相邻的红色节点；</li><li>从任意节点出发，到任意叶子节点的路径中包含相同数量的黑色节点；</li><li>新加入红黑树的节点都是红色节点。</li></ul><p>维持平衡的方式：变色，左旋，右旋。<a href="https://www.cnblogs.com/LiaHon/p/11203229.html/" target="_blank" rel="noopener">具体操作</a></p><h1 id="3-List接口"><a href="#3-List接口" class="headerlink" title="3. List接口"></a>3. List接口</h1><h2 id="3-1-迭代器Iterator"><a href="#3-1-迭代器Iterator" class="headerlink" title="3.1 迭代器Iterator"></a>3.1 迭代器Iterator</h2><p>答：Iterator是为了实现<strong>遍历Collection的接口</strong>。相当于把一个Collection容器的所有对象，做成一个线性表（List），而iterator本身是一个指针，开始时位于第一个元素之前。有三个主要方法：hasNext(),next(),remove()。</p><h3 id="3-1-1-Iterator和ListIterator区别"><a href="#3-1-1-Iterator和ListIterator区别" class="headerlink" title="3.1.1 Iterator和ListIterator区别"></a>3.1.1 Iterator和ListIterator区别</h3><p>答：区别如下：</p><ul><li>Iterator能遍历list和set集合；ListIterator只能遍历list集合。</li><li>Iterator只能后向遍历；ListIterator是双向遍历。</li><li>ListIterator也是继承了Iterator，再添加新的功能。</li></ul><h2 id="3-2-数组和List的转换"><a href="#3-2-数组和List的转换" class="headerlink" title="3.2 数组和List的转换"></a>3.2 数组和List的转换</h2><p>答：Arrays.asList和List.toArray方法。注意事项:</p><ol><li>Arrays.asList()<ul><li>转换后，不能修改集合，add/remove/clear会报错。因为转化后，本质上仍是一个数组，返回的是Arrays内部的ArrayList类。</li><li>传递数组必须是对象数组，而不能是基本类型。eg.用Integer替代int。</li><li>正确的方法有：<pre><code class="hljs java">List list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>));<span class="hljs-comment">//使用 Java8 的Stream(推荐)</span>Integer [] myArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;List myList = Arrays.stream(myArray).collect(Collectors.toList());<span class="hljs-comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span><span class="hljs-keyword">int</span> [] myArray2 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</code></pre></li></ul></li><li>List.toArray转换<ul><li>无参方法默认返回值是Object[];</li><li>有参方法传入list.size()/指定的数据类型。</li></ul></li></ol><h2 id="3-3-ArrayList"><a href="#3-3-ArrayList" class="headerlink" title="3.3 ArrayList"></a>3.3 ArrayList</h2><p>答：ArrayList是数组列表，用来存储数据。</p><ul><li>优点：数组实现，支持随机访问。</li><li>缺点：删除和插入元素效率低，线程不安全。</li></ul><p>正常使用中，不会频繁增删，不会多线程，所以选ArrayList。频繁增删就用LinkedList。线程安全就用Vector。</p><h3 id="3-3-1-ArrayList和LinkedList区别"><a href="#3-3-1-ArrayList和LinkedList区别" class="headerlink" title="3.3.1 ArrayList和LinkedList区别"></a>3.3.1 ArrayList和LinkedList区别</h3><p>答：总结如下：</p><ul><li>底层数据结构：ArrayList底层是Object动态数组；LinkedList底层使用双向链表。</li><li>随机访问和插入删除元素：ArrayList支持随机访问（相当于get(int index)方法）但删除插入元素慢；LinkedList不支持随机访问但支持随机插入删除元素。</li><li>内存空间占用：ArrayList必须预留一定的空间；LinkedList要存储前驱后继和节点信息，开销大。</li></ul><p>注：ArrayList和LinkedList都是非线程安全的，Vector保证线程安全所有方法都是同步，但耗费大量时间。</p><h3 id="3-3-2-多线程下的ArrayList"><a href="#3-3-2-多线程下的ArrayList" class="headerlink" title="3.3.2 多线程下的ArrayList"></a>3.3.2 多线程下的ArrayList</h3><p>答：ArrayList不是线程安全的。需要通过<code>Collections.synchronizedList()</code>方法转换成线程安全容器。</p><h3 id="3-3-3-扩容"><a href="#3-3-3-扩容" class="headerlink" title="3.3.3 扩容"></a>3.3.3 扩容</h3><ul><li>新建一个<strong>原始长度 * 1.5</strong>的数组；<code>oldCapacity + (oldCapacity &gt;&gt; 1)</code></li><li>把原数组的数据复制到新数组中；</li><li>最后更新地址。</li></ul><h3 id="3-3-4-新增元素"><a href="#3-3-4-新增元素" class="headerlink" title="3.3.4 新增元素"></a>3.3.4 新增元素</h3><ol><li>判断长度，不够就扩容；</li><li>新建数组，复制原数组，在index位开始把元素放进index+1位；</li><li>最后在index放入新增元素。</li></ol><h3 id="3-3-5-删除元素"><a href="#3-3-5-删除元素" class="headerlink" title="3.3.5 删除元素"></a>3.3.5 删除元素</h3><ol><li>新建数组，复制原数组，跳过index位，把index+1位放在index位；</li><li>相当于被覆盖。</li></ol><h2 id="3-4-CopyOnWriteArrayList"><a href="#3-4-CopyOnWriteArrayList" class="headerlink" title="3.4 CopyOnWriteArrayList"></a>3.4 CopyOnWriteArrayList</h2><ol><li>读写分离，写操作在复制的数组上，读操作在原始数组上。</li><li>写操作因为是并发所以需要加锁，结束后指针指向复制数组。</li><li>在写操作的同时允许读操作，适合读多写少的场景。</li></ol><p>缺点：</p><ul><li>内存敏感，因为写操作要复制数组；</li><li>数据不一致：读操作不能读到最新数据，因为写操作还未同步到数组中。</li></ul><h1 id="4-Set和Queue"><a href="#4-Set和Queue" class="headerlink" title="4. Set和Queue"></a>4. Set和Queue</h1><h2 id="4-1-HashSet原理"><a href="#4-1-HashSet原理" class="headerlink" title="4.1 HashSet原理"></a>4.1 HashSet原理</h2><p>答：基于HashMap实现，HashSet值存放在HashMap的key上，value统一为PRESENT。HashSet通过比较hash值和equals()判断key是否重复。底部基本都是调用HashMap的方法。</p><h3 id="4-1-1-hashCode-和equals-区别"><a href="#4-1-1-hashCode-和equals-区别" class="headerlink" title="4.1.1 hashCode()和equals()区别"></a>4.1.1 hashCode()和equals()区别</h3><p>答：总结为：</p><ul><li>两对象相等，则hashcode一定相同，equals也返回相同；</li><li>hashcode相同，对象可能不同，equals也可能返回不同；</li><li>重写equals()时，hashcode一定也得重写。</li></ul><h3 id="4-1-2-和equals"><a href="#4-1-2-和equals" class="headerlink" title="4.1.2 ==和equals()"></a>4.1.2 ==和equals()</h3><p>答：提一嘴。==判断内存地址，equals()判断内容值。</p><h2 id="4-2-Queue方法"><a href="#4-2-Queue方法" class="headerlink" title="4.2 Queue方法"></a>4.2 Queue方法</h2><h3 id="4-2-1-poll-和remove"><a href="#4-2-1-poll-和remove" class="headerlink" title="4.2.1 poll()和remove()"></a>4.2.1 poll()和remove()</h3><p>答：都能弹出第一个元素并把对象从队列中删除。区别是没有元素时poll()返回null，remove()抛出异常。</p><h3 id="4-2-2-BlockingQueue"><a href="#4-2-2-BlockingQueue" class="headerlink" title="4.2.2 BlockingQueue"></a>4.2.2 BlockingQueue</h3><p>答：BlockingQueue是用来实现生产者-消费者模式的队列。添加元素时，等待队列有空间；移除元素时，等待队列为非空。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2020/04/27/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/04/27/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>Java 基础知识，包括Java平台、语法、面向对象、IO流、泛型、反射等。</p><a id="more"></a><h1 id="1-Java概述"><a href="#1-Java概述" class="headerlink" title="1. Java概述"></a>1. Java概述</h1><p>Java是一种面向对象的编程语言，继承了之前语言的优点，还抛弃了指针等晦涩的内容，简单易用，功能强大。</p><h2 id="1-1-JDK、JRE和JVM"><a href="#1-1-JDK、JRE和JVM" class="headerlink" title="1.1 JDK、JRE和JVM"></a>1.1 JDK、JRE和JVM</h2><p>答：基本概念如下：</p><ul><li>JDK(Java Development Kit)开发工具包，java开发环境的核心组件，提供编译调试和运行java程序所有的工具和文件。</li><li>JRE(Java Runtime Environment)java运行时环境，包括JVM和核心类库。</li><li>JVM(Java Virtual Machine)java虚拟机，Java程序运行在JVM上，将字节码转为机器码，提供内存管理、GC等功能。</li></ul><h3 id="1-1-1-关系"><a href="#1-1-1-关系" class="headerlink" title="1.1.1 关系"></a>1.1.1 关系</h3><ul><li>JDK &gt; JRE &gt; JVM</li><li>只运行程序不编码，只装JRE；</li><li>JVM具有平台无关性，让java程序一次编译多个系统执行。</li></ul><h3 id="1-1-2-平台无关性实现"><a href="#1-1-2-平台无关性实现" class="headerlink" title="1.1.2 平台无关性实现"></a>1.1.2 平台无关性实现</h3><ul><li>Java程序基于JVM运行，JVM屏蔽了操作系统和底层硬件的差异；</li><li>Java先编译生成字节码文件，再交给JVM转为机器码；</li></ul><h2 id="1-2-字节码"><a href="#1-2-字节码" class="headerlink" title="1.2 字节码"></a>1.2 字节码</h2><p>答：字节码是Java源代码经过编译后生成的.class文件，只面向虚拟机。</p><h3 id="1-2-1-好处"><a href="#1-2-1-好处" class="headerlink" title="1.2.1 好处"></a>1.2.1 好处</h3><p>答：既保留了解释性语言的可移植性，又有编译型语言的高效率。</p><h3 id="1-2-2-流程"><a href="#1-2-2-流程" class="headerlink" title="1.2.2 流程"></a>1.2.2 流程</h3><p>Java源代码 -&gt; 编译器 -&gt; 字节码 -&gt; JVM的解释器 -&gt; 二进制代码 -&gt; 程序运行</p><h3 id="1-2-3-java是编译型还是解释型语言"><a href="#1-2-3-java是编译型还是解释型语言" class="headerlink" title="1.2.3 java是编译型还是解释型语言"></a>1.2.3 java是编译型还是解释型语言</h3><p>答：从上可以总结，java是先编译后解释执行的语言，不能单纯地归类。</p><h2 id="1-3-Java和C-区别"><a href="#1-3-Java和C-区别" class="headerlink" title="1.3 Java和C++区别"></a>1.3 Java和C++区别</h2><p>答：我也不知道，为什么面经都有这类题…</p><ul><li>都是面向对象的语言，支持封装继承和多态</li><li>java没有指针访问内存</li><li>java类是单继承，C++多重继承</li><li>java有自动GC机制</li><li>C/C++中的字符串和数组都自动加一个’\0’作为结束符，java中不需要</li></ul><h2 id="1-4-各版本特性"><a href="#1-4-各版本特性" class="headerlink" title="1.4 各版本特性"></a>1.4 各版本特性</h2><ol><li>Java 8<ul><li>Lambda 表达式，简化写法。</li><li>Streams流编程。中间操作返回Stream本身，能将多个操作串起，最终操作才返回结果。</li><li>Data API。Clock 提供访问当前日期和时间；时区设置；DateTimeFormatter 解决日期格式化；本地日期和本地时间。</li><li>注解。</li></ul></li><li>Java 9<ul><li>引入Java平台模块系统，将JDK分为若干模块，创建镜像只需要所依赖的JDK模块，减少JRE大小。</li><li>设置 G1 为默认垃圾收集器。</li><li>集合、Stream、Optional方法扩展。</li><li>接口私有方法。</li></ul></li><li>Java 10<ul><li>var关键字。只能用于局部变量和for循环。</li><li>G1 的FullGC变为并行的标记清除。</li></ul></li><li>Java 11<ul><li>新的长期支持版本。</li><li>增加一系列字符串处理方法。</li><li>ZGC 伸缩GC收集器。</li><li>HTTP Client API标准化，支持异步非阻塞。</li></ul></li><li>Java 12<ul><li>修改switch，变成类似lambda的形式。</li></ul></li><li>Java 13<ul><li>switch 加入 yield，用来跳出当前switch块。</li><li>文本块。</li></ul></li><li>Java 14<ul><li>将 switch 的增强转正。</li><li>移除 CMS 垃圾收集器。</li></ul></li></ol><h1 id="2-基础语法"><a href="#2-基础语法" class="headerlink" title="2.基础语法"></a>2.基础语法</h1><h2 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h2><p><img src="/img/java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" srcset="/img/loading.gif" alt="数据类型"></p><h3 id="2-1-1-BigDecimal"><a href="#2-1-1-BigDecimal" class="headerlink" title="2.1.1 BigDecimal"></a>2.1.1 BigDecimal</h3><p>浮点数的等值判断，基础类型不能用==，包装类型不能用equals()，会造成精度丢失。推荐使用BigDecimal操作浮点数，从而进行运算操作。</p><ul><li>大小判断：a.compareTo(b)，1为大于，0为等于，-1为小于；</li><li>保留小数：setScale()；</li><li>创建：new BigDecimal(“0.1”)/BigDecimal.valueOf(0.1)</li></ul><p>总结：BigDecimal操作(大)浮点数，BigInteger操作大整数(超过long)。</p><h2 id="2-2-运算符"><a href="#2-2-运算符" class="headerlink" title="2.2 运算符"></a>2.2 运算符</h2><h3 id="2-2-1-amp-和-amp-amp-区别"><a href="#2-2-1-amp-和-amp-amp-区别" class="headerlink" title="2.2.1 &amp;/|和&amp;&amp;/||区别"></a>2.2.1 &amp;/|和&amp;&amp;/||区别</h3><p>答：总结为：</p><ul><li>&amp;是按位与，|是逻辑或；</li><li>&amp;&amp;是与运算，||是或运算，都具有短路特性。eg.&amp;&amp;前面为false，右边表达式短路不访问。</li></ul><h3 id="2-2-2-equals-和-的区别"><a href="#2-2-2-equals-和-的区别" class="headerlink" title="2.2.2 equals()和==的区别"></a>2.2.2 equals()和==的区别</h3><p>答：区别：</p><ul><li>基本类型，==判断值相等，无equals()。</li><li>引用类型，==判断两个变量是否引用同一个变量即比较对象的地址，equals()判断引用对象是否等价。</li></ul><h2 id="2-3-关键字"><a href="#2-3-关键字" class="headerlink" title="2.3 关键字"></a>2.3 关键字</h2><h3 id="2-3-1-final"><a href="#2-3-1-final" class="headerlink" title="2.3.1 final"></a>2.3.1 final</h3><p>答：final关键字用于修饰类、变量和方法。</p><ul><li>final修饰的类，不能被继承；</li><li>final修饰的方法，不能被重写；</li><li>final修饰的变量，必须初始化，不能被改变。<strong>若修饰的是基础数据类型则其值不能变，若修饰引用类型则其内存地址不能变</strong>。</li></ul><h3 id="2-3-2-static"><a href="#2-3-2-static" class="headerlink" title="2.3.2 static"></a>2.3.2 static</h3><p>答：static的作用有:</p><ul><li>static修饰的类方法，不属于任何实例，但被类的实例对象共享。</li><li>static修饰的部分，只在第一次加载时初始化。</li></ul><h2 id="2-4-String"><a href="#2-4-String" class="headerlink" title="2.4 String"></a>2.4 String</h2><p>答：String是不可变的，创建后在常量池缓存。</p><h3 id="2-4-1-不可变"><a href="#2-4-1-不可变" class="headerlink" title="2.4.1 不可变"></a>2.4.1 不可变</h3><ul><li>String是final修饰的char数组，不可继承；</li><li>String不可变，但引用可变。eg.字符串拼接理解为开辟新的内存区域给新串。</li><li>用反射可以修改String。</li></ul><h3 id="2-4-2-StringBuffer与StringBuilder"><a href="#2-4-2-StringBuffer与StringBuilder" class="headerlink" title="2.4.2 StringBuffer与StringBuilder"></a>2.4.2 StringBuffer与StringBuilder</h3><ol><li>可变性：String底层用final char[]，不可变；StringBuffer和StringBuilder用char[]，可变。</li><li>线程安全：String不可变，安全；StringBuffer加了<strong>同步锁</strong>，线程安全；StringBuilder是非线程安全的。</li><li>性能：String改变时，生成新的String对象，将指针指向新的String；StringBuffer每次都对本身进行操作；StringBuilder速度会快一点。</li></ol><p>所以：</p><ul><li>操作少量的数据：适用String；</li><li>单线程操作字符串缓冲区下操作大量数据：适用StringBuilder；</li><li>多线程操作字符串缓冲区下操作大量数据：适用StringBuffer。</li></ul><p>注：记不清的话用safe来记忆，buffer有safe的一部分，所以它是线程安全的。</p><h3 id="2-4-3-缓存池"><a href="#2-4-3-缓存池" class="headerlink" title="2.4.3 缓存池"></a>2.4.3 缓存池</h3><p>答：new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用取同一个对象的引用。valueOf() 方法先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</li></ul><p>类似的new String(“i”)是在堆内存创建对象，String str=”i”是在常量池中存储。</p><h3 id="2-4-4-常用方法"><a href="#2-4-4-常用方法" class="headerlink" title="2.4.4 常用方法"></a>2.4.4 常用方法</h3><pre><code class="hljs java">indexOf()：返回指定字符的索引。charAt()：返回指定索引处的字符。replace()：字符串替换。trim()：去除字符串两端空白。split()：分割字符串，返回一个分割后的字符串数组。getBytes()：返回字符串的 <span class="hljs-keyword">byte</span> 类型数组。length()：返回字符串长度。toLowerCase()：将字符串转成小写字母。toUpperCase()：将字符串转成大写字符。substring()：截取字符串。equals()：字符串比较。</code></pre><h2 id="2-5-拆箱装箱"><a href="#2-5-拆箱装箱" class="headerlink" title="2.5 拆箱装箱"></a>2.5 拆箱装箱</h2><p>答：装箱就是自动将基本数据类型转换为包装类型；拆箱就是将包装类型转换为基本数据类型。</p><h3 id="2-5-1-分类"><a href="#2-5-1-分类" class="headerlink" title="2.5.1 分类"></a>2.5.1 分类</h3><p>答：Java为每个原始基本类型都提供了包装类。</p><ul><li>原始类型: boolean，char，byte，short，int，long，float，double</li><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li></ul><h3 id="2-5-2-Integer的坑"><a href="#2-5-2-Integer的坑" class="headerlink" title="2.5.2 Integer的坑"></a>2.5.2 Integer的坑</h3><p>答：写题时遇到。</p><ul><li>对于int，==比较的是值；</li><li>对于Integer，当-128~127时，==比较的是值；(直接引用常量池中内容)</li><li>当超过范围，==比较的是内存地址，要用 equals() 比较值。</li></ul><h1 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3. 面向对象"></a>3. 面向对象</h1><p>答：面向对象是一种思想，将复杂问题简单化模块化。</p><p>面向过程是具体化流程化。面向对象就是把过程抽象成类，封装成模块。</p><h2 id="3-1-三大特性"><a href="#3-1-三大特性" class="headerlink" title="3.1 三大特性"></a>3.1 三大特性</h2><ul><li>封装：将事物封装为一个类，隐藏细节，对外提供接口访问。当接口内部改变时，不影响外部调用。</li><li>继承：从已知类中派生新类，新类拥有父类的属性和方法，并能增加新功能或重写父功能。</li><li>多态：同一接口能有不同的解释，产生不同的结果。实现方式：继承、重载、向上转型。<br>多态是同一个行为具有多个不同表现形式或形态的能力。 </li></ul><h3 id="3-1-1-重写和重载"><a href="#3-1-1-重写和重载" class="headerlink" title="3.1.1 重写和重载"></a>3.1.1 重写和重载</h3><ul><li>重写，即父类有方法A，子类拓展了方法A并加了新功能，就是子类重写了A。</li><li>重载，即一个类中存在多个同名，但参数个数、顺序和类型不同的方法。</li></ul><p><strong>只有返回值不同，不构成重载！</strong></p><p><strong>构造器不能被重写，只能被重载</strong></p><h2 id="3-2-五大基本原则"><a href="#3-2-五大基本原则" class="headerlink" title="3.2 五大基本原则"></a>3.2 五大基本原则</h2><ul><li>单一职责原则SRP(Single Responsibility Principle)：类的功能要单一，不能包罗万象。</li><li>开放封闭原则OCP(Open－Close Principle)：对拓展开放，对修改封闭。</li><li>里式替换原则LSP(the Liskov Substitution Principle LSP)：子类可以替换父类且毫无察觉。</li><li>依赖倒置原则DIP(the Dependency Inversion Principle DIP)：高层模块不应依赖于低层模块，他们都应该依赖于抽象。抽象不应依赖于具体实现，具体实现应该依赖于抽象。</li><li>接口分离原则ISP(the Interface Segregation Principle ISP)：多个特殊接口比一个通用接口更好。</li></ul><h2 id="3-3-抽象类和接口"><a href="#3-3-抽象类和接口" class="headerlink" title="3.3 抽象类和接口"></a>3.3 抽象类和接口</h2><p><strong>抽象是对类的抽象，接口是对行为的抽象</strong></p><p>相同点:</p><ul><li>都不能实例化；</li><li>都包含抽象方法。</li></ul><p>不同点:</p><table><thead><tr><th></th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>构造方法</td><td>有</td><td>不存在</td></tr><tr><td>声明</td><td>abstract</td><td>interface</td></tr><tr><td>实现</td><td>extends继承抽象类</td><td>implements实现接口</td></tr><tr><td>构造器</td><td>有</td><td>无</td></tr><tr><td>继承方式</td><td>单继承</td><td>多继承3</td></tr><tr><td>字段声明</td><td>任意</td><td>默认static和final</td></tr><tr><td>修饰符</td><td>public、protected、default</td><td>public</td></tr></tbody></table><p>注：抽象类中不能有静态方法(final就不能被继承，矛盾)，JDK1.8后接口能有静态方法。</p><h3 id="3-3-1-静态与非静态的区别"><a href="#3-3-1-静态与非静态的区别" class="headerlink" title="3.3.1 静态与非静态的区别"></a>3.3.1 静态与非静态的区别</h3><p>答：静态是指用static关键字修饰的类、方法、字段等，非静态是指没有用static修饰的。</p><ul><li>静态只能访问静态的，非静态既能访问静态的也能访问非静态的</li><li>静态的直接可以用类名调用，非静态的需要先实例化再调用。</li><li>静态变量存在常量池中，非静态成员变量在堆中</li><li>静态变量随类的加载而加载，消失而消失，非静态成员变量随对象创建而存在，消失而消失</li></ul><h2 id="3-4-内部类"><a href="#3-4-内部类" class="headerlink" title="3.4 内部类"></a>3.4 内部类</h2><p>答：把一个类定义在另一个类的内部就是内部类，分为成员内部类、局部内部类、匿名内部类和静态内部类。</p><h3 id="3-4-1-优点"><a href="#3-4-1-优点" class="headerlink" title="3.4.1 优点"></a>3.4.1 优点</h3><ul><li>对包的其他类不透明，封装性好；</li><li>内部类能实现多重继承；</li><li>内部类能访问创建它的外部类对象。</li></ul><h3 id="3-4-2-匿名内部类"><a href="#3-4-2-匿名内部类" class="headerlink" title="3.4.2 匿名内部类"></a>3.4.2 匿名内部类</h3><ul><li>必须继承一个抽象类或者实现一个接口。</li><li>不能定义任何静态成员/方法。</li><li>匿名内部类使用的外部变量必须声明为 final。</li></ul><p>注：final是因为生命周期不一致。final可以确保局部/匿名内部类使用的变量与外层的局部变量区分开。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">new</span> Service() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;                    System.out.println(<span class="hljs-string">"匿名内部类"</span> );                &#125;            &#125;        &#125;.method();    &#125; &#125; <span class="hljs-comment">//匿名内部类必须继承或实现一个已有的接口 </span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Service</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h2 id="3-5-equals-和hashCode"><a href="#3-5-equals-和hashCode" class="headerlink" title="3.5 equals()和hashCode()"></a>3.5 equals()和hashCode()</h2><p>答：equals()判断两个对象是否相等，hashCode()获取对象的哈希码，根据哈希码确定对象在哈希表中的索引。</p><h3 id="3-5-1-关系"><a href="#3-5-1-关系" class="headerlink" title="3.5.1 关系"></a>3.5.1 关系</h3><ol><li>两个对象相等，hashCode()也一定相同；</li><li>hashCode值相同，对象不一定相等；</li><li>equals()重写时，hashcCode()也一定要被重写，为保证两个对象的哈希值也相等，避免hashmap逻辑冲突。</li></ol><h2 id="3-6-值传递"><a href="#3-6-值传递" class="headerlink" title="3.6 值传递"></a>3.6 值传递</h2><p>答：概括为：</p><ul><li>值传递，传递对象的副本，即修改副本，不影响源对象。</li><li>引用传递，传递对象的引用，即修改引用对象，会影响源对象。</li><li><strong>Java只有值传递，而这个值实际上是对象的引用</strong>！理解为共享传递。</li></ul><h2 id="3-7-拷贝"><a href="#3-7-拷贝" class="headerlink" title="3.7 拷贝"></a>3.7 拷贝</h2><ol><li>浅拷贝：对基础数据类型值传递，对引用数据类型引用传递；</li><li>深拷贝：对基础数据类型值传递，对引用数据类型，创建新对象，复制其内容。</li></ol><h1 id="4-IO流"><a href="#4-IO流" class="headerlink" title="4. IO流"></a>4. IO流</h1><h2 id="4-1-分类"><a href="#4-1-分类" class="headerlink" title="4.1 分类"></a>4.1 分类</h2><ul><li>按流向，分为输入流和输出流；</li><li>按操作单元，分为字节流和字符流；</li><li>按流的角色，分为节点流和处理流。</li></ul><p>归总，所有的IO都是从4个基类拓展得来。</p><ul><li>InputStream字节输入流</li><li>Reader字符输入流</li><li>OutputStream字节输出流</li><li>Writer字符输出流</li></ul><h2 id="4-2-BIO、NIO和AIO"><a href="#4-2-BIO、NIO和AIO" class="headerlink" title="4.2 BIO、NIO和AIO"></a>4.2 BIO、NIO和AIO</h2><ul><li>BIO：传统IO，数据的读取写入必须阻塞在一个线程内等待完成。使用简单，但并发能力低；</li><li>NIO：Client和Server通过通道Channel通信，监听通道的事件变化，如果有数据变化就通知线程进行读写操作，没有数据可读Client也能去做其他事情。多路复用。</li><li>AIO异步IO：异步是指服务端线程接收到客户端管道后就交给底层处理IO通信，自己可以做其他事情。基于事件和回调实现。</li></ul><p>IO类型具体见 Socket通信。</p><h1 id="5-反射"><a href="#5-反射" class="headerlink" title="5. 反射"></a>5. 反射</h1><p>答：反射机制是指在运行中，任意一个类，都能知道这个类的所有属性和方法；任意一个对象，都能调用它的属性和方法。简而言之，<strong>动态获取和调用对象的属性和方法。</strong> </p><p>优点是灵活度高，缺点是慢慢慢！</p><h2 id="5-1-相关类"><a href="#5-1-相关类" class="headerlink" title="5.1 相关类"></a>5.1 相关类</h2><ul><li>Class：类，用于获取类的相关信息</li><li>Field：成员变量，用于获取实例变量和静态变量</li><li>Method：方法，用于获取类中的方法参数和类型</li><li>Constructor：构造器，用于获取构造器的相关参数和类型</li></ul><h2 id="5-2-流程"><a href="#5-2-流程" class="headerlink" title="5.2 流程"></a>5.2 流程</h2><ol><li>获取class对象。Class.forName，getClass()，.class获得。</li><li>newInstance()获取class对象的实例，通过getFields,getConstructors,getMethods获取类成员，set/get访问字段，invoke()调用方法。</li></ol><h2 id="5-3-为什么慢"><a href="#5-3-为什么慢" class="headerlink" title="5.3 为什么慢"></a>5.3 为什么慢</h2><ol><li>class.getMethod()，遍历所有的方法，匹配不到就去找遍历父类。最耗时的地方，用备忘录将method记录能降低一个数量级的消耗。</li><li>method.invoke()，参数为Object数组，需要对基本类型装箱。</li></ol><h2 id="5-4-举例"><a href="#5-4-举例" class="headerlink" title="5.4 举例"></a>5.4 举例</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        User ming = <span class="hljs-keyword">new</span> Usetr();        String className = <span class="hljs-string">"com.bys.User"</span>;        <span class="hljs-comment">// 获取Class对象</span>        Class clazz = ming.getClass();        Class clazz = Class.forName(className);        Class clazz = User<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;        <span class="hljs-comment">// 创建User对象</span>        User user = (User)clazz.newInstance();        <span class="hljs-comment">// 和普通对象一样，可以设置属性值</span>        user.setUsername(<span class="hljs-string">"bys"</span>);        System.out.println(user);    &#125;&#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> String username;     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> username;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;        <span class="hljs-keyword">this</span>.username = username;    &#125;&#125;</code></pre><h1 id="6-元注解"><a href="#6-元注解" class="headerlink" title="6. 元注解"></a>6. 元注解</h1><p>答：提供了4个元注解，作用是负责注解其他注解。</p><ul><li>@Target，注明注解用于什么地方。</li><li>@Rentention，注明注解的生命周期，分为SOURCE, CLASS, RUNTIME三种策略。</li><li>@Documented，注明是否将注解信息添加在java文档中。</li><li>@Inherited，注明该注释和子类的关系。即一个类被@Inherited的注解标注，其子类也被这个注解标注。</li></ul><h2 id="6-1-注解的流程"><a href="#6-1-注解的流程" class="headerlink" title="6.1 注解的流程"></a>6.1 注解的流程</h2><p>答：作用：代替繁琐的配置文件，简化开发。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义注解类必须使用@interface</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>value就是属性。指定属性后，使用注解时需要给属性赋值。 </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnn &#123;     <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;     <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">value1</span><span class="hljs-params">()</span></span>; &#125;<span class="hljs-comment">// 使用注解MyAnn，可以设置属性</span><span class="hljs-meta">@MyAnn</span>(value1=<span class="hljs-number">100</span>,value=<span class="hljs-string">"hello"</span>) <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123; &#125;</code></pre><h1 id="7-泛型"><a href="#7-泛型" class="headerlink" title="7. 泛型"></a>7. 泛型</h1><p>答：泛型是当创建对象或调用方法时才去确定数据类型的特殊类型。</p><h2 id="7-1-好处"><a href="#7-1-好处" class="headerlink" title="7.1 好处"></a>7.1 好处</h2><p>不用进行强转；程序更加健壮；可读性更好；在创建集合时限定类型方便。</p><h2 id="7-2-泛型基础"><a href="#7-2-泛型基础" class="headerlink" title="7.2 泛型基础"></a>7.2 泛型基础</h2><h3 id="7-2-1-泛型类"><a href="#7-2-1-泛型类" class="headerlink" title="7.2.1 泛型类"></a>7.2.1 泛型类</h3><p>泛型类就是把泛型定义在类上，用户使用该类的时候，才把类型明确下来。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectTool</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> T obj;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getObj</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> obj;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setObj</span><span class="hljs-params">(T obj)</span> </span>&#123;        <span class="hljs-keyword">this</span>.obj = obj;    &#125;&#125;</code></pre><h3 id="7-2-2-泛型方法"><a href="#7-2-2-泛型方法" class="headerlink" title="7.2.2 泛型方法"></a>7.2.2 泛型方法</h3><p>外界调用时传进来什么类型，返回值就是什么类型。</p><pre><code class="hljs java"><span class="hljs-comment">//定义泛型方法..</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(T t)</span> </span>&#123;    System.out.println(t);&#125;</code></pre><h3 id="7-2-3-泛型类的子类"><a href="#7-2-3-泛型类的子类" class="headerlink" title="7.2.3 泛型类的子类"></a>7.2.3 泛型类的子类</h3><p>分为子类明确和子类不明确</p><pre><code class="hljs java"><span class="hljs-comment">//子类明确</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Inter</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(String s)</span> </span>&#123;        System.out.println(s);    &#125;&#125;<span class="hljs-comment">//子类不明确</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterImpl</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Inter</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(T t)</span> </span>&#123;        System.out.println(t);    &#125;&#125;</code></pre><h2 id="7-3-类型通配符’-’"><a href="#7-3-类型通配符’-’" class="headerlink" title="7.3 类型通配符’?’"></a>7.3 类型通配符’?’</h2><p>泛型提供了类型通配符 ? ，表示匹配任意类型。在用这个时，必须注意：<strong>只能调用和对象无关的方法，不能调用和对象有关的方法，直到外界确定了具体的类型。</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(List&lt;?&gt; list)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;list.size();i++)&#123;             System.out.println(list.get(i));      &#125;&#125;</code></pre><h3 id="7-3-1-通配符上限"><a href="#7-3-1-通配符上限" class="headerlink" title="7.3.1 通配符上限"></a>7.3.1 通配符上限</h3><p>表示List接收的元素只能是Number自身或子类。</p><pre><code class="hljs java">List&lt;? extends Number&gt;</code></pre><h3 id="7-3-2-通配符下限"><a href="#7-3-2-通配符下限" class="headerlink" title="7.3.2 通配符下限"></a>7.3.2 通配符下限</h3><p>表示传递进来的只能是Type或其父类。</p><pre><code class="hljs java">&lt;? <span class="hljs-keyword">super</span> Type&gt;</code></pre><h2 id="7-4-泛型擦除"><a href="#7-4-泛型擦除" class="headerlink" title="7.4 泛型擦除"></a>7.4 泛型擦除</h2><p>在已经确定泛型类型的集合赋值给普通集合时，发生泛型擦除，即<strong>保留类型参数的上限</strong>。如List<String> list传递给List list1，保留的是String的上限Object。</p><h1 id="8-JIT编译器"><a href="#8-JIT编译器" class="headerlink" title="8. JIT编译器"></a>8. JIT编译器</h1><p>答：JIT(Just In Time Compile)即时编译器，把经常运行的代码编译成和本地平台相关的机器码并优化，包括逃逸分析、锁消除、空值检测消除等。</p><h2 id="8-1-逃逸分析"><a href="#8-1-逃逸分析" class="headerlink" title="8.1 逃逸分析"></a>8.1 逃逸分析</h2><p>答：逃逸分析的基本行为就是分析对象动态作用域。当一个对象在方法中被定义时，它可能被外部方法引用，例如作为参数传递，这种称为方法逃逸。作用是，经过分析，发现对象不被外界访问，经过JIT优化，把对象拆解成若干标量替换。</p><h1 id="9-异常"><a href="#9-异常" class="headerlink" title="9. 异常"></a>9. 异常</h1><h2 id="9-1-分类"><a href="#9-1-分类" class="headerlink" title="9.1 分类"></a>9.1 分类</h2><ol><li>Throwable是所有错误Error和异常Exception的父类；</li><li>Error一般为程序运行错误，不能被动态处理，只能安全终止；</li><li>Exception分为运行时异常RuntimeException可以被捕获处理，非运行时异常CheckedException编译阶段强制要求处理(ide中标红)。</li></ol><h2 id="9-2-处理方式"><a href="#9-2-处理方式" class="headerlink" title="9.2 处理方式"></a>9.2 处理方式</h2><ol><li>抛出异常。遇到异常不做处理直接抛出，throws作用于方法上，throw作用于方法内。</li><li>try/catch/finally，try中的异常被catch捕获处理，finally无论是否发生异常都执行，一般用来释放资源。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>感悟</title>
    <link href="/2020/04/27/%E6%84%9F%E6%82%9F/"/>
    <url>/2020/04/27/%E6%84%9F%E6%82%9F/</url>
    
    <content type="html"><![CDATA[<ol><li>后台的本质就是增删查改，学很多知识，都是为了更好的增删查改。</li><li>时间越长，代码越来越复杂，就会涉及到业务拆分，架构设计。</li><li>常用的静态资源占用带宽，用静态资源服务器。</li><li>文件上传下载太慢，要提高效率，FastDFS。</li><li>要保证消息推送的实时性，就得建立长连接，netty，websockt。</li><li>一台服务器撑不住并发，多台服务器就会涉及到负载均衡。</li><li>多台服务器下他们中间会有通信问题，又涉及到RPC远程调用。</li><li>敏感业务，像支付和认证，受网络原因调用慢，就需要异步。</li><li>使用人数过多，要让服务器减压，就要用到消息队列 + 分布式缓存。</li><li>数据库数据量过大，得建立索引，分表分库。</li><li>常用信息访问过多占用资源，得用缓存，像redis。</li><li>代码设计里面又包含设计模式，架构模式。</li><li>分布式里面除了CAP这样的理论基础，还有SOA，服务治理，WebService，通讯协议等等。</li></ol><p>学是学不完的，但总归是要学的。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口问题</title>
    <link href="/2020/04/26/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/"/>
    <url>/2020/04/26/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>滑动窗口问题的思路和基础代码模板。</p><a id="more"></a><h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ol><li>设置左右指针，初始化都为0，把[left,right]当成一个窗口；</li><li>不断增大right，直到窗口内的子串符合要求；</li><li>不断增大left，缩小窗口直到窗口内子串不符合要求，在缩小left时记录结果；</li><li>直到right到达字符串串尾。</li></ol><p>对于如何判断是否符合要求，建立两个哈希表，一个needs记录pattern子串中字符出现次数，一个windows记录当前窗口子串中字符出现次数。用一个match记录符合规则的字符数。</p><p>当match等于needs的长度时，表明满足条件，开始缩小窗口。每次缩小时，都要再次判断条件，更新match。</p><p>注：在java中除了设置hashmap还可以直接用数组建立char[256/128]，操作也简便些。</p><h1 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h1><p>基础思想的模板</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (right &lt; s.size()) &#123;    window.add(s[right]);    right++;        <span class="hljs-keyword">while</span> (valid) &#123;        window.remove(s[left]);        left++;    &#125;&#125;</code></pre><p>详细些</p><pre><code class="hljs java"><span class="hljs-comment">// 双指针</span><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = <span class="hljs-number">0</span>;<span class="hljs-comment">// 滑动窗口</span>HashMap/Character[] windows = &#123;&#125;;<span class="hljs-comment">// 匹配条件</span>HashMap/Character[] needs = &#123;&#125;;<span class="hljs-comment">// 条件判断操作</span><span class="hljs-keyword">var</span> valid;<span class="hljs-comment">// 符合条件的字符数</span><span class="hljs-keyword">int</span> match = <span class="hljs-number">0</span> ;<span class="hljs-comment">// 变化窗口</span><span class="hljs-keyword">while</span>(right &lt; A.length)&#123;    <span class="hljs-comment">// 增大窗口</span>    <span class="hljs-keyword">if</span>(valid)&#123;        windows.add(B[right]);    &#125;    right++;    <span class="hljs-comment">// 符合子串匹配条件</span>    <span class="hljs-keyword">while</span>(match === needs.length)&#123;        <span class="hljs-keyword">if</span>(valid)&#123;            <span class="hljs-comment">// 缩小窗口</span>            window.remove(B[left]);            <span class="hljs-comment">// 归位规则计数</span>            match--;            <span class="hljs-comment">// 继续下一轮、增大前进窗口</span>            left++;        &#125;    &#125;&#125;</code></pre><h1 id="题目举例"><a href="#题目举例" class="headerlink" title="题目举例"></a>题目举例</h1><table><thead><tr><th>题号</th><th>题目</th><th>难度</th></tr></thead><tbody><tr><td>3</td><td><a href="https://github.com/BarryBean/AlgorithmNotes/blob/master/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/3%E6%97%A0%E9%87%8D%E5%A4%8D%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.md" target="_blank" rel="noopener">无重复的最长子串</a></td><td>中等</td></tr><tr><td>76</td><td><a href="https://github.com/BarryBean/AlgorithmNotes/blob/master/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/76%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.md" target="_blank" rel="noopener">最小覆盖子串</a></td><td>困难</td></tr><tr><td>209</td><td><a href="https://github.com/BarryBean/AlgorithmNotes/blob/master/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/209%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.md" target="_blank" rel="noopener">长度最小的子数组</a></td><td>中等</td></tr><tr><td>438</td><td><a href="https://github.com/BarryBean/AlgorithmNotes/blob/master/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/438%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.md" target="_blank" rel="noopener">找到字符串中所有字母异位词</a></td><td>中等</td></tr><tr><td>567</td><td><a href="https://github.com/BarryBean/AlgorithmNotes/blob/master/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/567%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.md" target="_blank" rel="noopener">字符串的排列</a></td><td>中等</td></tr><tr><td>239</td><td><a href="https://github.com/BarryBean/AlgorithmNotes/blob/master/%E5%8D%95%E8%B0%83%E6%A0%88/239%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.md" target="_blank" rel="noopener">滑动窗口最大值</a></td><td>困难</td></tr><tr><td>480</td><td><a href="https://github.com/BarryBean/AlgorithmNotes/blob/master/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/480%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0.md" target="_blank" rel="noopener">滑动窗口中位数</a></td><td>困难</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
