<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hexo博客部署腾讯云</title>
    <link href="/2020/05/10/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E8%85%BE%E8%AE%AF%E4%BA%91/"/>
    <url>/2020/05/10/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E8%85%BE%E8%AE%AF%E4%BA%91/</url>
    
    <content type="html"><![CDATA[<p>白嫖 github 速度慢，还是自己的服务器用起来好呀。</p><a id="more"></a><p>白嫖 github 虽然美滋滋，但一是速度有点慢，二是每次更新都占提交记录，所以还是得部署在自己的云服务器上才香。</p><p>注：腾讯云、阿里云、华为云都有学生优惠。</p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><ol><li>一台腾讯云服务器</li><li>本地的 hexo 博客</li></ol><p>云服务器系统为 CentOS 7.4 64位，登录并进入服务器的命令行界面。</p><p><img src="/img/tools/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BB%88%E7%AB%AF.png" srcset="/img/loading.gif" alt="命令行终端"></p><h1 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h1><ol><li><p>安装依赖库和编译工具</p><ul><li>安装依赖库：</li></ul><pre><code class="hljs bash">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</code></pre><ul><li>安装编译工具：</li></ul><pre><code class="hljs bash">yum install gcc perl-ExtUtils-MakeMaker package</code></pre></li><li><p>下载 git</p><ul><li>选择目录存放下载的 git 安装包。以<code>/usr/local/src</code> 为例。</li></ul><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/src</code></pre><ul><li>去 git官网 找一个稳定的源码包，下载到 <code>/usr/local/src</code> 里</li></ul><pre><code class="hljs bash">wget https://www.kernel.org/pub/software/scm/git/git-2.16.2.tar.gz</code></pre></li><li><p>解压编译</p><ul><li>在当前目录下解压 <code>git-2.16.2.tar.gz</code> </li></ul><pre><code class="hljs bash">tar -zvxf git-2.16.2.tar.gz</code></pre><ul><li>进入 <code>git-2.16.2.tar.gz</code> 目录下</li></ul><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> git-2.16.2</code></pre><ul><li>执行编译</li></ul><pre><code class="hljs bash">make all prefix=/usr/<span class="hljs-built_in">local</span>/git</code></pre><ul><li>安装 git 到 <code>/usr/local/git</code> 目录下</li></ul><pre><code class="hljs bash">make install prefix=/usr/<span class="hljs-built_in">local</span>/git</code></pre></li><li><p>配置环境变量</p><ul><li>将 git 加入 PATH 目录中</li></ul><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">'export PATH=$PATH:/usr/local/git/bin'</span> &gt;&gt; /etc/bashrc</code></pre><ul><li>使 git 环境变量生效</li></ul><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/bashrc</code></pre></li><li><p>查看 git 版本</p><pre><code class="hljs bash">git --version</code></pre><p><strong>如果能查到 git 的版本号，说明安装成功。</strong></p></li><li><p>创建 git 仓库，存放网站资源。</p><ul><li>在 <code>home/git</code> 的目录下，创建一个名为<code>hexoBlog</code>的仓库，并修改所有权和用户权限。</li></ul><pre><code class="hljs bash">mkdir /home/git/chown -R <span class="hljs-variable">$USER</span>:<span class="hljs-variable">$USER</span> /home/git/chmod -R 755 /home/git/</code></pre><ul><li>然后在此目录下，创建一个 git 仓库。</li></ul><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/git/git init --bare hexoBlog.git</code></pre></li><li><p>创建一个新的 git 钩子，用于自动部署。</p><ul><li>在 <code>/home/git/hexoBlog.git</code> 下，有一个自动生成的 <code>hooks</code> 文件夹。我们需要在里边新建一个新的钩子文件 <code>post-receive</code>。</li></ul><pre><code class="hljs bash">vim /home/git/hexoBlog.git/hooks/post-receive</code></pre><ul><li>按 <code>i</code> /<code>a</code>键进入编辑模式，在该文件中添加如下代码，指定 Git 的工作树（源代码）和 Git 目录（配置文件等）。</li></ul><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>git --work-tree=/home/hexoBlog --git-dir=/home/git/hexoBlog.git checkout -f</code></pre><ul><li><p>按 <code>Esc</code> 退出编辑模式，输入<code>:wq</code> 保存退出。</p></li><li><p>添加文件执行权限。</p></li></ul><pre><code class="hljs bash">chmod +x /home/git/hexoBlog.git/hooks/post-receive</code></pre></li></ol><p>至此，git 仓库搭建完成。</p><h1 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h1><ol><li>安装</li></ol><pre><code class="hljs bash">yum install -y nginx</code></pre><ol start="2"><li>启动</li></ol><pre><code class="hljs bash">service nginx start</code></pre><ol start="3"><li>测试 Nginx</li></ol><pre><code class="hljs bash">wget http://127.0.0.1</code></pre><p>出现以下页面说明安装成功。</p><pre><code class="hljs dart">Connecting to <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">80.</span>.. connected.HTTP request sent, awaiting response... <span class="hljs-number">200</span> OKLength: <span class="hljs-number">19706</span> (<span class="hljs-number">19</span>K) [text/html]Saving to: ‘index.html’<span class="hljs-number">100</span>%[==================================&gt;] <span class="hljs-number">19</span>,<span class="hljs-number">706</span>      --.-K/s   <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>s      <span class="hljs-number">2020</span><span class="hljs-number">-05</span><span class="hljs-number">-10</span> <span class="hljs-number">19</span>:<span class="hljs-number">29</span>:<span class="hljs-number">17</span> (<span class="hljs-number">311</span> MB/s) - ‘index.html’ saved [<span class="hljs-number">19706</span>/<span class="hljs-number">19706</span>]</code></pre><ol start="4"><li><p>配置 Nginx 托管文件目录</p><ul><li>创建 <code>/home/hexoBlog</code>目录，并配置权限。</li></ul><pre><code class="hljs bash">mkdir /home/hexoBlog/chown -R <span class="hljs-variable">$USER</span>:<span class="hljs-variable">$USER</span> /home/hexoBlog/chmod -R 755 /home/hexoBlog/</code></pre><ul><li>查看 Nginx 默认配置的安装位置</li></ul><pre><code class="hljs bash">nginx -t</code></pre><ul><li>修改默认配置，配置就是上一步查到的安装位置</li></ul><pre><code class="hljs bash">vim /etc/nginx/nginx.conf</code></pre><ul><li>按方向键，找到如下位置</li></ul><pre><code class="hljs bash">server &#123;    listen 80 default_server;    listen [::]:80 default_server;    root /home/hexoBlog;    <span class="hljs-comment">#需要修改</span>    server_name barrybean.com; <span class="hljs-comment">#博主的域名，需要修改成对应的域名</span>    <span class="hljs-comment"># Load configuration files for the default server block.</span>    include /etc/nginx/default.d/*.conf;    location / &#123;    &#125;    error_page 404 /404.html;        location = /40x.html &#123;    &#125;</code></pre><ul><li>按<code>i</code>键进入插入模式，将其中的 root 值改为 <code>/home/hexoBlog</code> （刚才创建的托管仓库目录）。<br> 将 server_name 值改成自己相应的<code>域名地址</code>。</li></ul></li><li><p>重启 Nginx 服务</p><pre><code class="hljs bash">service nginx restart</code></pre></li></ol><p>至此，服务器端配置结束。</p><h1 id="hexo本地配置"><a href="#hexo本地配置" class="headerlink" title="hexo本地配置"></a>hexo本地配置</h1><ol><li>设置 hexo 配置文件<ul><li>打开 hexo 的站点配置文件，修改如下。</li></ul></li></ol><pre><code class="hljs bash">deploy:  <span class="hljs-built_in">type</span>: git  repo: root@xx.xx.xx.xx:/home/git/hexoBlog  //xx.xx.xx.xx为服务器地址  branch: master</code></pre><ol start="2"><li>重新生成博客，并部署。</li></ol><pre><code class="hljs bash">hexo cleanhexo generatehexo deploy</code></pre><p>此时就能通过公网 ip，访问 hexo 博客。想自定义域名就得注册域名 + 备案啦。</p><p>参考：<a href="https://www.jianshu.com/p/271449df801f" target="_blank" rel="noopener">Hexo 教程：Hexo 博客部署到腾讯云教程</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周任务</title>
    <link href="/2020/05/08/%E6%AF%8F%E5%91%A8%E4%BB%BB%E5%8A%A1/"/>
    <url>/2020/05/08/%E6%AF%8F%E5%91%A8%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>已完成：</p><p><a href="https://github.com/BarryBean/Sword2Offer" target="_blank" rel="noopener">剑指Offer</a> (67/67)</p><p>待完善：</p><ol><li><p><a href="https://github.com/BarryBean/LeetCodeTop100" target="_blank" rel="noopener">力扣Hot100</a> (85/100)</p></li><li><p><a href="https://github.com/BarryBean/AlgorithmNotes" target="_blank" rel="noopener">算法笔记</a> 长期更新</p></li><li><p><a href="https://github.com/BarryBean/JavaNotes" target="_blank" rel="noopener">JavaNotes</a> 长期更新</p></li><li><p><a href="https://github.com/BarryBean/JavaNotes/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">设计模式</a> (4/23)</p></li></ol><p>下周计划：</p><ol><li>博客部署腾讯云(完成)</li><li>人事管理系统使用FastDFS进行文件上传</li><li>CSDN](<a href="https://blog.csdn.net/qq_34761012)博客搬篇总结" target="_blank" rel="noopener">https://blog.csdn.net/qq_34761012)博客搬篇总结</a></li><li>牛客刷题</li></ol>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2020/05/08/MySQL/"/>
    <url>/2020/05/08/MySQL/</url>
    
    <content type="html"><![CDATA[<p>详细介绍MySQL的索引、事务、锁机制、多版本并发控制、架构和数据库优化。</p><a id="more"></a><h1 id="1-基础理论"><a href="#1-基础理论" class="headerlink" title="1. 基础理论"></a>1. 基础理论</h1><h2 id="1-1-三大范式"><a href="#1-1-三大范式" class="headerlink" title="1.1 三大范式"></a>1.1 三大范式</h2><ul><li>第一范式：每个列都不能再分；</li><li>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能依赖主键的一部分；</li><li>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</li></ul><h2 id="1-2-存储过程"><a href="#1-2-存储过程" class="headerlink" title="1.2 存储过程"></a>1.2 存储过程</h2><p>答：存储过程是一个预编译的SQL语句，只要创建一次，就可以多次调用。</p><p>优点</p><ul><li>预编译过的，执行效率高；</li><li>可重复使用；</li><li>存储过程代码放在数据库里，通过存储过程名可以直接调用。</li></ul><p>缺点</p><ul><li>引用关系对象改变，受影响的存储过程要重新编译；</li><li>维护麻烦。</li></ul><h2 id="1-3-触发器"><a href="#1-3-触发器" class="headerlink" title="1.3 触发器"></a>1.3 触发器</h2><p>答：触发器是用户定义在关系表上的一类由事件驱动的特殊存储过程。通俗理解就是，一段触发某事件后自动执行的代码。</p><p>在insert、update、delete前后都能加入触发器。</p><h2 id="1-4-数据类型"><a href="#1-4-数据类型" class="headerlink" title="1.4 数据类型"></a>1.4 数据类型</h2><ol><li>整数类型。tinyint,smallint,mediumint,int,bigint =&gt; 1,2,3,4,8字节。</li><li>实数类型。float,double,decimal。</li><li>字符串类型。varchar(变长),char(定长),text,blob。</li><li>枚举类型。enum用来代替常用字符串类型。</li><li>日期和时间类型。timestamp,datetime。</li></ol><h2 id="1-5-int-10-char-10-varchar-10-区别"><a href="#1-5-int-10-char-10-varchar-10-区别" class="headerlink" title="1.5 int(10) char(10) varchar(10)区别"></a>1.5 int(10) char(10) varchar(10)区别</h2><ul><li>int(10)表示显示的数据长度，还是4字节存储；</li><li>char(10)表示存储定长的10个字符，不够就用空格补齐；</li><li>varchar(10)表示存储变长的10个字符，存储多少个就是多少个。</li></ul><h2 id="1-6-count-count-1-和count-col"><a href="#1-6-count-count-1-和count-col" class="headerlink" title="1.6 count(*),count(1)和count(col)"></a>1.6 count(*),count(1)和count(col)</h2><ol><li>执行效果上<ul><li>count(*)和count(1)相当于统计行数，不忽略列值为null的；</li><li>count(col)统计col列，忽略null值。</li></ul></li><li>执行效率上<ul><li>count(*)mysql做了优化处理，有主键的情况下，效率更优</li><li>count(1)当没有主键时使用。</li><li>count(col)最慢，因为不走索引。</li></ul></li></ol><h1 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2. 存储引擎"></a>2. 存储引擎</h1><p>答：MySQL是一个关系型数据库，默认端口号是3306。5.5前用MyISAM，5.5后用InnoDB。</p><h2 id="2-1-InnoDB"><a href="#2-1-InnoDB" class="headerlink" title="2.1 InnoDB"></a>2.1 InnoDB</h2><p>答：5.5版本后的默认引擎。默认可重复读的事务隔离级别，主索引是聚簇索引，内部做了诸多优化(插入缓冲区、哈希索引等)，支持热备份。</p><h2 id="2-2-MyISAM"><a href="#2-2-MyISAM" class="headerlink" title="2.2 MyISAM"></a>2.2 MyISAM</h2><p>答：5.5版本前的默认引擎。全文搜索用 match against。</p><h2 id="2-3-MyISAM和InnoDB区别"><a href="#2-3-MyISAM和InnoDB区别" class="headerlink" title="2.3 MyISAM和InnoDB区别"></a>2.3 MyISAM和InnoDB区别</h2><p>答：区别如下：</p><ul><li>行级锁。MyISAM只支持表级锁，InnoDB支持表级锁和行级锁。</li><li>事务支持。MyISAM不支持事务，InnoDB提供事务支持和崩溃恢复。</li><li>外键。MyISAM不支持外键，InnoDB支持外键。</li><li>InnoDB支持多版本并发控制MVVC，可以处理大量数据。</li><li>MyISAM支持全文索引。</li></ul><p>总结一下：<strong>InnoDB支持行+表级锁、事务、外键、多版本并发控制</strong>。</p><h1 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h1><p>索引是一种数据结构，提供指向存储在表的指定列中数据值的指针，能加快检索速度，但同时索引也需要空间存储和定期维护。(通俗理解为书本的目录)</p><h2 id="3-1-类型"><a href="#3-1-类型" class="headerlink" title="3.1 类型"></a>3.1 类型</h2><ul><li>主键索引：数据列不允许重复，不允许null，一个表主键唯一；</li><li>唯一索引：数据列不允许重复，允许null，一个表允许多个唯一索引。</li><li>普通索引：允许null，无唯一性要求。</li><li>全文索引：搜索时使用。</li></ul><h3 id="3-1-1-唯一索引影响插入速度，提高查找速度"><a href="#3-1-1-唯一索引影响插入速度，提高查找速度" class="headerlink" title="3.1.1 唯一索引影响插入速度，提高查找速度"></a>3.1.1 唯一索引影响插入速度，提高查找速度</h3><p>前提：当使用辅助索引时，先判断插入索引页是否在内存，不在则先放在 Change Buffer 中，然后以一定频率进行合并操作。</p><ol><li>插入速度慢<ul><li>唯一索引的插入无法利用Change Buffer。</li><li>因为唯一索引为了保证唯一性，要将数据页全部加载进内存，不用进入缓存。</li></ul></li><li>查找速度快<ul><li>普通索引在找到满足条件的第一条记录后，还需要继续查找，直到第一条不满足条件的记录出现；</li><li>唯一索引在找到满足条件的第一条记录后，直接返回。</li></ul></li></ol><h2 id="3-2-InnoDB索引类型"><a href="#3-2-InnoDB索引类型" class="headerlink" title="3.2 InnoDB索引类型"></a>3.2 InnoDB索引类型</h2><h3 id="3-2-1-B-Tree索引"><a href="#3-2-1-B-Tree索引" class="headerlink" title="3.2.1 B+ Tree索引"></a>3.2.1 B+ Tree索引</h3><p>答：<strong>InnoDB默认的索引方式</strong>。有序索引，将相邻数据都存在一起，把随机IO变成顺序IO。</p><h4 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h4><ul><li>B树，叶子和非叶子节点都存放数据；B+树，只在叶子节点存放数据。</li><li>B+树的叶子节点有一条链相连，能进行顺序索引，而B树的叶子节点各自独立。</li></ul><h4 id="数据库为什么用B-树"><a href="#数据库为什么用B-树" class="headerlink" title="数据库为什么用B+树"></a>数据库为什么用B+树</h4><p>答：总结：</p><ul><li>B+树支持<strong>随机和顺序索引</strong>，B树只支持随机索引；</li><li>B+树查询效率稳定。B+树数据存储在叶子结点中，B树存储在叶子 + 非叶子节点，所以B+树的<strong>查询是从root到叶子节点，不会中断</strong>。</li><li>B+树<strong>内部结点更小</strong>，没有指向关键字的指针，读写消耗小。</li></ul><h4 id="为什么MongoDB使用B树"><a href="#为什么MongoDB使用B树" class="headerlink" title="为什么MongoDB使用B树"></a>为什么MongoDB使用B树</h4><p>答：MySQL是关系型数据库，更多使用范围查询，所以用B+树；MongoDB是非关系型数据库，数据遍历的操作少，常用单一查询，所以用B树。</p><h3 id="3-2-2-哈希索引"><a href="#3-2-2-哈希索引" class="headerlink" title="3.2.2 哈希索引"></a>3.2.2 哈希索引</h3><p>答：类似哈希表，将数据库字段转换成hash值和行指针放进hash表。以O(1)时间搜索，但无法排序分组，<strong>只能精准查找</strong>。</p><p>自适应哈希索引：当某个索引被频繁引用时，在B+树索引上再创建一个哈希索引，提供快速查找。<br> 。</p><h2 id="3-3-聚簇索引-主索引-和非聚簇索引-辅助索引"><a href="#3-3-聚簇索引-主索引-和非聚簇索引-辅助索引" class="headerlink" title="3.3 聚簇索引(主索引)和非聚簇索引(辅助索引)"></a>3.3 聚簇索引(主索引)和非聚簇索引(辅助索引)</h2><p>答：B+ Tree索引分为主索引和辅助索引。</p><ul><li>聚簇索引/主索引：叶子<strong>结点存储数据</strong>。直接找key就能获得数据。一个表只能包含一个主索引。</li><li>非聚簇索引/辅助索引：叶子<strong>结点存储主键</strong>的值。需要先取得主键，再用此主键走一遍主索引。(回表，若全部命中索引，也可以不用回表)</li></ul><h2 id="3-4-索引优化"><a href="#3-4-索引优化" class="headerlink" title="3.4 索引优化"></a>3.4 索引优化</h2><h3 id="3-4-1-索引列顺序"><a href="#3-4-1-索引列顺序" class="headerlink" title="3.4.1 索引列顺序"></a>3.4.1 索引列顺序</h3><p>答：把<strong>选择性最强/使用最频繁的索引放在前面</strong>。索引选择性=不重复的索引值 / 记录总数。</p><h3 id="3-4-2-覆盖索引"><a href="#3-4-2-覆盖索引" class="headerlink" title="3.4.2 覆盖索引"></a>3.4.2 覆盖索引</h3><p>答：覆盖索引是select的数据列只用从索引中就能够取得，不必读取数据行，即查询列要被所建的索引覆盖。</p><h3 id="3-4-3-前缀索引"><a href="#3-4-3-前缀索引" class="headerlink" title="3.4.3 前缀索引"></a>3.4.3 前缀索引</h3><p>答：根据选择性，只<strong>索引</strong>字符串的<strong>最左M个字符</strong>，前提是前缀的标识度高。</p><h3 id="3-4-4-索引下推"><a href="#3-4-4-索引下推" class="headerlink" title="3.4.4 索引下推"></a>3.4.4 索引下推</h3><p>答：<strong>联合索引</strong>时，先对其余其他字段判断，<strong>过滤不满足条件的记录</strong>，减少回表次数和数据数量。</p><h3 id="3-4-5-最左前缀匹配原则"><a href="#3-4-5-最左前缀匹配原则" class="headerlink" title="3.4.5 最左前缀匹配原则"></a>3.4.5 最左前缀匹配原则</h3><p>联合索引时，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)停止，所以要注意联合索引的顺序。</p><h2 id="3-5-SQL语句"><a href="#3-5-SQL语句" class="headerlink" title="3.5 SQL语句"></a>3.5 SQL语句</h2><pre><code class="hljs java"><span class="hljs-comment">//增加索引</span>alter table user add index/unique/<span class="hljs-function">fulltext <span class="hljs-title">user_id</span><span class="hljs-params">(id)</span> </span><span class="hljs-function">create index/unique user_id on <span class="hljs-title">user</span><span class="hljs-params">(id)</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-comment">//删除索引</span></span><span class="hljs-function">alter table user drop key user_id</span></code></pre><h2 id="3-6-小知识"><a href="#3-6-小知识" class="headerlink" title="3.6 小知识"></a>3.6 小知识</h2><h3 id="3-6-1-回表"><a href="#3-6-1-回表" class="headerlink" title="3.6.1 回表"></a>3.6.1 回表</h3><p>答：回表就是指普通索引查询，先搜索普通索引树获得主键值，再到主键索引树搜索一次。</p><h3 id="3-6-2-百万级数据删除"><a href="#3-6-2-百万级数据删除" class="headerlink" title="3.6.2 百万级数据删除"></a>3.6.2 百万级数据删除</h3><p>答：百万级以上的数据一定存在索引，CRUD时都会对索引有影响，所以先删除索引，再删无用数据，循环。</p><h1 id="4-事务"><a href="#4-事务" class="headerlink" title="4. 事务"></a>4. 事务</h1><p>答：事务就是逻辑上的一组操作，要么都执行，要么都不执行，执行结果必须让数据库从一种一致性状态到另一种一致性状态。</p><h2 id="4-1-四大特性ACID"><a href="#4-1-四大特性ACID" class="headerlink" title="4.1 四大特性ACID"></a>4.1 四大特性ACID</h2><p>答：ACID。</p><ul><li><strong>原子性</strong>(Atomicity)：事务是最小的执行单位，要么全部执行，要么全部不执行。</li><li><strong>一致性</strong>(Consistency)：保证数据库状态要一致，多个事务对同一数据读取结果是相同的。</li><li><strong>隔离性</strong>(Isolation)：多个事务并发，各个事务是不受其他事务干扰的。</li><li><strong>持久性</strong>(Durability)：一个事务一旦提交，此修改在数据库中是持久保存的。</li></ul><p>持久性应对系统GG，只有一致性才能保证执行结果正确，并发才要隔离性，原子性是最基础的。</p><h2 id="4-2-并发事务的问题"><a href="#4-2-并发事务的问题" class="headerlink" title="4.2 并发事务的问题"></a>4.2 并发事务的问题</h2><ul><li><strong>脏读</strong>(Dirty read)：事务A读取了事务B修改未提交的数据，B回滚，A的数据不一致。</li><li><strong>丢失修改</strong>(Lost to modify)：事务A和B同时读取数据，A修改后先提交，B修改后再提交会将A的修改覆盖。</li><li><strong>不可重复读</strong>(Unrepeatable read)：事务A两次读取数据间，有事务B修改更新，导致两次读取数据不一致。</li><li><strong>幻读</strong>(Phantom read)：事务A两次读取数据间，有事务B增加了记录，导致两次读取数据记录数不一致。</li></ul><p>注：<strong>幻读指结构</strong>上发生变化。<strong>不可重复读指数值</strong>上发生变化。</p><h2 id="4-3-隔离级别"><a href="#4-3-隔离级别" class="headerlink" title="4.3 隔离级别"></a>4.3 隔离级别</h2><p>答：MySQL定义了四个隔离级别。</p><ul><li><strong>读未提交</strong>(Read-Uncommitted)：最低级别，允许读取尚未提交的数据。会发生脏读、幻读、不可重复读。</li><li><strong>读已提交</strong>(Read-Committed)：允许读取已经提交的数据。阻止脏读。<strong>oracle默认</strong></li><li><strong>可重复读</strong>(Repeatable-Read)：读事务时禁止写事务，写事务时阻止一切。阻止脏读和不可重复读。<strong>InnoDB默认隔离级别</strong>。</li><li><strong>可串行化</strong>(Serialization)：最高级别。所有事务依次执行，不会互相干扰。阻止三个事务问题。</li></ul><h1 id="5-锁机制"><a href="#5-锁机制" class="headerlink" title="5. 锁机制"></a>5. 锁机制</h1><p>锁机制是在并发时，确保数据访问次序的。</p><h2 id="5-1-按粒度分"><a href="#5-1-按粒度分" class="headerlink" title="5.1 按粒度分"></a>5.1 按粒度分</h2><p>答：分为表级锁，行级锁和页级锁。</p><ul><li><strong>表级锁</strong>：粒度最大的锁。<strong>对整张表加锁</strong>，资源消耗少，加锁快，不会死锁，但锁冲突概率高。</li><li><strong>行级锁</strong>：粒度最小的锁。<strong>对</strong>当前<strong>操作行加锁</strong>，加锁慢，开销大，会死锁，但大大减少冲突。</li><li><strong>页级锁</strong>：介于行级锁和表级锁中间的锁。<strong>一次锁定相邻的一组记录</strong>，会死锁，其他均属于中等。</li></ul><h3 id="5-1-1-常见行级锁"><a href="#5-1-1-常见行级锁" class="headerlink" title="5.1.1 常见行级锁"></a>5.1.1 常见行级锁</h3><p>答：有三种。</p><ul><li>Record Lock：单行锁，锁定符合条件的行。</li><li>Gap Lock：间隙锁，锁定一个范围，不含记录本身。防止幻读。</li><li><strong>Next-key Lock：Record+Gap，锁定一个范围，含记录本身</strong>。</li></ul><h3 id="5-1-2-表级锁使用场景"><a href="#5-1-2-表级锁使用场景" class="headerlink" title="5.1.2 表级锁使用场景"></a>5.1.2 表级锁使用场景</h3><p>答：当事务比较复杂，使用行级锁容易死锁回滚。更新大表的大部分数据，表级锁效率更好。</p><h3 id="5-1-3-行级锁何时会锁住整张表"><a href="#5-1-3-行级锁何时会锁住整张表" class="headerlink" title="5.1.3 行级锁何时会锁住整张表"></a>5.1.3 行级锁何时会锁住整张表</h3><p>答：更新的列没有建立索引，会直接锁住整张表。</p><h2 id="5-2-按是否可写分"><a href="#5-2-按是否可写分" class="headerlink" title="5.2 按是否可写分"></a>5.2 按是否可写分</h2><p>答：可以进一步划分为共享锁和排他锁。</p><ul><li><strong>共享锁</strong>(Shared Lock)：读锁。锁定的资源能被其他用户读取，但不能修改，直到资源上的S锁全部被释放。</li><li><strong>排他锁</strong>(Exclusive Lock)：写锁。事务T对数据A加X锁，则只允许T读取修改，直到X锁释放。在更新操作，如insert、update 或 delete时，始终应用排它锁。</li></ul><h3 id="5-2-1-意向锁"><a href="#5-2-1-意向锁" class="headerlink" title="5.2.1 意向锁"></a>5.2.1 意向锁</h3><p>意向锁都是表锁，表示事务想在表中某数据行上加 S 或 X 锁。</p><ul><li>事务想加 X 锁，先检测表A有无 X/IX/S/IS锁，有则加互斥锁失败；</li><li>想加 S 锁，先检测表A有无 X/IX，有则加读锁失败。</li><li>IS 和 IX 之间是相互兼容的，因为是意向，并没有真正加锁。</li></ul><h2 id="5-3-死锁"><a href="#5-3-死锁" class="headerlink" title="5.3 死锁"></a>5.3 死锁</h2><p>答：MySQL中的死锁是<strong>多个事务使用行级锁对某行数据加锁造成</strong>。</p><h3 id="5-3-1-解决方案"><a href="#5-3-1-解决方案" class="headerlink" title="5.3.1 解决方案"></a>5.3.1 解决方案</h3><p>答：分为两个方面。<br>业务层面：</p><ul><li>指定锁的获取资源顺序。(操作系统中的哲学家就餐问题)</li><li>同一个事务一次锁定尽可能多的资源。</li><li>事务拆分成小事务。</li></ul><p>数据库设置：</p><ul><li>设置超时时间。InnoDB默认是50s。</li><li>开启死锁检测。发生死锁时，回归死锁链上一个事务，让其他事务继续执行。</li></ul><h2 id="5-4-悲观锁和乐观锁"><a href="#5-4-悲观锁和乐观锁" class="headerlink" title="5.4 悲观锁和乐观锁"></a>5.4 悲观锁和乐观锁</h2><p>答：悲观锁和乐观锁是数据库管理系统并发控制的手段。</p><ul><li><strong>悲观锁</strong>：<strong>利用数据库的锁机制</strong>实现，在整个数据处理过程都加锁，<strong>保证排他性</strong>。</li><li><strong>乐观锁</strong>：<strong>CAS/版本号实现</strong>。假定不会发生冲突，在提交时检查是否违反数据完整性。</li></ul><h3 id="5-4-1-乐观锁的ABA问题"><a href="#5-4-1-乐观锁的ABA问题" class="headerlink" title="5.4.1 乐观锁的ABA问题"></a>5.4.1 乐观锁的ABA问题</h3><p>答：加入<strong>数据版本记录机制</strong>或者使用时间戳。</p><p>ABA问题：事务X读取数据A时，事务Y修改成B，又修改回A，事实上数据发生过改变的，存在并发问题，但事务X无法得到数据发生过变化。</p><h3 id="5-4-2-使用场景"><a href="#5-4-2-使用场景" class="headerlink" title="5.4.2 使用场景"></a>5.4.2 使用场景</h3><p>答：多读用乐观，多写用悲观。</p><h1 id="6-MySQL架构和执行流程"><a href="#6-MySQL架构和执行流程" class="headerlink" title="6. MySQL架构和执行流程"></a>6. MySQL架构和执行流程</h1><h2 id="6-1-基础架构"><a href="#6-1-基础架构" class="headerlink" title="6.1 基础架构"></a>6.1 基础架构</h2><p>答：MySQL主要分为Server层和存储引擎层。</p><ul><li><strong>Server层</strong>：跨存储引擎的功能都在此实现，如视图、触发器、函数等，有一个binlog日志。</li><li><strong>存储引擎</strong>：负责数据的存储和读取。常用的是InnoDB，自带redolog模块。</li></ul><h2 id="6-2-基本组件"><a href="#6-2-基本组件" class="headerlink" title="6.2 基本组件"></a>6.2 基本组件</h2><p>答：Server层有五个主要组件。</p><ul><li>连接器：身份验证和权限设置。</li><li>查询缓存：执行查询语句前，先查有没有缓存的结果集。(8.0后废弃)</li><li>分析器：没有命中缓存，则进入分析器进行词法和语法分析。</li><li>优化器：按照MySQL认为最优的方案执行。</li><li>执行器：用户有权限，则调用存储引擎，执行语句。</li></ul><h2 id="6-3-执行流程"><a href="#6-3-执行流程" class="headerlink" title="6.3 执行流程"></a>6.3 执行流程</h2><h3 id="6-3-1-查询语句"><a href="#6-3-1-查询语句" class="headerlink" title="6.3.1 查询语句"></a>6.3.1 查询语句</h3><p>权限校验—-&gt;查询缓存—-&gt;分析器—-&gt;优化器—-&gt;权限校验—-&gt;执行器—-&gt;引擎</p><h3 id="6-3-2-更新语句"><a href="#6-3-2-更新语句" class="headerlink" title="6.3.2 更新语句"></a>6.3.2 更新语句</h3><p>分析器—-&gt;权限校验—-&gt;执行器—-&gt;引擎—-&gt;redo log prepare—-&gt;binlog—-&gt;redo log commit</p><p>以修改张三的年龄为例：</p><ul><li>先查询到张三这条数据，如果有缓存，用缓存。</li><li>拿到查询的语句，把 age 改为 19。</li><li>调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态。</li><li>通知执行器，执行完成，可以提交。</li><li>执行器收到通知后记录 binlog，调用引擎接口，提交 redo log 为提交状态。</li><li>更新完成。</li></ul><h2 id="6-4-日志模块"><a href="#6-4-日志模块" class="headerlink" title="6.4 日志模块"></a>6.4 日志模块</h2><p>答：MySQL主要有redolog和binlog。</p><ul><li><strong>redolog(重做日志)</strong>：InnoDB特有，物理日志。<strong>记录哪个数据页做了修改</strong>。</li><li><strong>binlog(归档日志)</strong>：Server层自带，逻辑日志，<strong>记录本次修改的SQL语句</strong>。通常使用row二进制格式，保证数据记录的准确性。</li></ul><h3 id="6-4-1-两阶段提交"><a href="#6-4-1-两阶段提交" class="headerlink" title="6.4.1 两阶段提交"></a>6.4.1 两阶段提交</h3><p>答：保证数据一致性。</p><p><strong>redolog prepare引擎数据保存 -&gt; binlog执行器收到信号 -&gt; redolog commit执行器调用</strong></p><p>异常时，MySQL先判断redolog是否完整，完整则直接提交。redolog只是prepare状态，查看binlog是否完整，完整就继续提交redolog，否则回滚事务。</p><h3 id="6-4-2-MySQL为什么会突然慢一下"><a href="#6-4-2-MySQL为什么会突然慢一下" class="headerlink" title="6.4.2 MySQL为什么会突然慢一下"></a>6.4.2 MySQL为什么会突然慢一下</h3><p>答：更新数据库时，先写日志，等合适时间再更新磁盘。当redolog写满，需要<strong>flush脏页</strong>，将数据写入磁盘，这是会使执行速度慢一下。</p><h1 id="7-多版本并发控制"><a href="#7-多版本并发控制" class="headerlink" title="7. 多版本并发控制"></a>7. 多版本并发控制</h1><p><strong>MVCC</strong> 多版本并发控制是 InnoDB 实现隔离级别的方式，<strong>用于读已提交和可重复读</strong>。</p><blockquote><p>提一嘴，Next-Key Locks 解决幻读，锁自己Record+锁范围Gap。</p></blockquote><h2 id="7-1-基本思想"><a href="#7-1-基本思想" class="headerlink" title="7.1 基本思想"></a>7.1 基本思想</h2><p>事务的修改操作会为数据行新增一个版本快照，<strong>写操作更新最新的版本快照，读操作去读旧版本快照</strong>。</p><blockquote><p>注：脏读和不可重复读的原因是事务读取到其他事务未提交的修改。</p></blockquote><h2 id="7-2-Undo日志"><a href="#7-2-Undo日志" class="headerlink" title="7.2 Undo日志"></a>7.2 Undo日志</h2><p>多版本就是指多个版本的快照，快照存储在 Undo 日志中，通过回滚指针把一个数据行的所有快照连接起来。</p><ul><li>系统版本号SYS_ID：递增数字，每一个新事务，就++；</li><li>事务版本号TRX_ID：事务开始时的系统版本号。</li></ul><h2 id="7-3-ReadView"><a href="#7-3-ReadView" class="headerlink" title="7.3 ReadView"></a>7.3 ReadView</h2><p>MVCC 维护了 ReadView 结构，包含当前系统未提交的事务列表TRX_IDs，列表的最大值和最小值。</p><h2 id="7-4-SELECT"><a href="#7-4-SELECT" class="headerlink" title="7.4 SELECT"></a>7.4 SELECT</h2><p>根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：</p><ol><li>TRX_ID &lt; TRX_ID_MIN，表示该数据行快照是在当前所有未提交事务之前进行更改的，因此可以使用。</li><li>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li><li>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：<ul><li>提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li><li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li></ul></li></ol><p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。</p><p>此节参考：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E4%BA%94%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">CyC2018数据库系统原理-多版本并发控制</a></p><h1 id="8-优化"><a href="#8-优化" class="headerlink" title="8. 优化"></a>8. 优化</h1><h2 id="8-1-结构优化"><a href="#8-1-结构优化" class="headerlink" title="8.1 结构优化"></a>8.1 结构优化</h2><ol><li>拆表。把使用频率低的列单独分离成表。</li><li>增加中间表。把经常联合查询数据插入中间表。</li><li>增加冗余字段。</li></ol><h2 id="8-2-SQL优化"><a href="#8-2-SQL优化" class="headerlink" title="8.2 SQL优化"></a>8.2 SQL优化</h2><h3 id="8-2-1-超大分页"><a href="#8-2-1-超大分页" class="headerlink" title="8.2.1 超大分页"></a>8.2.1 超大分页</h3><p>答：两个思路。</p><ul><li>减少load的数据，如先定位id再关联；</li><li>增加缓存，如redis。</li></ul><h3 id="8-2-2-慢查询日志"><a href="#8-2-2-慢查询日志" class="headerlink" title="8.2.2 慢查询日志"></a>8.2.2 慢查询日志</h3><p>答：当执行时间超过临界值时，将SQL计入日志。慢查询优化主要从三方面入手。</p><ul><li>load了额外数据；</li><li>没有命中索引；</li><li>数据量太大，需要切分。</li></ul><h3 id="8-2-3-语句优化"><a href="#8-2-3-语句优化" class="headerlink" title="8.2.3 语句优化"></a>8.2.3 语句优化</h3><p>参考 <a href="https://www.cnblogs.com/huchong/p/10219318.html" target="_blank" rel="noopener">https://www.cnblogs.com/huchong/p/10219318.html</a> 作者：听风。</p><h2 id="8-3-大表优化"><a href="#8-3-大表优化" class="headerlink" title="8.3 大表优化"></a>8.3 大表优化</h2><p>答：单表记录数过大时，数据库性能下降明显，需要进行一系列的优化。</p><h3 id="8-3-1-限定数据范围"><a href="#8-3-1-限定数据范围" class="headerlink" title="8.3.1 限定数据范围"></a>8.3.1 限定数据范围</h3><p>最简单的手段，限制数据范围条件来查询数据。</p><h3 id="8-3-2-读写分离"><a href="#8-3-2-读写分离" class="headerlink" title="8.3.2 读写分离"></a>8.3.2 读写分离</h3><p><strong>主服务器处理写操作</strong>或实时性高的读操作，<strong>从服务器处理读操作</strong>。</p><ul><li>实现方式：增设代理服务器，决定将应用传来的请求转发到哪个服务器。</li><li>原因：极大减少了锁的争用；用冗余换可用性；从服务器可用MyISAM节约资源。<br><img src="/img/db/%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93.png" srcset="/img/loading.gif" alt="主从数据库"></li></ul><h3 id="8-3-3-缓存"><a href="#8-3-3-缓存" class="headerlink" title="8.3.3 缓存"></a>8.3.3 缓存</h3><p>对基本不更新的数据使用应用级别的缓存。</p><h3 id="8-3-4-水平拆分"><a href="#8-3-4-水平拆分" class="headerlink" title="8.3.4 水平拆分"></a>8.3.4 水平拆分</h3><p>水平拆分将一张表A拆分成多个相同结构的表a1,a2,a3存储，每个子表只占一部分数据。<br>又细分为库内分表和分库分表。</p><ul><li><strong>库内分表</strong>：子表仍在一个数据库实例中，仍要竞争同一个物理机资源。</li><li><strong>分库分表</strong>：子表分散在不同数据库中。</li></ul><p>优点：业务改造简单；解决了单表数据量过大的问题。<br>缺点：跨库的一致性难保证；join关联性能差；扩容和维护难度过大。</p><h3 id="8-3-5-垂直拆分"><a href="#8-3-5-垂直拆分" class="headerlink" title="8.3.5 垂直拆分"></a>8.3.5 垂直拆分</h3><p>又细分为垂直分库和垂直分表。</p><ul><li><strong>垂直分库</strong>：基于业务划分数据库，让每个业务都有独立数据库。</li><li><strong>垂直分表</strong>：基于数据表的列切分，把一张列1-7的表拆成列1-4和列1 5-7的表。</li></ul><p>优点：业务解耦；高并发下提升了性能。<br>缺点：增加了业务复杂度；<strong>主键冗余</strong>；数据量过大仍未解决，需要配合水平拆分。</p><h2 id="8-4-拆分后的问题"><a href="#8-4-拆分后的问题" class="headerlink" title="8.4 拆分后的问题"></a>8.4 拆分后的问题</h2><ol><li>事务一致性<br>两阶段提交性能较差。通常<strong>追求最终一致性</strong>，出现问题进行事务补偿。</li><li>分页和排序<br>字段排序，需要先在每个节点内排序，再将结果汇总再次排序，最后返回给用户。</li><li>全局唯一主键<br>拆分后属于分布式应用，需要使用<strong>分布式ID用作全局唯一主键</strong>。一般用雪花模型。</li></ol><p>注：所以推荐使用成熟的中间件，如sharding-jdbc，Atlas，Cobar</p><h2 id="8-5-分布式ID"><a href="#8-5-分布式ID" class="headerlink" title="8.5 分布式ID"></a>8.5 分布式ID</h2><ol><li>UUID：生成简单，但不推荐！长度过长，不适合实际的业务需求。<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String uuid = UUID.randomUUID().toString().replaceAll(<span class="hljs-string">"-"</span>,<span class="hljs-string">""</span>);       System.out.println(uuid); &#125;</code></pre></li><li>数据库自增ID：用一个单独数据库实例生成ID，需要ID时，向表中插入记录并返回ID。<ul><li>MySQL本身性能是瓶颈，而且存在宕机风险。</li></ul></li><li>数据库集群：对每个MySQL实例的自增ID设置起始值和自增步长，保证不冲突。<ul><li>后续扩容问题大，无法满足高并发。</li></ul></li><li>数据库号段模式：每次从数据库获取一个号段范围，具体业务将号段生成对应自增ID加载到内存。一批号段ID用完，再向数据库申请新的。<ul><li>用版本号乐观锁更新；不频繁访问数据库。</li></ul></li><li><strong>雪花算法</strong>：twitter公司开源的算法。<ul><li>Snowflake生成Long型<strong>64位ID</strong>。</li><li>组成结构：正数位（1bit，默认0）+ 时间戳（41bit，存储 当前-固定开始 的差值）+ 机器ID（5bit）+ 数据中心（5bit）+ 自增值（12bit，1ms支持同一节点生成4096个ID）</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认证授权和网络攻击</title>
    <link href="/2020/05/08/%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E5%92%8C%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"/>
    <url>/2020/05/08/%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E5%92%8C%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<p>常见的授权方式，如 Cookie、Session、Token和OAuth2.0，以及常问的几种网络攻击方式，XSS、CSRF、SQL注入和Dos。</p><p>OAuth参照阮一峰的系列文章。</p><a id="more"></a><h1 id="1-认证授权"><a href="#1-认证授权" class="headerlink" title="1. 认证授权"></a>1. 认证授权</h1><h2 id="1-1-Authentication和Authorization"><a href="#1-1-Authentication和Authorization" class="headerlink" title="1.1 Authentication和Authorization"></a>1.1 Authentication和Authorization</h2><p>答：通俗说，认证 Authentication 就是你是谁，授权 Authorization 就是你有权干什么。</p><h2 id="1-2-Cookie和Session"><a href="#1-2-Cookie和Session" class="headerlink" title="1.2 Cookie和Session"></a>1.2 Cookie和Session</h2><ul><li>Cookie是保存在客户端，用来保存用户信息的数据。内有SessionID。</li><li>Session是保存在服务端，用来记录用户状态的数据。通过SessionID标识用户，放在redis里。</li></ul><h3 id="1-2-1-认证流程"><a href="#1-2-1-认证流程" class="headerlink" title="1.2.1 认证流程"></a>1.2.1 认证流程</h3><ol><li>Client发送用户名密码登录系统；</li><li>Server验证通过，创建Session标识用户，并保存redis；</li><li>Server返回SessionID，写入Client的cookie；</li><li>Client之后所有请求都带cookie发出；</li><li>Server通过redis中的Session信息和cookie中的SessionID比较，验证身份。</li></ol><h3 id="1-2-2-Cookie禁用"><a href="#1-2-2-Cookie禁用" class="headerlink" title="1.2.2 Cookie禁用"></a>1.2.2 Cookie禁用</h3><p>答：不是没有Cookie就不能用Session，还可以把Session<strong>直接拼接URL</strong>，或者加密后再拼接。</p><h3 id="1-2-3-安全问题"><a href="#1-2-3-安全问题" class="headerlink" title="1.2.3 安全问题"></a>1.2.3 安全问题</h3><p>答：Cookie无法阻止CSRF跨站请求伪造，因为只要拿到SessionID就能冒用身份进行访问。</p><h2 id="1-3-Token"><a href="#1-3-Token" class="headerlink" title="1.3 Token"></a>1.3 Token</h2><p>答：Token令牌，本质上是一段<strong>带有签名的 JSON 格式数据</strong>。客户端将Server发来的Token保存在localStorage/Cookie中，之后所有请求都携带令牌。服务端并不保存，每次只用解密token查询用户信息。</p><h3 id="1-3-1-流程"><a href="#1-3-1-流程" class="headerlink" title="1.3.1 流程"></a>1.3.1 流程</h3><ol><li>用户发送用户名和密码登录；</li><li>验证通过，返回带签名的JWT；</li><li>Client每次请求都在Header中携带JWT；</li><li>Server检查JWT获得用户信息。</li></ol><h3 id="1-3-2-为何防止CSRF"><a href="#1-3-2-为何防止CSRF" class="headerlink" title="1.3.2 为何防止CSRF"></a>1.3.2 为何防止CSRF</h3><p>答：Token放在Cookie中，同源页面每次发请求都在请求头或者参数中加入Cookie中读取的Token来完成验证。CSRF只能通过浏览器带上Cookie，无法获取该用户的Token的具体值。</p><p>注：这时候的Cookie纯粹当作一个存储的容器。</p><h2 id="1-4-OAuth2-0"><a href="#1-4-OAuth2-0" class="headerlink" title="1.4 OAuth2.0"></a>1.4 OAuth2.0</h2><p>OAuth2.0是一种授权标准，为第三方应用颁发有时效性的 Token 从而对系统获取一定的权限。</p><h3 id="1-4-1-token和密码的区别"><a href="#1-4-1-token和密码的区别" class="headerlink" title="1.4.1 token和密码的区别"></a>1.4.1 token和密码的区别</h3><ol><li>令牌<strong>到期自动失效</strong>，密码长期有效；</li><li>令牌不能自己修改，<strong>只能被数据所有者撤销</strong>，密码能被用户修改，但不会被外力撤销；</li><li>令牌<strong>有权限范围</strong>，密码一般都是所属角色的完整权限。 </li></ol><h3 id="1-4-2-四种方式"><a href="#1-4-2-四种方式" class="headerlink" title="1.4.2 四种方式"></a>1.4.2 四种方式</h3><ol><li>授权码。最常用的，有后台有前端。<ul><li>第三方应用先申请一个授权码，再用该码获取令牌；</li><li>授权码在前端，令牌保存后端。</li></ul></li></ol><p>流程：</p><ol><li><p>A提供如下链接，点击后跳转B，进行授权。四个参数分别是<code>返回的授权码</code>，<code>客户端id</code>，<code>接受/拒绝后的跳转地址</code>，<code>授权范围</code>。</p></li><li><p>B要求用户登录，并询问是否给授权。若同意，B跳转到指定地址，同时传回授权码。</p><pre><code class="hljs html">https://b.com/oauth/authorize?  response_type=code&amp;  client_id=CLIENT_ID&amp;  redirect_uri=CALLBACK_URL&amp;  scope=read</code></pre></li><li><p>A拿到授权码，对B发送请求获得令牌。参数分别是<code>客户端id</code>和<code>secret</code>用来确认身份，<code>认证类型</code>即authorization_code，上一步拿到的<code>授权码</code>，令牌颁发的<code>回调地址</code>。</p></li><li><p>B收到请求，向回调地址发送一段 json数据，即颁发令牌。</p><pre><code class="hljs html">https://b.com/oauth/token? client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; grant_type=authorization_code&amp; code=AUTHORIZATION_CODE&amp; redirect_uri=CALLBACK_URL</code></pre></li><li><p>隐藏式</p><ul><li>没有后端，直接令牌存在前端，跳过授权码的步骤。</li></ul></li><li><p>密码式</p><ul><li>第三方应用用你的密码去申请令牌。</li></ul></li><li><p>客户端凭证</p><ul><li>可能多个用户共享一个令牌。</li></ul></li></ol><h3 id="1-4-3-令牌更新"><a href="#1-4-3-令牌更新" class="headerlink" title="1.4.3 令牌更新"></a>1.4.3 令牌更新</h3><p>一次颁发两个令牌，一个用来获取数据，一个用来获取新的令牌。令牌到期时，用户使用 <code>refresh token</code> 发请求，去更新令牌。</p><h2 id="1-5-SSO"><a href="#1-5-SSO" class="headerlink" title="1.5 SSO"></a>1.5 SSO</h2><p>单点登录，解决一个公司多个相关子系统间的登陆问题。登录一个就等同登录一群。</p><h1 id="2-安全漏洞"><a href="#2-安全漏洞" class="headerlink" title="2.安全漏洞"></a>2.安全漏洞</h1><h2 id="2-1-XSS跨站脚本攻击"><a href="#2-1-XSS跨站脚本攻击" class="headerlink" title="2.1 XSS跨站脚本攻击"></a>2.1 XSS跨站脚本攻击</h2><p>答：XSS(Cross-Site Scripting)跨站脚本攻击，通过<strong>在用户提交数据中加入恶意代码</strong>，从而破坏页面结构，盗取用户资料等。XSS利用用户对网站的信任。</p><h3 id="2-1-1-产生原因"><a href="#2-1-1-产生原因" class="headerlink" title="2.1.1 产生原因"></a>2.1.1 产生原因</h3><p>答：过分信任客户端数据，没有对数据进行过滤和转移。</p><h3 id="2-1-2-分类"><a href="#2-1-2-分类" class="headerlink" title="2.1.2 分类"></a>2.1.2 分类</h3><p>答：分为：</p><ul><li>存储型：恶意代码<strong>放在数据库中</strong>，每次Server响应Client请求时返回并执行；</li><li>反射型：恶意代码<strong>加在URL中作为参数</strong>提交，Server解析响应，恶意代码存在结果中；</li><li>DOM型：<strong>前端JS的漏洞</strong>，恶意代码在Client执行。</li></ul><h3 id="2-1-3-防御"><a href="#2-1-3-防御" class="headerlink" title="2.1.3 防御"></a>2.1.3 防御</h3><p>答：简单方法：</p><ul><li><strong>过滤特殊字符</strong>，比如将&lt;转义为&amp;lt。</li><li>对重要<strong>cookie设置httpOnly</strong>，防止前端通过document获得。</li></ul><h2 id="2-2-CSRF跨站请求伪造"><a href="#2-2-CSRF跨站请求伪造" class="headerlink" title="2.2 CSRF跨站请求伪造"></a>2.2 CSRF跨站请求伪造</h2><p>答：CSRF(Cross-site request forgery)跨站请求伪造，通过恶意网站<strong>伪装成受信任用户进行请求访问</strong>获取数据。恶意网站只能冒用cookie，不能获得cookie。CSRF利用网站对Client的信任。</p><h3 id="2-2-1-过程"><a href="#2-2-1-过程" class="headerlink" title="2.2.1 过程"></a>2.2.1 过程</h3><p><img src="/img/network/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0.png" srcset="/img/loading.gif" alt="跨站请求伪造"></p><h3 id="2-2-2-防御"><a href="#2-2-2-防御" class="headerlink" title="2.2.2 防御"></a>2.2.2 防御</h3><p>答：常用方法：</p><ul><li><strong>Referer字段验证</strong>：<strong>不适用，Referer能被篡改</strong>。HTTP头中用Referer字段记录请求的源地址。</li><li><strong>Token验证</strong>：<strong>Server发给Client一个Token，Client发出带Token的请求</strong>，若Token不合法，则Server拒绝请求。</li><li><strong>双重Cookie验证</strong>：Client将<strong>Cookie参数加入请求参数</strong>中，Server校验，若无附加的cookie参数则拒绝请求。</li><li><strong>验证码</strong>：在用户进行敏感操作时，要求用户输入验证码。</li></ul><h3 id="2-2-3-XSS和CSRF区别"><a href="#2-2-3-XSS和CSRF区别" class="headerlink" title="2.2.3 XSS和CSRF区别"></a>2.2.3 XSS和CSRF区别</h3><p>答：总结为：</p><ul><li>CSRF需要用户先登录网站A，恶意网站B再冒用用户在A的cookie。XSS不需要登录。</li><li>CSRF本质是利用网站漏洞请求接口，XSS本质是注入恶意代码篡改内容。</li></ul><h2 id="2-3-SSRF服务端请求伪造"><a href="#2-3-SSRF服务端请求伪造" class="headerlink" title="2.3 SSRF服务端请求伪造"></a>2.3 SSRF服务端请求伪造</h2><p>答：SSRF(Server-site request forgery)服务端请求伪造，通过Server使得<strong>外网能访问内网系统</strong>。</p><h3 id="2-3-1-过程"><a href="#2-3-1-过程" class="headerlink" title="2.3.1 过程"></a>2.3.1 过程</h3><p><img src="/img/network/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0.png" srcset="/img/loading.gif" alt="服务端请求伪造"></p><h3 id="2-3-2-原因"><a href="#2-3-2-原因" class="headerlink" title="2.3.2 原因"></a>2.3.2 原因</h3><p>答：Server提供从其他服务器获取数据，但没有对地址做过滤限制。</p><h3 id="2-3-3-防御"><a href="#2-3-3-防御" class="headerlink" title="2.3.3 防御"></a>2.3.3 防御</h3><p>答：常用方法：</p><ul><li><strong>限制请求端口</strong>。保留常用HTTP端口。</li><li><strong>设置IP黑名单</strong>。一经发现直接拉黑。</li><li><strong>禁用不必要的协议</strong>。只保留HTTP和HTTPS。</li><li><strong>过滤返回信息</strong>。</li></ul><h2 id="2-4-SQL注入"><a href="#2-4-SQL注入" class="headerlink" title="2.4 SQL注入"></a>2.4 SQL注入</h2><p>答：SQL注入指<strong>把SQL命令插入请求字符串或者页面提交中，欺骗Server执行</strong>。大多都是利用设计漏洞，没有对用户输入数据进行校验。比如：</p><blockquote><p>strSQL = “SELECT * FROM users WHERE (name = ‘1’ OR ‘1’=’1’) and (pw = ‘1’ OR ‘1’=’1’);”<br>//获得用户信息。</p></blockquote><h3 id="2-4-1-防御"><a href="#2-4-1-防御" class="headerlink" title="2.4.1 防御"></a>2.4.1 防御</h3><p>答：常用方法：</p><ul><li><strong>预编译语句</strong>。直接传入数据执行，<strong>避免</strong>进行<strong>SQL</strong>语句<strong>拼接</strong>。使用占位符，#{}。</li><li>对Client的输入进行类型检查。</li></ul><h2 id="2-5-DoS拒绝服务攻击"><a href="#2-5-DoS拒绝服务攻击" class="headerlink" title="2.5 DoS拒绝服务攻击"></a>2.5 DoS拒绝服务攻击</h2><p>答：DoS(denial-of-service attack)拒绝服务攻击，亦称洪水攻击。目的是<code>使目标电脑的网络或系统资源耗尽，迫使服务中断停止，导致用户无法访问</code>。<br>DDos(distributed denial-of-service attack)分布式拒绝服务攻击，指<code>攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动Dos</code>。</p><h3 id="2-5-1-分类"><a href="#2-5-1-分类" class="headerlink" title="2.5.1 分类"></a>2.5.1 分类</h3><ul><li>SYN Flood。<strong>利用TCP协议缺陷，发送大量半连接请求</strong>，从而耗尽资源。(半连接指客户端掉线，服务器在一段时间内维护未完成的连接)</li><li>CC 攻击。应用层攻击手段。<strong>模拟多个正常用户不停地访问需要大量数据操作的页面</strong>，造成服务器资源浪费。</li></ul><h3 id="2-5-2-防御"><a href="#2-5-2-防御" class="headerlink" title="2.5.2 防御"></a>2.5.2 防御</h3><p>答：无法根治。</p><ul><li>关闭不必要的服务，仅保留重要端口。 </li><li>缩短SYN 半连接的 Timeout 时间。</li><li>设置半连接的最大数目。</li><li>短时间连续收到某个IP的重复SYN将此地址拉黑。</li><li>防火墙设置。</li><li>严格监控对外开放的服务器的对外访问。</li></ul><h2 id="2-6-检测连接安全性"><a href="#2-6-检测连接安全性" class="headerlink" title="2.6 检测连接安全性"></a>2.6 检测连接安全性</h2><ol><li>验证码。简单有效。点触、滑动、第三方。</li><li>频率。限制单IP、单设备的请求次数。</li><li>归属地。手机号和常用IP所在地匹配。</li><li>可疑用户。短信/邮件验证码验证身份。</li><li>黑名单。已在黑名单用户，返回接口默认值。</li><li>签名/加密。</li><li>Token。</li><li>https。</li><li>风控。</li><li>数据安全。提高攻击者的攻击成本。</li><li>第三方的IP鉴定库。</li></ol><p>图片来源：<a href="https://blog.nowcoder.net/n/a3776d83a8014f618dc50e78bcc95b53" target="_blank" rel="noopener">https://blog.nowcoder.net/n/a3776d83a8014f618dc50e78bcc95b53</a></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>认证授权</tag>
      
      <tag>网络攻击</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础</title>
    <link href="/2020/05/08/Linux%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/05/08/Linux%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>Linux的基本概念，文件系统，进程状态和常用命令。</p><a id="more"></a><h1 id="1-基础操作和概念"><a href="#1-基础操作和概念" class="headerlink" title="1. 基础操作和概念"></a>1. 基础操作和概念</h1><h2 id="1-1-快捷键"><a href="#1-1-快捷键" class="headerlink" title="1.1 快捷键"></a>1.1 快捷键</h2><ul><li>Tab：补全。</li><li>Ctrl + C：中断。</li><li>Ctrl + D：结束键盘输入。</li></ul><h2 id="1-2-关机"><a href="#1-2-关机" class="headerlink" title="1.2 关机"></a>1.2 关机</h2><ul><li>who：查看当前在线用户；</li><li>sync：同步操作，将内存文件同步磁盘；</li><li>shutdown -h now：立即关机。 </li></ul><h2 id="1-3-路径"><a href="#1-3-路径" class="headerlink" title="1.3 路径"></a>1.3 路径</h2><ul><li>路径间用 <code>:</code>分割；</li><li>sudo：允许一般用户使用 root 命令。</li></ul><h2 id="1-4-包管理工具"><a href="#1-4-包管理工具" class="headerlink" title="1.4 包管理工具"></a>1.4 包管理工具</h2><ul><li>RPM：Red Hat =&gt; CentOS</li><li>DPKG：Ubuntu =&gt; Debian</li></ul><h2 id="1-5-vim"><a href="#1-5-vim" class="headerlink" title="1.5 vim"></a>1.5 vim</h2><p>分为三个模式。</p><ul><li>vim进入的默认模式是 一般指令模式Command mode，可以进行剪切粘贴，游标移动；</li><li>i,I,a,A,o,O 进入编辑模式，esc退出；</li><li>: 进入指令列模式，用于保存退出。</li></ul><p>指令列模式的操作又有：</p><ul><li>:w：写入磁盘；</li><li>:q：离开；</li><li>:wq：写入磁盘后离开；</li><li>加上!就是强制操作。</li></ul><h1 id="2-文件系统"><a href="#2-文件系统" class="headerlink" title="2. 文件系统"></a>2. 文件系统</h1><p>Linux哲学：一切都是文件。</p><h2 id="2-1-组成"><a href="#2-1-组成" class="headerlink" title="2.1 组成"></a>2.1 组成</h2><p>答：主要包括：</p><ul><li>inode：一个文件占用一个inode，记录文件属性和文件内容的block编号。</li><li>block：记录文件内容。</li><li>superblock：记录文件系统的整体信息。包括inode、block的总量、使用量、剩余量等。</li><li>block bitmap：记录block是否被使用的位图。</li></ul><p><img src="/img/os/Linux%E6%96%87%E4%BB%B6.png" srcset="/img/loading.gif" alt="Linux文件"></p><h3 id="2-1-1-block"><a href="#2-1-1-block" class="headerlink" title="2.1.1 block"></a>2.1.1 block</h3><p>答：一个block只能被一个文件使用，未使用的部分就是被浪费了。可以理解为内存块。</p><p>Ext2文件系统支持1K、2K、4K三种大小，分别限制了单个文件和文件系统的大小。</p><h3 id="2-1-2-inode"><a href="#2-1-2-inode" class="headerlink" title="2.1.2 inode"></a>2.1.2 inode</h3><p>答：inode的特点有：</p><ul><li>每个inode均是128bytes。</li><li>一个文件有且仅占用一个inode。</li><li>inode内的block编号使用间接引用。让引用的block块记录block信息。</li></ul><h2 id="2-2-文件类型"><a href="#2-2-文件类型" class="headerlink" title="2.2 文件类型"></a>2.2 文件类型</h2><p><img src="/img/os/%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B.png" srcset="/img/loading.gif" alt="文件类型"></p><h2 id="2-3-文件读取"><a href="#2-3-文件读取" class="headerlink" title="2.3 文件读取"></a>2.3 文件读取</h2><p>答：根据文件系统不同，读取方式也不同。</p><ul><li>Ext2：先读inode中内容所在的所有block，再读取block内容。</li><li>FAT：没有inode，block存着下一个block的编号。</li></ul><h2 id="2-4-文件属性"><a href="#2-4-文件属性" class="headerlink" title="2.4 文件属性"></a>2.4 文件属性</h2><p>答：</p><ul><li>用户分为：文件所有者、所在群组、其他用户。</li><li>文件分为：d目录、-文件、|链接文件。</li><li>权限分为：r可读、w可写、x可执行。转为数字即421。</li><li>文件时间：内容更新、状态更新、读取更新。</li><li>文件的默认权限是 666，目录的默认权限是777。</li></ul><h2 id="2-5-目录结构"><a href="#2-5-目录结构" class="headerlink" title="2.5 目录结构"></a>2.5 目录结构</h2><p><img src="/img/os/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" alt="Linux目录结构"></p><ul><li>/root：根目录；</li><li>/bin：存放二进制文件，存储着命令；</li><li>/etc：存放系统管理和配置文件；</li><li>/home：存放用户文件的根目录；</li><li>/usr：默认存放系统应用程序；</li><li>/var：存放运行过程中的产生的数据文件。</li></ul><h2 id="2-6-挂载目录日志"><a href="#2-6-挂载目录日志" class="headerlink" title="2.6 挂载目录日志"></a>2.6 挂载目录日志</h2><ul><li>挂载：用目录作为文件系统的进入点，即进入该目录相当于进入系统能进行数据读取。</li><li>目录：分配一个inode和若干block，block记录目录下所有文件的inode编号和文件名。</li><li>日志：用来修复文件系统，回滚操作。</li></ul><h2 id="2-7-链接"><a href="#2-7-链接" class="headerlink" title="2.7 链接"></a>2.7 链接</h2><ol><li>实体链接：在目录下创建一个条目，记录源文件inode编号和文件名。</li><li>符号链接：保存源文件的绝对路径。理解为windows的快捷方式。</li></ol><h1 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3.进程管理"></a>3.进程管理</h1><h2 id="3-1-进程状态"><a href="#3-1-进程状态" class="headerlink" title="3.1 进程状态"></a>3.1 进程状态</h2><p>和os中的进程状态相似。</p><ul><li>R：正在执行或者可执行，位于执行队列中。</li><li>D：不可中断阻塞，通常为 IO 阻塞。</li><li>S：可中断阻塞，进程正在等待某个事件完成。</li><li>Z：僵死，进程已经终止但是尚未被其父进程获取信息。</li><li>T：结束。</li></ul><h2 id="3-2-SIGCHLD"><a href="#3-2-SIGCHLD" class="headerlink" title="3.2 SIGCHLD"></a>3.2 SIGCHLD</h2><p>答：当一个子进程改变状态，父进程会发生两件事。</p><ul><li>得到SIGCHLD信号。包含子进程的信息，如ID、状态等。</li><li>wait()调用销毁子进程并返回。父进程通过wait()获得退出子进程的信息。成功就返回子进程id，失败返回-1。</li></ul><h2 id="3-3-孤儿进程"><a href="#3-3-孤儿进程" class="headerlink" title="3.3 孤儿进程"></a>3.3 孤儿进程</h2><p>答：父进程退出，但子进程还在运行，这些子进程就是孤儿进程。孤儿进程会被 init 进程收养和处理。</p><h2 id="3-4-僵尸进程"><a href="#3-4-僵尸进程" class="headerlink" title="3.4 僵尸进程"></a>3.4 僵尸进程</h2><p>答：子进程退出后，父进程没有调用wait()释放进程描述符，使得子进程描述符一直保存在系统中，这就是僵尸进程。</p><ul><li>危害：进程号是有限的，僵尸进程占据大量进程号。</li><li>解决方法：杀死父进程，让僵尸进程变成孤儿进程。</li></ul><h1 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4.常用命令"></a>4.常用命令</h1><h2 id="4-1-文件和目录命令"><a href="#4-1-文件和目录命令" class="headerlink" title="4.1 文件和目录命令"></a>4.1 文件和目录命令</h2><ol><li>cd</li></ol><pre><code class="hljs shell">cd xxx：切换到该目录下的xxx目录；cd ..：切换到上一层目录；cd /：切换到根目录；cd ~：切换到用户主目录；cd -：切换到上一个操作所在的目录。</code></pre><ol start="2"><li>ls 列出文件或目录信息。通常用 ll</li><li>mkdir 创建目录。</li><li>rmdir 删除目录，必须为空。</li><li>touch 建立文件/更新文件时间。</li><li>cp 复制文件</li></ol><pre><code class="hljs shell">cp -r source destination</code></pre><ol start="7"><li>rm 删除文件</li></ol><pre><code class="hljs powershell">rm <span class="hljs-literal">-rf</span>：删库跑路</code></pre><ol start="8"><li>mv 移动文件<pre><code class="hljs shell">mv -f source destination 强制移动</code></pre></li></ol><h2 id="4-2-修改权限"><a href="#4-2-修改权限" class="headerlink" title="4.2 修改权限"></a>4.2 修改权限</h2><p>chmod [ugoa] [+-=] [rwx]</p><pre><code class="hljs shell">chmod u=rwx,g=rw,o=r aaa.txtchmod 764 aaa.txtchmod a+w .bashrc</code></pre><p>修改aaa.txt的权限为：用户拥有全部权限，用户组有读写权限，其他用户只有读权限。也可以用数字表示。</p><h2 id="4-3-获取文件内容"><a href="#4-3-获取文件内容" class="headerlink" title="4.3 获取文件内容"></a>4.3 获取文件内容</h2><ul><li>cat：取得文件内容；</li><li>tac：cat的反向操作，从最后一行获取文件内容；</li><li>more：一页一页查看文件内容，q退出，回车下一行，空格下一页；</li><li>less：PgUp和PgDn翻页；</li><li>head -x：查看前x行；</li><li>tail -x：查看后x行，Ctrl+C结束；</li></ul><h2 id="4-4-压缩命令"><a href="#4-4-压缩命令" class="headerlink" title="4.4 压缩命令"></a>4.4 压缩命令</h2><ol><li>压缩指令<br>压缩指令只对单个文件进行压缩。</li></ol><ul><li>gzip 使用最多<pre><code class="hljs shell">gzip [-cdtv#] filename -c：将压缩数据输出到屏幕； -d：压缩； -t：校验压缩文件； -v：显示压缩比信息；<span class="hljs-meta"> -#</span><span class="bash">：压缩等级，默认6，越大越高。</span></code></pre></li><li>bzip2 更高的压缩比</li><li>xz 更加高的压缩比</li></ul><ol start="2"><li>打包<br>打包能将多个文件打包成一个大文件，且将打包和压缩合在一起进行。</li></ol><pre><code class="hljs shell">//打包压缩tar [-z|-j|-J] [cv] -f filename -z：使用gzip； -j：使用bzip2； -J：使用xz； -c：新建打包文件； -v：在过程中，显示处理的文件名； -f：要处理的文件； //查看tar [-z|-j|-J] [tv] -f filename -t：查看打包文件中的内容；//解压缩tar [-z|-j|-J] [xv] -f filename -C -x：解压缩； -C：在目标目录解压缩。</code></pre><h2 id="4-5-指令搜索和文件搜索"><a href="#4-5-指令搜索和文件搜索" class="headerlink" title="4.5 指令搜索和文件搜索"></a>4.5 指令搜索和文件搜索</h2><ol><li>which -a 指令搜索</li><li>whereis filename 文件搜索</li><li>locate keyword 根据关键字或正则表达式搜索文件</li><li>find 根据属性和权限进行文件搜索</li></ol><h2 id="4-6-管道指令"><a href="#4-6-管道指令" class="headerlink" title="4.6 管道指令"></a>4.6 管道指令</h2><ol><li>管道是将一个命令的输出作为另一个命令的输入。使用 | 作为分隔。</li><li>cut 切分数据，取出想要的部分。<pre><code class="hljs shell">last | cut -d ' ' -f 1 -c 12- -d：分隔符； -f：分隔后，使用 `-f n` 取出第 n 个区间； -c：以字符为单位取区间。`-c 12-` 取出第12字符后的字符串。</code></pre></li><li>sort 排序<pre><code class="hljs shell">-f ：忽略大小写-b ：忽略最前面的空格-M ：以月份的名字来排序，例如 JAN，DEC-n ：使用数字-r ：反向排序-u ：相当于 unique，重复的内容只出现一次-t ：分隔符，默认为 tab-k ：指定排序的区间</code></pre></li><li>字符转化指令<ul><li>tr 删除行中字符 / 替换字符</li><li>join 合并有相同数据的行</li><li>paste 直接粘贴两行</li></ul></li><li>split 将一个文件划分为多个文件<pre><code class="hljs shell">split [-bl] file PREFIX-b ：以大小来进行分区，可加单位，例如 b, k, m 等；-l ：以行数来进行分区；-PREFIX ：分区文件的前缀名称。</code></pre></li></ol><h2 id="4-7-正则表达式"><a href="#4-7-正则表达式" class="headerlink" title="4.7 正则表达式"></a>4.7 正则表达式</h2><ol><li>grep 全局查找<pre><code class="hljs shell">grep [-acinv] [--color=auto] 搜寻字符串 filename -c ： 统计匹配到行的个数 -i ： 忽略大小写 -n ： 输出行号 -v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行 --color=auto ：找到的关键字加颜色显示</code></pre></li><li>printf 格式化输出，传数据时用 $()，不属于管道命令。</li><li>awk 逐行读文件，进行切片，对每部分进行分析处理。<pre><code class="hljs shell">awk '&#123;pattern + action&#125;' &#123;filenames&#125;</code></pre></li></ol><h2 id="4-8-进程管理"><a href="#4-8-进程管理" class="headerlink" title="4.8 进程管理"></a>4.8 进程管理</h2><ol><li>ps 查看进程信息<pre><code class="hljs shell">-l：查看自己进程aux：查看系统所有进程</code></pre></li><li>pstree 查看进程树</li><li>top 实时显示进程信息</li><li>netstat 查看占用端口的进程</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发</title>
    <link href="/2020/05/05/Java%E5%B9%B6%E5%8F%91/"/>
    <url>/2020/05/05/Java%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>详细介绍线程和进程的区别，创建线程的方法，线程的生命周期，调度方法，故障类型，synchronized，volatile关键字，ReentrantLock类，ThreadLocal，AQS的并发组件，线程池相关，原子类。</p><p>参考：《Java并发编程之美》，<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md" target="_blank" rel="noopener">CyC2018_Java并发</a>，阿里巴巴Java开发手册。</p><a id="more"></a><h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><h2 id="1-1-优缺点"><a href="#1-1-优缺点" class="headerlink" title="1.1 优缺点"></a>1.1 优缺点</h2><p>优点：</p><ul><li>充分利用多核CPU性能，提高运行速度；</li><li>拆分业务，提高系统处理能力。</li></ul><p>缺点：</p><ul><li>引发的一系列问题，如内存泄漏，上下文切换，线程安全，死锁等等。</li></ul><h2 id="1-2-三要素"><a href="#1-2-三要素" class="headerlink" title="1.2 三要素"></a>1.2 三要素</h2><p>答：原子性、可见性、有序性，也是线程安全的体现。</p><ul><li>原子性：一组操作要么都执行，要么都不执行。(针对共享变量)</li><li>可见性：一个线程对共享变量的修改，另一个线程是可见的。</li><li>有序性：程序执行的顺序按代码先后顺序执行。</li></ul><h2 id="1-3-线程安全"><a href="#1-3-线程安全" class="headerlink" title="1.3 线程安全"></a>1.3 线程安全</h2><p>问题：</p><ul><li>线程切换-&gt;原子性</li><li>缓存-&gt;可见性</li><li>编译优化-&gt;有序性</li></ul><p>解决方案：</p><ul><li>Atomic原子类，synchronized，Lock-&gt;原子性</li><li>synchronized，volatile，Lock-&gt;可见性</li><li>Happens-Before-&gt;有序性</li></ul><h2 id="1-4-并发和并行"><a href="#1-4-并发和并行" class="headerlink" title="1.4 并发和并行"></a>1.4 并发和并行</h2><p>答：并发指同一时间段，多个任务按时间片轮转执行。并行指单位时间内，多个任务被多个处理器同时执行。</p><p>eg. 8-9点，我洗脸刷牙吃饭-&gt;并发，我左手洗脸右手刷牙-&gt;并行。</p><h2 id="1-5-多线程"><a href="#1-5-多线程" class="headerlink" title="1.5 多线程"></a>1.5 多线程</h2><p>答：多线程是指一个进程，并发执行多个线程，每个线程有自己的功能处理不同的任务。</p><p>优势：</p><ul><li>使用<strong>CPU轮询时间片</strong>模式，提高资源利用率。</li></ul><p>劣势：</p><ul><li>线程也需要占用内存，线程越大占用内存越大；</li><li>降低程序执行速度，因为存在线程上下文切换；</li><li>对共享资源的访问，带来线程死锁等安全问题。</li></ul><h1 id="2-进程、线程和协程"><a href="#2-进程、线程和协程" class="headerlink" title="2. 进程、线程和协程"></a>2. 进程、线程和协程</h1><h2 id="2-1-区别"><a href="#2-1-区别" class="headerlink" title="2.1 区别"></a>2.1 区别</h2><table><thead><tr><th></th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>根本区别</td><td>进程是资源分配的基本单位</td><td>线程是CPU调度执行的最小允许单位</td></tr><tr><td>资源开销</td><td>进程切换要保存当前CPU环境和建立新的CPU环境</td><td>线程切换只需要保存虚拟机栈和程序计数器</td></tr><tr><td>包含关系</td><td>一个进程可以有多个线程</td><td>线程是进程的一部分</td></tr><tr><td>内存分配</td><td>进程间的资源和地址相互独立</td><td>同一进程的线程共享本进程的资源和地址</td></tr><tr><td>执行过程</td><td>每个进程都是独立运行</td><td>线程必须依赖应用程序</td></tr><tr><td>影响关系</td><td>一个进程崩溃不会影响其他进程</td><td>一个线程崩溃容易整个进程挂掉</td></tr><tr><td>系统资源</td><td>进程拥有堆和方法区/元空间</td><td>线程一般没有系统资源，但有必不可少的ThreadLocal</td></tr></tbody></table><p><strong>协程</strong>是用户态执行的轻量级线程(在一个线程执行)，调度都由用户控制，可以随时中断执行别的子程序再返回接着执行。项目中，协程去读取或者写入本地的文件，这样就是串行。</p><h2 id="2-2-守护线程和用户线程"><a href="#2-2-守护线程和用户线程" class="headerlink" title="2.2 守护线程和用户线程"></a>2.2 守护线程和用户线程</h2><ul><li>守护线程：运行在后台，为前台线程服务。如GC线程。</li><li>用户线程：运行在前台，执行具体的任务。如main()。</li></ul><h2 id="2-3-进程通信方式"><a href="#2-3-进程通信方式" class="headerlink" title="2.3 进程通信方式"></a>2.3 进程通信方式</h2><ol><li><strong>管道 Pipes</strong>：只能用于父子进程或兄弟进程间的通信；</li><li><strong>有名管道 Name Pipes</strong>：遵循FIFO，能实现任意两个进程通信；</li><li><strong>信号 Signal</strong>：通知接收进程某个事件已发生；</li><li><strong>消息队列 Message Queuing</strong>：遵循FIFO，存放内核中，能实现消息的随机查询。克服了信号承载信息少，管道只能承载无格式字节流和缓冲区大小受限问题。</li><li><strong>信号量 Semaphores</strong>：就是计数器，解决进程间同步竞争，用于多进程的共享资源访问。</li><li><strong>共享内存 Shared Memory</strong>：使多进程可以同时访问同一块内存空间，不同进程能看到其他进程对共享资源的操作。</li><li><strong>套接字 Socket</strong>：用于客户端和服务器间的网络通信，看成不同主机的进程间的双向通信。</li></ol><h1 id="3-创建线程的方法"><a href="#3-创建线程的方法" class="headerlink" title="3. 创建线程的方法"></a>3. 创建线程的方法</h1><p>答：java中有四种方法实现线程。实现Runnable接口，实现Callable接口，继承Thread类，Executor创建线程池。</p><p>建议采用实现接口的方式，因为继承整个Thread类开销过大且Java不支持多重继承，但支持多接口继承。</p><p>实现接口的类就像是线程中运行的任务，最终还是要通过Thread调用。</p><h2 id="3-1-实现Runnable接口"><a href="#3-1-实现Runnable接口" class="headerlink" title="3.1 实现Runnable接口"></a>3.1 实现Runnable接口</h2><p>继承Runnable接口，<strong>实现run方法，通过Thread调用start()启动线程，无返回值，无法捕获异常处理。</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    MyRunnable instance = <span class="hljs-keyword">new</span> MyRunnable();    Thread thread = <span class="hljs-keyword">new</span> Thread(instance);    thread.start();&#125;</code></pre><h2 id="3-2-实现Callable接口"><a href="#3-2-实现Callable接口" class="headerlink" title="3.2 实现Callable接口"></a>3.2 实现Callable接口</h2><p><strong>以Callable做参数创建FutureTask类，通过Thread调用start()启动线程，有返回值(被Future获取)，能捕获异常处理。</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;    MyCallable mc = <span class="hljs-keyword">new</span> MyCallable();    FutureTask&lt;Integer&gt; ft = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(mc);    Thread thread = <span class="hljs-keyword">new</span> Thread(ft);    thread.start();    System.out.println(ft.get());&#125;</code></pre><h2 id="3-3-继承Thread类"><a href="#3-3-继承Thread类" class="headerlink" title="3.3 继承Thread类"></a>3.3 继承Thread类</h2><p>通过start()启动，因为Thread类也是实现Runnable接口，所以需要重写run()。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    MyThread mt = <span class="hljs-keyword">new</span> MyThread();    mt.start();&#125;</code></pre><h2 id="3-4-线程池"><a href="#3-4-线程池" class="headerlink" title="3.4 线程池"></a>3.4 线程池</h2><p>Executors提供方法，实现ExecutorService接口。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ExecutorService executorService = Executors.newSingleThreadExecutor();    MyRunnable runnableTest = <span class="hljs-keyword">new</span> MyRunnable();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;        executorService.execute(runnableTest);    &#125;    executorService.shutdown();&#125;</code></pre><h2 id="3-5-run-和start"><a href="#3-5-run-和start" class="headerlink" title="3.5 run()和start()"></a>3.5 run()和start()</h2><ul><li>start()用于启动线程让线程进入就绪状态，只能调用一次，会自动执行run()；</li><li>run()用于执行线程内部代码，类似main()下的普通方法，可重复调用，依赖于线程start()。</li></ul><h1 id="4-线程的生命周期和调度"><a href="#4-线程的生命周期和调度" class="headerlink" title="4. 线程的生命周期和调度"></a>4. 线程的生命周期和调度</h1><h2 id="4-1-生命周期状态"><a href="#4-1-生命周期状态" class="headerlink" title="4.1 生命周期状态"></a>4.1 生命周期状态</h2><p>答：线程状态包括 新建、运行、阻塞等待和消亡。阻塞等待分为Blocked、Waiting和Time Waiting。<br><img src="/img/java/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" srcset="/img/loading.gif" alt="线程生命周期"></p><p>(图源：CyC2018)</p><p>参照源码中Thread的Enum定义。</p><ul><li>New新建：创建后尚未调用start方法</li><li>Runnable可运行：就绪状态，可能是正在运行或者正在等待CPU资源</li><li>Blocked阻塞：线程进入同步块中，需要申请一个同步锁而进行的等待</li><li>Waiting无限期等待：调用了Object.wait()或Object.notify()或LockSupport.park()方法，无限期等待其他线程来唤醒</li><li>Time Waiting有限期等待：调用Thread.sleep(x)等方法，区别是等待时间是明确的</li><li>Terminated消亡：线程执行结束或产生异常提前结束</li></ul><h2 id="4-2-线程调度"><a href="#4-2-线程调度" class="headerlink" title="4.2 线程调度"></a>4.2 线程调度</h2><h3 id="4-2-1-调度模型"><a href="#4-2-1-调度模型" class="headerlink" title="4.2.1 调度模型"></a>4.2.1 调度模型</h3><p>答：两种模型。</p><ul><li>分时调度：让所有线程轮流获得CPU使用权，平均分配时间片。</li><li>抢占式调度：让优先级高的线程抢占CPU，直到有更高优先级线程进入或线程任务运行。JVM默认。</li></ul><h3 id="4-2-2-相关方法"><a href="#4-2-2-相关方法" class="headerlink" title="4.2.2 相关方法"></a>4.2.2 相关方法</h3><ul><li>sleep()：Thread类的方法，让线程进入有限期等待休眠，之后<strong>自动苏醒</strong>。休眠<strong>不释放锁</strong>。常用于<strong>暂停执行</strong>。</li><li>wait()：Object类的方法，与synchronized一起使用，线程进入有限期或无限期等待，被notify方法调用才能解除阻塞，只有重新占用互斥锁才能进入Runnable。休眠<strong>释放互斥锁</strong>。常用于<strong>线程间通信交互</strong>。wait(long timeout)超时后也会自动苏醒。</li><li>join()：当前线程调用，其他线程全部停止，等待当前线程执行结束再执行。<strong>Stop the world</strong></li><li>yield()：让线程<strong>放弃当前获得的CPU</strong>，使线程仍处于Runnable，随时可以再获得CPU。只给相同优先级或更高优先级的线程机会。</li><li>notify()：唤醒一个线程。</li><li>notifyAll()：唤醒所有线程，参与锁竞争，失败就留在池中等待下次唤醒。</li></ul><h3 id="4-2-3-停止运行线程方法"><a href="#4-2-3-停止运行线程方法" class="headerlink" title="4.2.3 停止运行线程方法"></a>4.2.3 停止运行线程方法</h3><ul><li>退出标志，让线程正常退出；</li><li>stop()/suspend()强制终止；</li><li>interrupt()中断线程，但仅是把逻辑状态设置为中断，不会停止线程，需要后续处理。</li></ul><h3 id="4-2-4-interrupte-，interrupted-和isInterrupted"><a href="#4-2-4-interrupte-，interrupted-和isInterrupted" class="headerlink" title="4.2.4 interrupte()，interrupted()和isInterrupted()"></a>4.2.4 interrupte()，interrupted()和isInterrupted()</h3><ul><li>interrupt()：中断线程。调用该方法后，线程状态被置为中断，不会停止线程，抛出中断异常。</li><li>interrupted()：静态方法，检查当前中断状态，并清除中断状态。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。</li><li>isInterrupted()：查看当前线程的中断状态，不清除状态。</li></ul><h3 id="4-2-5-线程共享数据"><a href="#4-2-5-线程共享数据" class="headerlink" title="4.2.5 线程共享数据"></a>4.2.5 线程共享数据</h3><ul><li>临界区：单进程的多线程同步。用户态。</li><li>互斥量：单进程和多进程的多线程访问同步。内核态。</li><li>事件：多进程的多线程间触发事件实现同步。内核态。</li><li>信号量：多个线程同时访问公共区域数据。内核态。</li></ul><h3 id="4-2-6-线程同步方式"><a href="#4-2-6-线程同步方式" class="headerlink" title="4.2.6 线程同步方式"></a>4.2.6 线程同步方式</h3><p>答：总共7种。</p><ol><li>同步方法。用synchronized修饰的方法。</li><li>同步代码块。用synchronized修饰的语句块。</li><li>用volatile修饰变量。</li><li>可重入锁。</li><li>ThreadLocal管理变量副本。</li><li>阻塞队列。</li><li>原子类。</li></ol><h3 id="4-2-7-线程类的构造方法、静态块是被哪个线程调用的"><a href="#4-2-7-线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="4.2.7 线程类的构造方法、静态块是被哪个线程调用的"></a>4.2.7 线程类的构造方法、静态块是被哪个线程调用的</h3><p>答：线程类的构造方法、静态块是被new这个线程类所在的线程所调用，run()里的代码才是被线程自身所调用的。</p><p>eg.Thread2 中 new 了Thread1，main 函数中 new 了 Thread2，那么：</p><ul><li>Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()方法是Thread2 自己调用的；</li><li>Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法是Thread1 自己调用的。</li></ul><h1 id="5-线程故障"><a href="#5-线程故障" class="headerlink" title="5. 线程故障"></a>5. 线程故障</h1><h2 id="5-1-线程死锁"><a href="#5-1-线程死锁" class="headerlink" title="5.1 线程死锁"></a>5.1 线程死锁</h2><p>答：定义为多个线程之间相互请求对方占用的资源而被无限期阻塞。</p><h3 id="5-1-1-四个必要条件"><a href="#5-1-1-四个必要条件" class="headerlink" title="5.1.1 四个必要条件"></a>5.1.1 四个必要条件</h3><p>答：OS的基础知识：</p><ul><li>资源互斥：一个资源任意时刻只能被一个线程使用；</li><li>请求和保持：一个线程因请求资源而阻塞时，对已获得的资源保持不放；</li><li>不剥夺：线程已获得的资源，再未使用完之前，不能强行剥夺；</li><li>循环等待：若干线程间形成头尾相接的循环等待资源状态。</li></ul><h3 id="5-1-2-避免死锁的方法"><a href="#5-1-2-避免死锁的方法" class="headerlink" title="5.1.2 避免死锁的方法"></a>5.1.2 避免死锁的方法</h3><p>答：破坏死锁产生的四个条件中的任一，常用算法是银行家算法。</p><ul><li>破坏资源互斥：做不到；</li><li>破坏请求和保持：<strong>一次性申请全部资源</strong>；</li><li>破坏不剥夺：占用部分资源的线程再申请其他资源时，若申请不到就<strong>主动释放其占有的资源</strong>；</li><li>破环循环等待：<strong>锁排序法</strong>，指定获取锁的顺序(也可认为指定获取资源的顺序)，比如：只有获得A锁的线程才能获得B锁，只有AB锁都获得的才能操作资源C。。</li></ul><h3 id="5-1-3-死锁代码"><a href="#5-1-3-死锁代码" class="headerlink" title="5.1.3 死锁代码"></a>5.1.3 死锁代码</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockDemo</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object resource1 = <span class="hljs-keyword">new</span> Object();<span class="hljs-comment">//资源 1</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object resource2 = <span class="hljs-keyword">new</span> Object();<span class="hljs-comment">//资源 2</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">synchronized</span> (resource1) &#123;                System.out.println(Thread.currentThread() + <span class="hljs-string">"get resource1"</span>);                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">1000</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(Thread.currentThread() + <span class="hljs-string">"waiting get resource2"</span>);                <span class="hljs-keyword">synchronized</span> (resource2) &#123;                    System.out.println(Thread.currentThread() + <span class="hljs-string">"get resource2"</span>);                &#125;            &#125;        &#125;, <span class="hljs-string">"线程 1"</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">synchronized</span> (resource2) &#123;                System.out.println(Thread.currentThread() + <span class="hljs-string">"get resource2"</span>);                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">1000</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(Thread.currentThread() + <span class="hljs-string">"waiting get resource1"</span>);                <span class="hljs-keyword">synchronized</span> (resource1) &#123;                    System.out.println(Thread.currentThread() + <span class="hljs-string">"get resource1"</span>);                &#125;            &#125;        &#125;, <span class="hljs-string">"线程 2"</span>).start();    &#125;&#125;</code></pre><h2 id="5-2-线程锁死"><a href="#5-2-线程锁死" class="headerlink" title="5.2 线程锁死"></a>5.2 线程锁死</h2><p>答：等待线程由于唤醒条件无法成立或其他线程无法唤醒这个线程，而一直处于非运行状态。</p><h3 id="5-2-1-分类"><a href="#5-2-1-分类" class="headerlink" title="5.2.1 分类"></a>5.2.1 分类</h3><ul><li>信号丢失锁死：没有对应的线程来唤醒等待线程，导致一直等待。</li><li>嵌套监视器锁死：由于嵌套锁导致等待线程永远无法被唤醒的故障。比如，线程只释放了内层锁Y.wait()，没有释放外层锁X；但通知线程必须获得外层锁X，才能通过Y.notify()唤醒，这就出现嵌套等待现象。</li></ul><h2 id="5-3-线程活锁"><a href="#5-3-线程活锁" class="headerlink" title="5.3 线程活锁"></a>5.3 线程活锁</h2><p>答：线程一直处于运行状态，但其执行的任务没有任何进展。比如，线程一直在请求其需要的资源，但无法申请成功。(占着茅坑不拉屎)</p><h2 id="5-4-线程饥饿"><a href="#5-4-线程饥饿" class="headerlink" title="5.4 线程饥饿"></a>5.4 线程饥饿</h2><p>答：线程一直无法获得其所需的资源致使任务无法运行的情况。</p><h2 id="5-5-活性故障间转换"><a href="#5-5-活性故障间转换" class="headerlink" title="5.5 活性故障间转换"></a>5.5 活性故障间转换</h2><p>答：线程饥饿发生时，如果线程处于Runnable状态，就转变为活锁。线程死锁也是线程饥饿。</p><h1 id="6-并发理论"><a href="#6-并发理论" class="headerlink" title="6. 并发理论"></a>6. 并发理论</h1><h2 id="6-1-JVM"><a href="#6-1-JVM" class="headerlink" title="6.1 JVM"></a>6.1 JVM</h2><h3 id="6-1-1-GC"><a href="#6-1-1-GC" class="headerlink" title="6.1.1 GC"></a>6.1.1 GC</h3><p>答：GC是为了识别和丢弃不再使用的对象来释放资源。详细过程和相关见JVM部分。</p><h3 id="6-1-2-finalize"><a href="#6-1-2-finalize" class="headerlink" title="6.1.2 finalize()"></a>6.1.2 finalize()</h3><p>答：GC在回收某对象时，会调用该对象的finalize()，让对象处理生前的最后事情或者挣扎一下。</p><ul><li>自我挣扎。覆写了finalize()重新引用到GC root上。只能调用一次。但只保证被调用，不保证方法内任务执行。</li><li>做最后的资源回收。</li></ul><h2 id="6-2-重排序"><a href="#6-2-重排序" class="headerlink" title="6.2 重排序"></a>6.2 重排序</h2><p>答：执行程序时，为了最佳执行效率，处理器和编译器会对指令进行重排序。</p><ul><li>单线程下不会改变运行结果，但会破坏多线程的执行结果。</li><li>存在数据依赖关系的不允许重排序。</li></ul><h2 id="6-3-happens-before和as-if-serial"><a href="#6-3-happens-before和as-if-serial" class="headerlink" title="6.3 happens-before和as-if-serial"></a>6.3 happens-before和as-if-serial</h2><ul><li>都是为了在不改变执行结果的前提下，尽可能提高程序并行程度；</li><li>happens-before 保证一个操作的结果必然对另一个操作可见；</li><li>as-if-serial 保证单线程按指定顺序执行，即执行结果不能被改变。</li></ul><h2 id="6-4-JMM"><a href="#6-4-JMM" class="headerlink" title="6.4 JMM"></a>6.4 JMM</h2><p>JMM Java内存模型，规定：</p><ol><li>所有的共享变量存储在主内存中；</li><li>每个线程私有工作内存，对于变量的读写必须在本工作内存中完成；</li><li>线程间变量的传递，通过主内存中转。</li></ol><h1 id="7-关键字"><a href="#7-关键字" class="headerlink" title="7. 关键字"></a>7. 关键字</h1><h2 id="7-1-synchronized"><a href="#7-1-synchronized" class="headerlink" title="7.1 synchronized"></a>7.1 synchronized</h2><h3 id="7-1-1-理解"><a href="#7-1-1-理解" class="headerlink" title="7.1.1 理解"></a>7.1.1 理解</h3><p>答：synchronized是Java的一个关键字，用来控制线程同步，保证修饰的方法或代码块在任意时刻只有一个线程执行。在JDK1.6后进行了大量优化，引入了锁升级机制，减少了锁的开销。</p><p>synchronized可用来修饰实例方法(锁当前实例)、静态方法(锁当前类的class对象)和代码块(锁当前括号内对象)。</p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><ol><li>实例对象在堆中，分为对象头、实例变量和填充数据。</li><li>synchronized锁对象存储在对象头中，由Mark Word 和 Class Metadata Address组成。</li><li>Mark Word存储对象的hashCode、锁信息、分代年龄等。</li></ol><h3 id="7-1-2-底层原理"><a href="#7-1-2-底层原理" class="headerlink" title="7.1.2 底层原理"></a>7.1.2 底层原理</h3><p>答：分为修饰代码块和修饰方法。</p><p><strong>修饰代码块：</strong> 显式同步</p><ul><li>进入时，执行 monitorenter，将计数器+1，释放锁 monitorexit 时，计数器-1；</li><li>每条 enter 指令都有对应的 monitorexit，多出的一个 monitorexit 是为了异常时释放 monitor，避免死锁。</li><li>当一个线程判断到计数器为0时，则当前锁空闲，可以占用；反之，当前线程进入等待状态</li></ul><p><strong>修饰方法：</strong> 隐式同步<br>使用 ACC_SYNCHRONIZED 标识指明方法是一个同步方法，JVM从而执行相应的同步调用(和代码块类似的 monitor管程)</p><h3 id="7-1-3-锁优化"><a href="#7-1-3-锁优化" class="headerlink" title="7.1.3 锁优化"></a>7.1.3 锁优化</h3><p>锁优化主要是synchronized的优化。</p><p>Java早期版本中，monitor 依赖于os的 Mutex Lock互斥锁，每次调用都要切换用户态和核心态，效率低下。</p><ol><li><strong>自旋锁</strong>：让线程在请求一个共享数据锁时忙循环（自旋）一段时间，若这段时间内能获得锁，则避免进入阻塞状态。总结：<strong>请求锁时被占用先忙循环</strong></li><li><strong>锁粗化</strong>：JVM探测到一组操作都对同一个对象加锁，就会把加锁范围扩展到整个操作的外部（粗化），以避免频繁加锁引起性能损耗。</li><li><strong>偏向锁</strong>：主要思想是<strong>先来就是你的，对你不用同步，有竞争就释放锁</strong>。对象头有一个变量专门存储当前线程的id，之后再来线程与这个id比较，相同就不用再进行同步验证，不同就释放锁，锁升级为轻量锁。</li></ol><h3 id="7-1-4-锁升级"><a href="#7-1-4-锁升级" class="headerlink" title="7.1.4 锁升级"></a>7.1.4 锁升级</h3><p>答：目的是为了降低锁的性能消耗。具体流程是:</p><ol><li>最开始阶段时无锁状态。</li><li>第一次访问时，JVM设置为偏向锁，把threadid设置为当前线程id，再次进入时判断id是否一致；</li><li>不一致，升级为轻量锁，进入自旋；</li><li>自旋一定次数仍未获取资源，升级为重量锁。</li></ol><h3 id="7-1-5-等待唤醒机制"><a href="#7-1-5-等待唤醒机制" class="headerlink" title="7.1.5 等待唤醒机制"></a>7.1.5 等待唤醒机制</h3><p>答：notify,notifyAll和wait方法，必须拿到当前对象的monitor监视器对象，synchronized可以获取监视器，所以等待唤醒方法必须要synchronized的方法或代码块。</p><h2 id="7-2-Volatile"><a href="#7-2-Volatile" class="headerlink" title="7.2 Volatile"></a>7.2 Volatile</h2><h3 id="7-2-1-理解"><a href="#7-2-1-理解" class="headerlink" title="7.2.1 理解"></a>7.2.1 理解</h3><ol><li>Volatile的主要作用是<strong>保证变量的可见性和有序性，不能保证原子性</strong>。</li><li>可见性是通过，每次把修改后的值立即更新到主存，其他线程上的变量副本失效，需要再到主存读取。</li><li>有序性是通过在适当位置插入内存屏障实现。</li><li>当多个线程共享一组状态变量，可以替代锁。</li></ol><h3 id="7-2-2-可见性原理"><a href="#7-2-2-可见性原理" class="headerlink" title="7.2.2 可见性原理"></a>7.2.2 可见性原理</h3><ul><li>缓存一致性原理：CPU写数据时，若操作变量为共享变量，会通知其他CPU此变量的缓存置为无效，当其他CPU需要用时，再去内存重新读取。</li><li>嗅探：每个CPU通过嗅探在总线上的数据和自己的缓存比较，若发现缓存对应的内存地址被修改，就将缓存置为无效。</li><li>总线风暴：由于每个CPU需要不断地嗅探和CAS比较，容易占满整个带宽。</li></ul><h3 id="7-2-3-synchronized和volatile的区别"><a href="#7-2-3-synchronized和volatile的区别" class="headerlink" title="7.2.3 synchronized和volatile的区别"></a>7.2.3 synchronized和volatile的区别</h3><p>答：比较总结如下：</p><ul><li>volatile关键字是<strong>轻量级</strong>的锁，性能比synchronized好(1.6优化后不一定)；</li><li>volatile只能<strong>修饰变量</strong>，synchronized能修饰方法和代码块；</li><li>volatile保证数据<strong>可见性和有序性</strong>，不保证原子性；synchronized都保证。</li></ul><h3 id="7-2-4-内存屏障"><a href="#7-2-4-内存屏障" class="headerlink" title="7.2.4 内存屏障"></a>7.2.4 内存屏障</h3><p>答：JMM(Java内存模型)通过在适当位置插入内存屏障阻止重排序。</p><ol><li>volatile写：在前和后插入屏障(先禁上面普通写，再禁止下面可能的volatile读写)；</li><li>volatile读：在后插入两个屏障(禁止普通读写+volatile读)。</li></ol><ul><li>StoreStore屏障：禁止上面的普通写和下面的volatile写重排序；</li><li>StoreLoad屏障：禁止上面的volatile写和下面的volatile读/写重排序；</li><li>LoadLoad屏障：禁止上面的volatile读重排序和下面的普通读操作；</li><li>LoadStore屏障：禁止上面的volatile读重排序和下面的普通写操作。<br><img src="/img/java/volatile%E5%86%99.png" srcset="/img/loading.gif" alt="volatile写"><br><img src="/img/java/volatile%E8%AF%BB.png" srcset="/img/loading.gif" alt="volatile读"></li></ul><h3 id="7-2-5-不保证原子性"><a href="#7-2-5-不保证原子性" class="headerlink" title="7.2.5 不保证原子性"></a>7.2.5 不保证原子性</h3><p>答：Java对基本类型的赋值和读取是原子操作，如 i=1。但 i++ 不是原子操作，实际上其被拆成了3个指令，在将修改写回主内存时会产生覆盖，所以不能保证原子性。</p><p>解决方法：加锁，加synchronized，原子类。</p><h1 id="8-Lock"><a href="#8-Lock" class="headerlink" title="8. Lock"></a>8. Lock</h1><h2 id="8-1-Lock接口"><a href="#8-1-Lock接口" class="headerlink" title="8.1 Lock接口"></a>8.1 Lock接口</h2><p>答：总体上说Lock接口是synchronized的升级版，支持非公平和公平锁，提供了轮询、定时、中断、多条件的锁操作，更加灵活。</p><h2 id="8-2-ReentrantLock"><a href="#8-2-ReentrantLock" class="headerlink" title="8.2 ReentrantLock"></a>8.2 ReentrantLock</h2><p>答：ReentrantLock可重入锁是Lock接口的一个实现类。可重入锁就是自己可以再次获取自己的内部锁。同一线程每次获取锁，锁的计数器++，计数器为0时再释放锁。</p><h3 id="8-2-1-synchronized和ReentrantLock的区别"><a href="#8-2-1-synchronized和ReentrantLock的区别" class="headerlink" title="8.2.1 synchronized和ReentrantLock的区别"></a>8.2.1 synchronized和ReentrantLock的区别</h3><p>答：总结为：</p><ol><li>二者都是可重入锁。</li><li>synchronized是关键字依赖于JVM，ReentrantLock是类依赖于API接口。</li><li>synchronized修饰类和方法，ReentrantLock只适用代码块。</li><li>ReentrantLock比synchronized增加了一些高级功能。</li></ol><ul><li><strong>等待可中断</strong>。正在等待的线程可以选择放弃等待，执行其他任务。</li><li>ReentrantLock支持<strong>公平和非公平调度</strong>。synchronized只支持非公平锁。</li><li>支持<strong>选择性通知</strong>。synchronized相当于整个Lock只有一个Condition，所有线程都注册在一个上面，notifyAll()通知所有等待状态线程，效率不高。ReentrantLock的线程对象能注册在指定的Condition中，signalAll()只会唤醒该Condition实例中的等待线程。</li></ul><h3 id="8-2-2-ReentrantReadWriteLock"><a href="#8-2-2-ReentrantReadWriteLock" class="headerlink" title="8.2.2 ReentrantReadWriteLock"></a>8.2.2 ReentrantReadWriteLock</h3><p>答：ReentrantLock在多个线程读数据时也会重复加锁，降低性能，所以诞生了ReentrantReadWriteLock读写重入锁。</p><ul><li>ReentrantReadWriteLock实现了读写分离，读时共享，写时独占，读和读不会互斥。</li><li>实现锁降级。写-读-释放写-降级为读锁。</li></ul><h2 id="8-3-AQS"><a href="#8-3-AQS" class="headerlink" title="8.3 AQS"></a>8.3 AQS</h2><p>答：AQS(AbstractQueuedSynchronizer)是用来<strong>构建锁和同步器</strong>的框架。</p><h3 id="8-3-1-底层原理"><a href="#8-3-1-底层原理" class="headerlink" title="8.3.1 底层原理"></a>8.3.1 底层原理</h3><ol><li>若被请求的<strong>共享资源空闲</strong>，则将当前请求资源的线程设置为有效的工作线程，<strong>分配后将共享资源设为锁定状态</strong>。</li><li>若被请求的<strong>共享资源被占用</strong>，则需要一套线程阻塞等待和唤醒锁分配的机制，这个机制AQS通过CLH队列实现，即<strong>将暂时获取不到锁的线程封装为一个结点加入到队列中</strong>。</li><li>CLH队列是一个虚拟双向队列，仅存在结点间的关联。AQS就是把线程封装成队列的node。</li><li>内部使用volatile int变量的state标识同步状态，FIFO的排队策略，CAS实现值的修改。</li></ol><p><img src="/img/java/AQS.png" srcset="/img/loading.gif" alt="AQS"></p><h3 id="8-3-2-资源共享方式"><a href="#8-3-2-资源共享方式" class="headerlink" title="8.3.2 资源共享方式"></a>8.3.2 资源共享方式</h3><p>答：两种。</p><ol><li>Exclusive(独占)：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：</li></ol><ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul><ol start="2"><li>Share(共享)：多个线程可同时执行，如Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock等。</li></ol><h2 id="8-4-并发组件"><a href="#8-4-并发组件" class="headerlink" title="8.4 并发组件"></a>8.4 并发组件</h2><ol><li>Semaphore(信号量)：<strong>允许多个线程同时访问某个资源</strong>，通过参数可以设置访问数，synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源。</li><li>CountDownLatch：<strong>倒计时器，让线程倒计时为0再执行</strong>，用来实现线程等待其余线程完成某一特定操作后，再开始执行。<strong>内部维护一个计数器</strong>，为0则唤醒等待线程，不为0则暂停。</li><li>CyclicBarrier：<strong>循环栅栏，到地一拦，人齐再走</strong>。让线程到达同步点时被栅栏阻塞，直到最后一个线程到达栅栏，才让所有被拦截的线程继续执行。<strong>内部维护一个参与方个数的计数器</strong>，每个线程到达同步点调用await()方法使count-1，当判断到是最后一个参与方时，调用singalAll唤醒所有线程。</li></ol><h1 id="9-并发容器"><a href="#9-并发容器" class="headerlink" title="9. 并发容器"></a>9. 并发容器</h1><h2 id="9-1-ConcurrentHashMap"><a href="#9-1-ConcurrentHashMap" class="headerlink" title="9.1 ConcurrentHashMap"></a>9.1 ConcurrentHashMap</h2><p>详细见Java-三大集合。</p><p>1.8前用分段锁实现，1.8后用数组+链表+红黑树，synchronized和CAS控制并发。</p><h2 id="9-2-ThreadLocal"><a href="#9-2-ThreadLocal" class="headerlink" title="9.2 ThreadLocal"></a>9.2 ThreadLocal</h2><h3 id="9-2-1-理解"><a href="#9-2-1-理解" class="headerlink" title="9.2.1 理解"></a>9.2.1 理解</h3><p>答：ThreadLocal是<strong>为每个线程提供独立的变量本地副本</strong>，通过get/set方法独立获取/改变自己的副本值，避免线程安全问题。(理解为有100个学生给了100只笔，互不影响)</p><h3 id="9-2-2-底层原理"><a href="#9-2-2-底层原理" class="headerlink" title="9.2.2 底层原理"></a>9.2.2 底层原理</h3><p>答：每个线程内都有一个类HashMap的对象，称为<strong>ThreadLocalMap</strong>，存放以ThreadLocal为key的键值对，get/set/remove基于此实现。</p><h3 id="9-2-3-内存泄漏"><a href="#9-2-3-内存泄漏" class="headerlink" title="9.2.3 内存泄漏"></a>9.2.3 内存泄漏</h3><p>答：key是弱引用，value是强引用。gc时value不会被清理，长期不清除造成内存泄漏。</p><h3 id="9-2-4-解决方案"><a href="#9-2-4-解决方案" class="headerlink" title="9.2.4 解决方案"></a>9.2.4 解决方案</h3><ul><li>每次用完就remove()清除数据。</li><li>针对key为null的entry，先查有没有哈希冲突，没有就调用cleanSomeSlots检测脏数据；有就向后环形查找，过程中有脏数据就replaceStaleEntry。</li></ul><h3 id="9-2-5-key使用弱引用原因"><a href="#9-2-5-key使用弱引用原因" class="headerlink" title="9.2.5 key使用弱引用原因"></a>9.2.5 key使用弱引用原因</h3><p>答：反过来想。</p><ul><li>key是强引用，业务处理key置null，始终可达，JVM不会自动gc。</li><li>key是软引用，只能等到空间不足才gc，但有些线程比如守护线程是不会关闭的，所以等同不能gc。</li><li>总之，弱引用即使会出现内存泄漏问题，但在生命周期内只要保证对脏数据处理，就能保证安全。</li></ul><h2 id="9-3-BlockingQueue"><a href="#9-3-BlockingQueue" class="headerlink" title="9.3 BlockingQueue"></a>9.3 BlockingQueue</h2><p>答：BlockingQueue阻塞队列。</p><ul><li>当队列为空时，获取元素的线程等待队列非空；</li><li>当队列为满时，存储元素的线程等待队列可用。</li><li>常用于生产者-消费者模型，socket数据读取和解析。</li></ul><h1 id="10-线程池"><a href="#10-线程池" class="headerlink" title="10. 线程池"></a>10. 线程池</h1><h2 id="10-1-理解"><a href="#10-1-理解" class="headerlink" title="10.1 理解"></a>10.1 理解</h2><p>答：池化思想有利于降低资源消耗，节省创建资源的时间，提高线程的可管理性。线程池，顾名思义，提前创建若干线程放在池中，需要时直接获取不用创建，使用完毕放回池中。</p><h2 id="10-2-状态"><a href="#10-2-状态" class="headerlink" title="10.2 状态"></a>10.2 状态</h2><ul><li>Running：接收新任务，处理等待队列中的任务；</li><li>Shutdown：不接受新任务，处理等待队列中的任务；</li><li>Stop：不接受新任务，不处理等待队列中的任务，中断正在执行的任务；</li><li>Tidying：所有任务都销毁了，workCount为0，钩子引用terminated()；</li><li>Terminated：terminated()执行后的状态。</li></ul><h2 id="10-3-execute-和submit-区别"><a href="#10-3-execute-和submit-区别" class="headerlink" title="10.3 execute()和submit()区别"></a>10.3 execute()和submit()区别</h2><p>答：总结如下：</p><ul><li>execute()用于提交<strong>不需要返回值</strong>的任务，所以无法判断任务是否被线程池执行成功；Runnable。</li><li>submit()用于提交需要返回值的任务，线程池<strong>返回Future类型对象</strong>，通过get()获得返回值。Callable+Runnable。</li></ul><h2 id="10-4-ThreadPoolExecutor"><a href="#10-4-ThreadPoolExecutor" class="headerlink" title="10.4 ThreadPoolExecutor"></a>10.4 ThreadPoolExecutor</h2><p>答：使用ThreadPoolExecutor创建线程池，客户端调用submit(Runnable task)提交任务。</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ArrayBlockingQueue;<span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolExecutorDemo</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CORE_POOL_SIZE = <span class="hljs-number">5</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_POOL_SIZE = <span class="hljs-number">10</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> QUEUE_CAPACITY = <span class="hljs-number">100</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Long KEEP_ALIVE_TIME = <span class="hljs-number">1L</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//使用阿里巴巴推荐的创建线程池的方式</span>        <span class="hljs-comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span>        ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(                CORE_POOL_SIZE,                MAX_POOL_SIZE,                KEEP_ALIVE_TIME,                TimeUnit.SECONDS,                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),                <span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span>            Runnable worker = <span class="hljs-keyword">new</span> MyRunnable(<span class="hljs-string">""</span> + i);            <span class="hljs-comment">//执行Runnable</span>            executor.execute(worker);        &#125;        <span class="hljs-comment">//终止线程池</span>        executor.shutdown();        <span class="hljs-keyword">while</span> (!executor.isTerminated()) &#123;        &#125;        System.out.println(<span class="hljs-string">"Finished all threads"</span>);    &#125;&#125;</code></pre><p>具体参数为：</p><ul><li>corePoolSize：核心线程数，即最小可同时运行的线程数量</li><li>maximumPoolSize：最大线程数，即最大可同时运行的线程数量</li><li>keepAliveTime ：线程空闲但是保持不被回收的时间</li><li>unit：时间单位</li><li>workQueue：阻塞队列，存储线程的队列</li><li>threadFactory：创建线程的工厂</li><li>handler：拒绝策略</li></ul><p>推荐配置：</p><ul><li>corePoolSize: 核心线程数为 5。</li><li>maximumPoolSize ：最大线程数 10</li><li>keepAliveTime : 等待时间为 1L。</li><li>unit: 等待时间的单位为 TimeUnit.SECONDS。</li><li>workQueue：任务队列为 ArrayBlockingQueue，并且容量为 100;</li><li>handler:拒绝策略为 CallerRunsPolicy。</li></ul><h2 id="10-5-排队策略"><a href="#10-5-排队策略" class="headerlink" title="10.5 排队策略"></a>10.5 排队策略</h2><p>答：向线程池提交任务时，需要遵循排队策略。</p><ul><li>若运行的线程 &lt; corePoolSize，Executor首选添加线程，不排队；</li><li>若运行的线程 &gt;= corePoolSize，且队列未满，Executor首选将请求加入队列，不加新线程；</li><li>若队列已满，创建新线程，若超出maximumPoolSize ，根据拒绝策略处理。</li></ul><h2 id="10-6-拒绝-饱和策略"><a href="#10-6-拒绝-饱和策略" class="headerlink" title="10.6 拒绝/饱和策略"></a>10.6 拒绝/饱和策略</h2><p>答：线程达到max，队列也放满时，使用拒绝策略。</p><ul><li>AbortPolicy：中断，抛出异常 RejectedExecutionException来拒绝新任务的处理。</li><li>CallerRunsPolicy：调用自己所在线程运行任务。会降低对于新任务提交速度，影响程序的整体性能。</li><li>DiscardPolicy：直接丢弃，不处理。</li><li>DiscardOldestPolicy：舍弃最旧任务，丢弃最早的未处理的任务请求。</li></ul><h2 id="10-7-常见线程池类型"><a href="#10-7-常见线程池类型" class="headerlink" title="10.7 常见线程池类型"></a>10.7 常见线程池类型</h2><p>答：四种。</p><ul><li>newCachedThreadPool()：<strong>可缓存</strong>线程池，核心线程池大小为0，最大线程池大小无限，<strong>来一个创建一个线程</strong>。</li><li>newFixedThreadPool()：<strong>固定大小</strong>的线程池。</li><li>newScheduledThreadPool：<strong>定时</strong>线程池，周期执行或者定时执行。</li><li>newSingleThreadExecutor()：<strong>单线程化</strong>的线程池，保证所有任务按指定顺序执行，如FIFO、LRU。不会发生并发执行。</li></ul><h2 id="10-8-常见阻塞队列"><a href="#10-8-常见阻塞队列" class="headerlink" title="10.8 常见阻塞队列"></a>10.8 常见阻塞队列</h2><p>答：三种。</p><ol><li>ArrayBlockingQueue：基于<strong>预先分配的数组实现</strong>的有界阻塞队列。</li></ol><ul><li>优点：put和take操作不会增加GC的负担；</li><li>缺点：put和take<strong>操作使用同一个锁</strong>，可能导致锁争用。</li><li>适合在生产者线程和消费者线程之间的<strong>并发程序较低</strong>的情况下使用。</li></ul><ol start="2"><li>LinkedBlockingQueue：基于<strong>链表实现</strong>的是无界阻塞队列。(上限是Integer.MAX_VALUE)</li></ol><ul><li>优点：put和take<strong>操作使用两个显式锁</strong>；</li><li>缺点：增加GC的负担，因为空间是动态分配的。</li><li>适合在生产者线程和消费者线程之间的<strong>并发程序较高</strong>的情况下使用。</li></ul><ol start="3"><li>SynchronousQueue：不存储元素的有界阻塞队列。</li></ol><ul><li>生产者线程生产一个产品之后，会等待消费者线程来取走这个产品，才会接着生产下一个产品。(<strong>put必须有take</strong>)</li><li>适合在生产者线程和消费者线程之间的处理能力相差不大的情况下使用。</li></ul><h1 id="11-Atomic原子类"><a href="#11-Atomic原子类" class="headerlink" title="11. Atomic原子类"></a>11. Atomic原子类</h1><p>答：简单来说，原子类就是具有原子操作特征的类，即这个类中的操作不可中断。原子类都方法JUC(java.util.concurrent)并发包.atomic下，基本都是<strong>CAS + volatile</strong>实现。</p><h2 id="11-1-CAS"><a href="#11-1-CAS" class="headerlink" title="11.1 CAS"></a>11.1 CAS</h2><h3 id="11-1-1-乐观锁"><a href="#11-1-1-乐观锁" class="headerlink" title="11.1.1 乐观锁"></a>11.1.1 乐观锁</h3><p>答：CAS乐观锁假设所有线程访问资源不会出现冲突情况，在提交数据时检查完整性，如果出现冲突使用CAS处理。</p><h3 id="11-1-2-过程"><a href="#11-1-2-过程" class="headerlink" title="11.1.2 过程"></a>11.1.2 过程</h3><p>答：总结：<strong>拿期望值和原本值比较，相同就更新为新值</strong>，不同就自旋。</p><ul><li>CAS包含，V：内存中的实际值，A：预期值，B：新值。</li><li>V=A，说明值没有更改，A为当前最新值，可以进行B赋值给V。</li><li>V!=A，说明值已经改变，A不为当前最新值，不能赋值，直接返回V。</li></ul><h3 id="11-1-3-问题"><a href="#11-1-3-问题" class="headerlink" title="11.1.3 问题"></a>11.1.3 问题</h3><ol><li><strong>ABA</strong>：如果一个值初次读取为A，而后被改成B，后来又被改回A，那CAS会误认为其没有改变过。解决方案是<strong>增加变量值的版本号或者引入boolean标志改没改变</strong>，AtomicStampedReference类。</li><li><strong>自旋时间过长</strong>：CAS是非阻塞同步，不会挂起线程，而是自旋一段时间进行尝试。自旋时间过长会对性能造成很大的消耗。</li></ol><h2 id="11-2-synchronized和CAS的区别"><a href="#11-2-synchronized和CAS的区别" class="headerlink" title="11.2 synchronized和CAS的区别"></a>11.2 synchronized和CAS的区别</h2><p>答：Synchronized是互斥同步，存在线程阻塞和唤醒锁的性能问题。CAS是非阻塞同步，进行自旋后尝试。</p><h2 id="11-3-以AtomicInteger为例"><a href="#11-3-以AtomicInteger为例" class="headerlink" title="11.3 以AtomicInteger为例"></a>11.3 以AtomicInteger为例</h2><p>常用方法有：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-comment">//获取当前的值</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span><span class="hljs-comment">//获取当前的值，并设置新的值</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span><span class="hljs-comment">//获取当前的值，并自增</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndDecrement</span><span class="hljs-params">()</span> <span class="hljs-comment">//获取当前的值，并自减</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> delta)</span> <span class="hljs-comment">//获取当前的值，并加上预期的值</span></span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> <span class="hljs-comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lazySet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span><span class="hljs-comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统基础</title>
    <link href="/2020/05/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/05/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>os 的基础知识，包括进程、线程、内存管理机制和虚拟内存。</p><a id="more"></a><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>操作系统 Operating System，本质上是管理计算机硬件和软件资源的程序。为用户提供与系统交互的界面，分为外壳和内核。</p><h2 id="1-2-系统调用"><a href="#1-2-系统调用" class="headerlink" title="1.2 系统调用"></a>1.2 系统调用</h2><p>os有两种状态，分别是：</p><ol><li>用户态/目态：只能访问用户程序资源和数据。</li><li>核心态/管态：能够访问计算机的任何资源。</li></ol><p>为了安全问题，<strong>os提供一些被限制在核心态运行操作的接口给应用程序调用</strong>，这些接口就是系统调用。</p><p>用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用接口使用系统调用。先通过 <strong>trap 访管指令</strong> (用户态指令) 自愿进管，再在核心态执行特权指令。</p><h1 id="2-进程和线程"><a href="#2-进程和线程" class="headerlink" title="2. 进程和线程"></a>2. 进程和线程</h1><h2 id="2-1-区别"><a href="#2-1-区别" class="headerlink" title="2.1 区别"></a>2.1 区别</h2><table><thead><tr><th></th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>根本区别</td><td>进程是资源分配的基本单位</td><td>线程是CPU调度执行的最小允许单位</td></tr><tr><td>资源开销</td><td>进程切换要保存当前CPU环境和建立新的CPU环境</td><td>线程切换只需要保存虚拟机栈和程序计数器</td></tr><tr><td>包含关系</td><td>一个进程可以有多个线程</td><td>线程是进程的一部分</td></tr><tr><td>内存分配</td><td>进程间的资源和地址相互独立</td><td>同一进程的线程共享本进程的资源和地址</td></tr><tr><td>执行过程</td><td>每个进程都是独立运行</td><td>线程必须依赖应用程序</td></tr><tr><td>影响关系</td><td>一个进程崩溃不会影响其他进程</td><td>一个线程崩溃容易整个进程挂掉</td></tr><tr><td>系统资源</td><td>进程拥有堆和方法区/元空间</td><td>线程一般没有系统资源，但有必不可少的ThreadLocal</td></tr></tbody></table><h2 id="2-2-进程状态"><a href="#2-2-进程状态" class="headerlink" title="2.2 进程状态"></a>2.2 进程状态</h2><ul><li>创建状态 new：进程正在被创建，尚未准备好；</li><li>就绪状态 ready：进程已准备就绪，只要获得处理器资源就可运行；</li><li>运行状态 running：进程正在处理器上运行；</li><li>阻塞/等待状态 waiting：进程正在等待某一资源或操作而暂停运行；</li><li>结束状态 terminated：进程结束或中断退出。</li></ul><h2 id="2-3-线程状态"><a href="#2-3-线程状态" class="headerlink" title="2.3 线程状态"></a>2.3 线程状态</h2><ul><li>新建 New：线程正在被创建，尚为准备好；</li><li>可运行 Runnable：线程正在运行或者等待资源；</li><li>阻塞 Blocked：线程进入同步块，需要一个同步锁的等待；</li><li>无限期等待 Waiting：调用 Object.wait()，notify() 无限期等待其他线程来唤醒；</li><li>有限期等待 Time Waiting：调用 Thread.sleep(x) 等待指定时间后自动唤醒；</li><li>消亡 Terminated：线程结束或中断退出。</li></ul><h2 id="2-4-进程通信方式"><a href="#2-4-进程通信方式" class="headerlink" title="2.4 进程通信方式"></a>2.4 进程通信方式</h2><ol><li><strong>管道 Pipes</strong>：只能用于父子进程或兄弟进程间的通信；</li><li><strong>有名管道 Name Pipes</strong>：遵循FIFO，能实现任意两个进程通信；</li><li><strong>信号 Signal</strong>：通知接收进程某个事件已发生；</li><li><strong>消息队列 Message Queuing</strong>：遵循FIFO，存放内核中，能实现消息的随机查询。克服了信号承载信息少，管道只能承载无格式字节流和缓冲区大小受限问题。</li><li><strong>信号量 Semaphores</strong>：就是计数器，解决进程间同步竞争，用于多进程的共享资源访问。</li><li><strong>共享内存 Shared Memory</strong>：使多进程可以同时访问同一块内存空间，不同进程能看到其他进程对共享资源的操作。</li><li><strong>套接字 Socket</strong>：用于客户端和服务器间的网络通信，看成不同主机的进程间的双向通信。</li></ol><h2 id="2-5-线程同步方式"><a href="#2-5-线程同步方式" class="headerlink" title="2.5 线程同步方式"></a>2.5 线程同步方式</h2><ol><li><strong>互斥量 Mutex</strong>：只有持有互斥对象的线程才能访问公共资源，保证公共资源不会被同时访问。比如 synchronized锁，Lock类。</li><li><strong>信号量 Semphares</strong>：允许同一时刻多个线程访问同一资源，但会控制同时访问的最大线程数量。</li><li><strong>事件 Event</strong>：通过 wait(),notify() 等方法，保持多线程同步。</li></ol><h2 id="2-6-进程调度算法"><a href="#2-6-进程调度算法" class="headerlink" title="2.6 进程调度算法"></a>2.6 进程调度算法</h2><ul><li><strong>FCFS 先来先服务</strong>：从就绪队列中选择最先进入队列的进程分配资源，直到执行完成或中断再重新调度。</li><li><strong>SJF 短作业优先</strong>：从就绪队列中选择运行时间最短的进程分配资源，直到执行完成或中断再重新调度。</li><li><strong>高响应比优先</strong>：把CPU分配给就绪队列中响应比最高的进程。响应比 = (等待时间 + 要求服务时间)/ 要求服务时间。FCFS 和 SJF 的折中方案。</li><li><strong>RR 时间片轮转</strong>：每个进程被分配一个时间片，若时间片结束进程仍在运行，则资源被剥夺给另一个进程。该进程被移到就绪进程列表队列的末尾，等待下一次分配。</li><li><strong>优先级</strong>：首先执行具有最高优先级的进程，若优先级相同则以 FCFS 方式执行，若有更高优先级进程传入，则中断去执行更高优先级。</li><li><strong>多级反馈队列</strong>：既能使高优先级的作业得到响应又能使短作业迅速完成。各个队列的时间片随着优先级的增加而减少。</li></ul><h1 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h1><p>答：主要负责内存的分配和回收，逻辑地址和物理地址转换等。</p><h2 id="3-1-管理机制"><a href="#3-1-管理机制" class="headerlink" title="3.1 管理机制"></a>3.1 管理机制</h2><p>答：分为连续分配管理和非连续分配管理。</p><ol><li>连续分配管理：为程序分配一个连续的内存空间。<ul><li><strong>块式管理</strong>：将内存分为若干个块，每个块只能分配一个进程，未被利用的空间被称为碎片。</li></ul></li><li>非连续分配管理：为程序分配不连续的内存空间。但每个页/段内的地址是连续的。<ul><li><strong>页式管理</strong>：将内存分为若干大小相同的页，通过页表对应逻辑和物理地址。内存划分得更小，利用率更高，少量内部碎片。</li><li><strong>段式管理</strong>：将内存分为若干段，内存划分得更小，且有实际意义，每个段定义一组逻辑信息，通过段表管理。段过长也要分配连续空间。</li><li><strong>段页式管理</strong>：结合两者优点。先把内存划分成段，每个段划分为页。</li></ul></li></ol><h2 id="3-2-快表和多级页表"><a href="#3-2-快表和多级页表" class="headerlink" title="3.2 快表和多级页表"></a>3.2 快表和多级页表</h2><p>答：分页管理有两个问题。一是虚拟地址到物理地址的转换；二是虚拟地址空间过大。</p><h3 id="3-2-1-快表"><a href="#3-2-1-快表" class="headerlink" title="3.2.1 快表"></a>3.2.1 快表</h3><p>答：引入快表，提高虚拟地址到物理地址的转换速度，类似 cache。以空间换时间。</p><p>流程为：</p><ol><li>根据虚拟地址中页号查快表；</li><li>该页在快表中，直接读取，化简为一次访存；</li><li>不在则访问内存的页表，并把该页表添加到快表中，两次访存；</li><li>快表需要淘汰机制进行淘汰内部的页表。</li></ol><h3 id="3-2-2-多级页表"><a href="#3-2-2-多级页表" class="headerlink" title="3.2.2 多级页表"></a>3.2.2 多级页表</h3><p>答：引入多级页表，避免全部页表都放在内存中。将二级及以后的页表放在磁盘中，用到再调用。以时间换空间。</p><h2 id="3-3-分页和分段的共同点和区别"><a href="#3-3-分页和分段的共同点和区别" class="headerlink" title="3.3 分页和分段的共同点和区别"></a>3.3 分页和分段的共同点和区别</h2><ol><li>共同点<ul><li>都能提高内存利用率，减少内碎片；</li><li>都是非连续的分配管理方式，但每个页与段中的内存是连续的。</li></ul></li><li>区别<ul><li><strong>页的大小固定</strong>，由 os 决定；<strong>段的大小不固定</strong>，取决于运行程序的一组逻辑信息长度。</li><li>分页满足 os 内存管理的需求，没有实际意义；<strong>段是逻辑信息单位，有实际意义</strong>。</li></ul></li></ol><h2 id="3-4-逻辑地址和物理地址"><a href="#3-4-逻辑地址和物理地址" class="headerlink" title="3.4 逻辑地址和物理地址"></a>3.4 逻辑地址和物理地址</h2><p>答：逻辑地址就是内存寄存器中的地址，物理地址就是真实的物理内存中的地址。</p><h2 id="3-5-CPU寻址"><a href="#3-5-CPU寻址" class="headerlink" title="3.5 CPU寻址"></a>3.5 CPU寻址</h2><p>答：现代处理器使用<strong>虚拟寻址</strong>的方式，将虚拟地址翻译为物理地址。通过内存管理单元 MMU 实现，同样使用快表加速此过程。</p><p>os 使用虚拟地址空间来访问物理内存，避免将物理内存直接暴露给用户导致伤害 os 或者多个程序无法并行。</p><p><strong>虚拟地址空间能使用一系列相邻的虚拟地址来访问不相邻的物理内存</strong> ，不同进程的虚拟内存彼此隔离，进程间不会相互影响。</p><h1 id="4-虚拟内存"><a href="#4-虚拟内存" class="headerlink" title="4. 虚拟内存"></a>4. 虚拟内存</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>答：<strong>虚拟内存让应用程序认为它拥有一个连续完整的地址空间，并让程序拥有超过系统物理内存大小的可用空间</strong>。实际上，其被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p><h2 id="4-2-局部性原理"><a href="#4-2-局部性原理" class="headerlink" title="4.2 局部性原理"></a>4.2 局部性原理</h2><p>答：局部性原理表现为：</p><ol><li><strong>时间局部性</strong>：某条指令执行后可能再次执行，某个数据被访问后可能再次被访问。原因是程序中存在大量的循环操作。</li><li><strong>空间局部性</strong>：某个单元被访问，不久后，其附近的单元也会被访问。因为底层的数据、指令还是顺序存放的。</li></ol><p>利用局部性原理，实现高速缓存，只装载部分程序就能运行。将最近用过的数据和其附近的存储单元存 cache，建立内存-外存两级存储器结构。</p><h2 id="4-3-虚拟存储器"><a href="#4-3-虚拟存储器" class="headerlink" title="4.3 虚拟存储器"></a>4.3 虚拟存储器</h2><p>答：虚拟存储器是基于局部性原理。<strong>将程序的一部分装入内存就能启动，其他放外存</strong>，当访问数据不在内存时，os 将需要的部分调入内存，用不到的内存置换到外存。<strong>因为外存比内存大得多，所以计算机好像为用户提供了比实际内存大得多的内存</strong>。</p><h2 id="4-4-实现"><a href="#4-4-实现" class="headerlink" title="4.4 实现"></a>4.4 实现</h2><p>答：虚拟内存的实现建立在非连续的内存管理方式。</p><ol><li><strong>请求分页存储管理</strong>：基于分页管理，加入<strong>请求调页</strong>和<strong>页面置换</strong>功能。<strong>一开始仅装入当前要执行的部分段</strong>，若运行过程中访问的页面不在内存，发生缺页中断，则由 os 按照页面置换算法将相应的页面调入到主存，将暂时不用的页面置换到外存中。</li><li>请求分段存储管理：基于分段管理，加入请求调段和分段置换功能。</li><li>请求段页式存储管理。</li></ol><p>一目了然，请求分页和分页的区别就是是否将程序的全部地址空间都加载进内存。</p><h2 id="4-5-页面置换算法"><a href="#4-5-页面置换算法" class="headerlink" title="4.5 页面置换算法"></a>4.5 页面置换算法</h2><p>答：若请求页面不在内存中，发生缺页中断，需要将访问的页调入内存。若当前内存没有足够空间，必须按页面置换算法将一个页面移出内存让出空间。</p><ol><li><strong>OPT 最佳页面置换</strong>：选择的页面是之后不使用或者最长时间内不再访问的页面。但需要预知之后的页面情况，所以该算法无法实现。</li><li><strong>FIFO 先进先出</strong>：总是淘汰最先进入内存的页面，即淘汰内存中停留时间最久的页面。</li><li><strong>LRU 最近最久未使用</strong>：选择最近的最长时间没使用过的页面淘汰。</li><li><strong>LFU 最近最少使用</strong>：选择之前最近的使用次数最少的页面淘汰。</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaIO</title>
    <link href="/2020/05/02/JavaIO/"/>
    <url>/2020/05/02/JavaIO/</url>
    
    <content type="html"><![CDATA[<p>Java自身对于IO的封装，主要有BIO、NIO和AIO。</p><a id="more"></a><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><p>BIO、NIO、AIO是Java对于IO的封装，和Socket的IO模型有些不同，两者可以对照看。</p><h2 id="1-1-同步异步"><a href="#1-1-同步异步" class="headerlink" title="1.1 同步异步"></a>1.1 同步异步</h2><ul><li>同步：发送请求后，被调用者没处理完之前，不返回；</li><li>异步：发送请求后，被调用者发送收到回应，但不返回结果，调用者可以去处理其它请求，之后通过回调事件等机制通知调用者。</li></ul><h2 id="1-2-阻塞非阻塞"><a href="#1-2-阻塞非阻塞" class="headerlink" title="1.2 阻塞非阻塞"></a>1.2 阻塞非阻塞</h2><ul><li>阻塞：发送请求后，调用者一直等待结果，无法处理其他事情；</li><li>非阻塞：发送请求后，调用者不用等待结果，可以去处理其他事情。</li></ul><h1 id="2-BIO"><a href="#2-BIO" class="headerlink" title="2. BIO"></a>2. BIO</h1><p>同步阻塞 Blocking IO，数据的读取写入阻塞在一个线程完成。</p><h2 id="2-1-传统BIO"><a href="#2-1-传统BIO" class="headerlink" title="2.1 传统BIO"></a>2.1 传统BIO</h2><p>一请求一应答，服务端为每一个客户端请求创建一个新的线程进行处理。<br><img src="/img/java/%E4%BC%A0%E7%BB%9FBIO.png" srcset="/img/loading.gif" alt="传统BIO"><br>由 Acceptor 线程负责监听客户端连接，不停调用 accept() 监听请求，接收到请求，就建立 socket 进行读写操作，直到这个客户端操作完成。 </p><ul><li>优点：简单。</li><li>缺点：线程的创建、切换和销毁成本剧增。</li></ul><h2 id="2-2-伪异步IO"><a href="#2-2-伪异步IO" class="headerlink" title="2.2 伪异步IO"></a>2.2 伪异步IO</h2><p>后端通过线程池处理多个客户端请求，达到 M 个客户端 : N 个最大处理线程，其中 M &gt;&gt; N。</p><p><img src="/img/java/%E4%BC%AA%E5%BC%82%E6%AD%A5IO.png" srcset="/img/loading.gif" alt="伪异步IO"><br>客户端请求时，服务端将 Socket 封装成 Task 放进线程池，线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。</p><ul><li>优点：避免一请求一应答，线程池的资源占用可控，不会耗尽资源。</li><li>缺点：底层依然是同步阻塞的BIO模型，因此无法从根本上解决问题。</li></ul><h1 id="3-NIO"><a href="#3-NIO" class="headerlink" title="3. NIO"></a>3. NIO</h1><p>同步非阻塞 New/Non-Blocking IO。</p><h2 id="3-1-特点"><a href="#3-1-特点" class="headerlink" title="3.1 特点"></a>3.1 特点</h2><h3 id="3-1-1-非阻塞IO"><a href="#3-1-1-非阻塞IO" class="headerlink" title="3.1.1 非阻塞IO"></a>3.1.1 非阻塞IO</h3><p><strong>IO是阻塞的，NIO是非阻塞的。</strong></p><ul><li>IO 当调用write()或read()时，线程被阻塞，直到操作完成；</li><li>NIO 当线程写入数据到通道，不用等待，可以去处理其他事情。</li></ul><h3 id="3-1-2-缓冲区-buffer"><a href="#3-1-2-缓冲区-buffer" class="headerlink" title="3.1.2 缓冲区 buffer"></a>3.1.2 缓冲区 buffer</h3><p><strong>IO面向流，NIO面向缓冲区。</strong></p><ul><li>NIO 所有的数据直接读写到缓冲区处理；</li><li>IO 将数据读写到 Stream 对象中，但还是需要从流读到缓冲区。</li></ul><h3 id="3-1-3-通道-channel"><a href="#3-1-3-通道-channel" class="headerlink" title="3.1.3 通道 channel"></a>3.1.3 通道 channel</h3><p><strong>NIO 通过通道双向读写。</strong></p><ul><li>IO 流只能单向。</li><li>NIO 的通道是双向，并且只和 buffer 交互。</li></ul><h3 id="3-1-4-选择器-selector"><a href="#3-1-4-选择器-selector" class="headerlink" title="3.1.4 选择器 selector"></a>3.1.4 选择器 selector</h3><p><strong>NIO 通过选择器使用一个线程能处理多个通道。</strong></p><h2 id="3-2-读写方式"><a href="#3-2-读写方式" class="headerlink" title="3.2 读写方式"></a>3.2 读写方式</h2><ul><li>读取：创建一个 buffer，请求通道读取数据；</li><li>写入：创建一个 buffer，填充数据，要求通道写入数据。 </li></ul><h2 id="3-3-改进"><a href="#3-3-改进" class="headerlink" title="3.3 改进"></a>3.3 改进</h2><p>Netty，因为NIO 底层的 epoll 有空轮询bug，使 CPU 占用100%。</p><h1 id="4-AIO"><a href="#4-AIO" class="headerlink" title="4. AIO"></a>4. AIO</h1><p>异步非阻塞 Asynchronous IO。</p><p>客户端发送请求后，服务端立即返回，应用进程去做其他事情，当内核完成所有操作后，再通知应用进程IO已完成。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智力题</title>
    <link href="/2020/05/02/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    <url>/2020/05/02/%E6%99%BA%E5%8A%9B%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>本篇来自牛客的一个 <a href="https://www.nowcoder.com/discuss/414594?toCommentId=5976180" target="_blank" rel="noopener">帖子</a> 和 自己之前的总结，<strong>缝合</strong>而来。(您的好友缝合怪上线)</p><a id="more"></a><h1 id="1-扔鸡蛋"><a href="#1-扔鸡蛋" class="headerlink" title="1. 扔鸡蛋"></a>1. 扔鸡蛋</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>现在有两个一样的鸡蛋，坚硬程度未知，有一栋100层的大楼，鸡蛋从楼上扔下去可能坏也可能不坏，问：最少测试多少次能够找到鸡蛋不坏的最高楼层</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>二分折半。100层，直接取一半，从50层往下仍。<ul><li>碎了，就从1-50，只剩一个鸡蛋，只能从1层轮询往上。</li><li>没碎，就从50-100再折半。</li></ul></li><li>分层。将100层分成10份，每份10层，从第10层扔下。<ul><li>碎了，轮询1-10。</li><li>没碎，从第20层扔。</li><li>思路是用一个鸡蛋试探找到临界楼层的范围，再用另一个鸡蛋准确找到。最坏18次。</li></ul></li><li>转化为 <strong>2个鸡蛋测试k次最多能测试多少层</strong>。假设第一次从m层扔下。<ul><li>碎了，又变成轮询，最坏情况相当于做了 1+(m-1) 次测试，所以 m=k，即第一次应该从 k 层扔下。</li><li>没碎，又面临相同选择，此时能扔 k-1 次。</li><li>最终楼层总数 h = k+(k-1)+(k-2)+…+1，又因为 h &gt; 100，所以 k &gt; 13。</li><li>最终答案是14次。</li></ul></li></ol><h1 id="2-二进制问题"><a href="#2-二进制问题" class="headerlink" title="2. 二进制问题"></a>2. 二进制问题</h1><p>二进制应用，万变不离其宗，把数目转成二进制就行。</p><h2 id="金条问题"><a href="#金条问题" class="headerlink" title="金条问题"></a>金条问题</h2><p>有个商人雇用了一位手艺高超的工匠了为他做一个精致产品，工作一星期七天的代价是一条金条。商人手头上有一条金条，刚好有可以付工匠一星期的工钱。但工匠要求工钱要按每天来付。虽然他并不急着用钱，每天有钱进账，老人心里总是踏实一些。但商人家中有个规矩，金条每星期只能切二刀。后来商人想出以了个切割金条的办法，满足了工匠的要求。你知道商人是怎么切割金条才能满足工匠的吗？</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>切成 1，2，4。这三个数能组成表示 1-7 中的任意一个。</p><h2 id="老鼠试毒药"><a href="#老鼠试毒药" class="headerlink" title="老鼠试毒药"></a>老鼠试毒药</h2><p>有 n 桶牛奶，其中有 1 桶有问题，老鼠喝了后第二天会死掉。如何在最短时间内用最少的老鼠测出有问题的那瓶牛奶？</p><h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><p>如果 n 是 2 的整数次幂，就是 n 转换为二进制后的位数减一。如果 n 不是 2 的整数次幂，就是 n 转换为二进制后的位数。</p><p>即算log2(n)，如果是整数，那这个整数就是最少的老鼠。如果有小数，整取后并加1后的值为最少的老鼠数</p><h3 id="操作方案"><a href="#操作方案" class="headerlink" title="操作方案"></a>操作方案</h3><p>假设 n = 8，转换成二进制位 1000，可知需要最少的老鼠是 4 只，但因为 8 是 2 的整数次幂，其实最后只需要 3 只老鼠，先以 4 只老鼠为例。</p><ol><li>第一步</li></ol><p>给 8 桶牛奶用二进制编号</p><ul><li>第 1 桶牛奶 0001</li><li>第 2 桶牛奶 0010</li><li>第 3 桶牛奶 0011</li><li>第 4 桶牛奶 0100</li><li>第 5 桶牛奶 0101</li><li>第 6 桶牛奶 0110</li><li>第 7 桶牛奶 0111</li><li>第 8 桶牛奶 1000</li></ul><ol start="2"><li>第二步</li></ol><p>4 只老鼠按顺序排好，面对着牛奶对应的二进制编号，每桶二进制编号为 1 对应的老鼠喝牛奶</p><ul><li>老鼠 1 喝第 8 桶的牛奶</li><li>老鼠 2 喝第 4、5、6、7 桶的牛奶</li><li>老鼠 3 喝第 2、3、6、7 桶的牛奶</li><li>老鼠 4 喝第 1、3、5、7 桶的牛奶</li></ul><ol start="3"><li>第三步</li></ol><p>第二天后把这 4 只老鼠还按昨天的顺序排好，死了的老鼠标记为 1，没有死的老鼠标记为 0，这这样 4 只老鼠就组成了一个二进制的数，与之对应的牛奶编号就是有毒的那桶。比如老鼠 2 和老鼠 3 死了，对应的二进制编号为 0110，那就说明第 6 桶牛奶有毒</p><p>我们知道 n 为 2 的整数次幂的话，对应的二进制只有在最高位为1，也就是对应的第 n 桶牛奶只有一只老鼠喝，我们可以把这个老鼠省下来，用剩下的老鼠喝其余桶中的牛奶。如果这些老鼠都没死，那就说明是第 n 桶牛奶有毒了。</p><h1 id="3-倒水问题"><a href="#3-倒水问题" class="headerlink" title="3. 倒水问题"></a>3. 倒水问题</h1><p>两个或多个桶中的水来回倒，得到目标升数的水。</p><h2 id="通用套路"><a href="#通用套路" class="headerlink" title="通用套路"></a>通用套路</h2><p>我们每次操作只会使桶里水的总量+x，+y，-x，-y，所以就是找整数a，b使得 <strong>ax+by=z</strong> 成立。</p><p>根据贝祖定律，等式成立的条件是 <strong>z为x，y的最大公约数的倍数</strong>，所以将题目转化为<strong>求x,y的最大公约数，判断是否为z的倍数</strong>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);&#125;</code></pre><h2 id="无穷多的水"><a href="#无穷多的水" class="headerlink" title="无穷多的水"></a>无穷多的水</h2><h3 id="3和5得4"><a href="#3和5得4" class="headerlink" title="3和5得4"></a>3和5得4</h3><p>如果你有无穷多的水，一个3夸脱的和一个5夸脱的提桶，你如何准确称出 4夸脱的水？</p><p>(0，5) -&gt; (3，2) -&gt; (0，2) -&gt; (2，0) -&gt; (2，5) -&gt; (1，4)</p><h3 id="7和11得2"><a href="#7和11得2" class="headerlink" title="7和11得2"></a>7和11得2</h3><p>(0，11) -&gt; (7，4) -&gt; (0，4) -&gt; (4，0) -&gt; (4，11) -&gt; (7，8) -&gt; (0，8) -&gt; (7，1) -&gt; (0，1)</p><p>-&gt; (1，11) -&gt; (7，5) -&gt; (0，5) -&gt; (5，0) -&gt; (5，11) -&gt; (7，9) -&gt; (0，9) -&gt; (7，2)</p><h2 id="有限水且三个桶"><a href="#有限水且三个桶" class="headerlink" title="有限水且三个桶"></a>有限水且三个桶</h2><p>一个装了10L水的桶，一个7L的空桶，一个3L的空桶，怎样变成2个5L？</p><p>(10，0，0) -&gt; (7，0，3) -&gt; (7，3，0) -&gt; (4，3，3) -&gt; (4，6，0) -&gt; (1，6，3) -&gt; (1，7，2) -&gt; (8，0，2) -&gt; (8，2，0) -&gt; (5，2，3) -&gt; (5，5，0)</p><h1 id="4-蓝眼睛问题"><a href="#4-蓝眼睛问题" class="headerlink" title="4. 蓝眼睛问题"></a>4. 蓝眼睛问题</h1><p>这类问题基本上都是<strong>如果有c人是蓝眼睛的，则所有蓝眼睛的人要用c晚才能离岛，且都在同一晚离开</strong>。</p><h2 id="蓝眼睛问题"><a href="#蓝眼睛问题" class="headerlink" title="蓝眼睛问题"></a>蓝眼睛问题</h2><p>有个岛上住着一群人，有一天来了个游客，定了一条奇怪的规矩：所有蓝眼睛的人都必须尽快离开这个岛。每晚8点会有一个航班离岛。每个人都看得见别人眼睛的颜色，但不知道自己的（别人也不可以告知）。此外，他们不知道岛上到底有多少人是蓝眼睛的，只知道至少有一个人的眼睛是蓝色的。所有蓝眼睛的人要花几天才能离开这个岛？</p><h3 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h3><p><strong>有多少个蓝眼睛的人就会花多少天。</strong> 前提是所有人都是聪明的。</p><ol><li>c=1</li></ol><p>蓝眼睛的人四处观察之后，发现没有人是蓝眼睛的。但他知道至少有一人是蓝眼睛的，于是就能推导出自己一定是蓝眼睛的。因此，他会搭乘当晚的飞机离开。</p><ol start="2"><li>c=2</li></ol><p>两个蓝眼睛的人看到对方，并不确定c是1还是2，但是由上一种情况，他们知道，如果c = 1，那个蓝眼睛的人第一晚就会离岛。因此，发现另一个蓝眼睛的人仍在岛上，他一定能推断出c = 2，也就意味着他自己也是蓝眼睛的。于是，两个蓝眼睛的人都会在第二晚离岛。</p><ol start="3"><li>c&gt;2</li></ol><p>如果c = 3，那么，这三个人会立即意识到有2到3人是蓝眼睛的。如果有两人是蓝眼睛的，那么这两人会在第二晚离岛。因此，如果过了第二晚另外两人还在岛上，每个蓝眼睛的人都能推断出c = 3，因此这三人都有蓝眼睛。他们会在第三晚离岛。</p><h2 id="类似问题"><a href="#类似问题" class="headerlink" title="类似问题"></a>类似问题</h2><h3 id="疯狗问题"><a href="#疯狗问题" class="headerlink" title="疯狗问题"></a>疯狗问题</h3><p>有50家人家，每家一条狗。有一天警察通知，50条狗当中有病狗，行为和正常狗不一样。每人只能通过观察别人家的狗来判断自己家的狗是否生病，而不能看自己家的狗，如果判断出自己家的狗病了，就必须当天一枪打死自己家的狗。结果，第一天没有，第二天没有，第三天开始一阵枪响，问：一共死了几条狗？</p><h3 id="耳光问题"><a href="#耳光问题" class="headerlink" title="耳光问题"></a>耳光问题</h3><p>一群人开舞会，每人头上都戴着一顶帽子。帽子只有黑白两种，黑的至少有一顶。每个人都能看到其他人帽子的颜色，却看不到自己的。主持人先让大家看看别人头上戴的是什么帽子，然后关灯，如果有人认为自己戴的是黑帽子，就打自己一个耳光。第一次关灯，没有声音。于是再开灯，大家再看一遍，关灯时仍然鸦雀无声。一直到第三次关灯，才有劈劈啪啪打耳光的声音响起。问有多少人戴着黑帽子？</p><h1 id="5-重量问题"><a href="#5-重量问题" class="headerlink" title="5. 重量问题"></a>5. 重量问题</h1><h2 id="乒乓球重量"><a href="#乒乓球重量" class="headerlink" title="乒乓球重量"></a>乒乓球重量</h2><p>8个乒乓球，其中一个重，有一个秤，问至少几次能够找出重的那个乒乓球</p><h3 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h3><p>2次，分成3堆，3，3，2。</p><ol><li>第一种情况<ul><li>称3和3，如果一样重，代表重的在2。</li><li>称2个那一堆的。</li></ul></li><li>第二种情况<ul><li>称3和3，不一样重，重的在3里面重的那堆。</li><li>3个里面随便取2个，一样重，第三个重。不一样重，重的那个就是。</li></ul></li></ol><h2 id="盐重量问题"><a href="#盐重量问题" class="headerlink" title="盐重量问题"></a>盐重量问题</h2><p>有7克、2克砝码各一个，天平一只，如何只用这些物品五次内将140克的盐分成50、90克各一份？</p><h3 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h3><ol><li>先分成70和70</li><li>通过7和2砝码将70分成9和61</li><li>通过9克盐和2砝码将61分成50和11</li></ol><h2 id="药丸问题"><a href="#药丸问题" class="headerlink" title="药丸问题"></a>药丸问题</h2><p>有20瓶药丸，其中19瓶装有1克/粒的药丸，余下一瓶装有1.1克/粒的药丸。给你一台称重精准的天平，怎么找出比较重的那瓶药丸？天平只能用一次。</p><h3 id="答案-5"><a href="#答案-5" class="headerlink" title="答案"></a>答案</h3><ol><li>从药瓶#1取出一粒药丸，从药瓶#2取出两粒，从药瓶#3取出三粒，依此类推。</li><li>如果每粒药丸均重1克，则称得总重量为210克，<code>多出来的重量</code>必定来自每粒多0.1克的药丸。药瓶的编号可由算式(weight - 210) / 0.1 得出。</li></ol><p>比如，若这堆药丸称得重量为211.3克，则药瓶#13装有较重的药丸。</p><h1 id="6-概率问题"><a href="#6-概率问题" class="headerlink" title="6. 概率问题"></a>6. 概率问题</h1><h2 id="男孩女孩"><a href="#男孩女孩" class="headerlink" title="男孩女孩"></a>男孩女孩</h2><p>一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率（假定生男生女的概率一样）</p><h3 id="答案-6"><a href="#答案-6" class="headerlink" title="答案"></a>答案</h3><ul><li>贝叶斯学派，已知先验概率是一家男女四种组合是各 1/4，有女概率是 3/4，两女概率是 1/4，所以结果是条件概率 1/3。</li><li>频率学派，认为一个孩子是男是女的概率都是 1/2，因为生男生女概率一样且事件互斥，根据最大似然估计就应该是 1/2。</li></ul><h2 id="红球概率"><a href="#红球概率" class="headerlink" title="红球概率"></a>红球概率</h2><p>你有两个罐子，每个罐子各有若干红色弹球和蓝色弹球，两个罐子共有50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机从中选取出一个弹球，要使取出的是红球的概率最大，一开始两个罐子应放几个红球，几个蓝球？在你的计划中，得到红球的准确几率是多少？</p><h3 id="答案-7"><a href="#答案-7" class="headerlink" title="答案"></a>答案</h3><p>A罐子里放1个红球，B罐子里放49个红球和蓝球。</p><p>红球概率 =&gt; 50%+50%*49/99 = 99/198 + 49/198 = 74/99。</p><h1 id="7-其他问题"><a href="#7-其他问题" class="headerlink" title="7. 其他问题"></a>7. 其他问题</h1><h2 id="扑克牌"><a href="#扑克牌" class="headerlink" title="扑克牌"></a>扑克牌</h2><p>54张扑克牌，其中有十张是翻过来的。现在把你的眼睛蒙上，让你把扑克牌分成两叠（两叠的多少可以不一样）。要求在两叠中翻过来的扑克牌是相等的。请问该怎么做？</p><h3 id="答案-8"><a href="#答案-8" class="headerlink" title="答案"></a>答案</h3><ol><li>从54张牌中随意抽出10张；</li><li>将10张牌每张都翻过，就是所要求的。</li></ol><p>设44张牌中x张为翻过来的，10张中则有10-x张，第二步后，10张则有10-x张正面，x张翻过来的。</p><h2 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h2><p>教授选出两个从2到9的数，把它们的和告诉学生甲，把它们的积告诉学生乙，让他们轮流猜这两个数， 甲说：“我猜不出”， 乙说：“我猜不出”， 甲说：“我猜到了”， 乙说：“我也猜到了”， 问这两个数是多少？</p><h3 id="答案-9"><a href="#答案-9" class="headerlink" title="答案"></a>答案</h3><p>3和4。</p><p>设两个数为n1，n2，甲的数为 n=n1+n2，乙的数为 m=n1*n2，证明n1=3，n2=4是唯一解。</p><p>证明：先证n=7。</p><ol><li>必要性<ul><li>n &gt; 5 是显然的，因为甲回答不知道，2 3 4 5都能直接知道；</li><li>n = 6，甲虽然不知道，但乙必然知道，8或9直接得出；</li><li>n &lt; 8，若 n &gt;= 8，n至少可以分解成两种不同的合数之和，甲在第二次回答时不可能立马知道。</li></ul></li><li>充分性<ul><li>n = 7时，分解成2 5或3 4，显然2 5不合题意，舍去，3 4符合题意，m=12，证毕。</li></ul></li></ol><p>于是得到n=7，m=12， n1=3， n2=4是唯一解。</p><h2 id="标签问题"><a href="#标签问题" class="headerlink" title="标签问题"></a>标签问题</h2><p>3个箱子里面放了 苹果，梨子，苹果加梨子，标签全错误，只能选择查看一箱的水果来改正所有标签。</p><h3 id="答案-10"><a href="#答案-10" class="headerlink" title="答案"></a>答案</h3><p>查看苹果加梨子那箱。</p><ul><li>若有苹果和梨子，说明此标签对，另两个错误，需要互换；</li><li>若只有梨子，说明这箱标签应为梨子，剩下的是苹果，苹果+梨子，剩下的标签是苹果和梨子。因为标签全错，所以贴着苹果的是两者混合，贴着梨子的是苹果。</li><li>若只有苹果，情况和上一种类似。</li></ul><h2 id="吃药问题"><a href="#吃药问题" class="headerlink" title="吃药问题"></a>吃药问题</h2><p>某种药方要求非常严格，你每天需要同时服用A、B两种药片各一颗，不能多也不能少。这种药非常贵，你不希望有任何一点的浪费。一天，你打开装药片A的药瓶，倒出一粒药片放在手心；然后打开另一个药瓶，但不小心倒出了两粒药片。现在，你手心上有一颗药片A，两颗药片B，并且你无法区别哪个是A，哪个是B。你如何才能严格遵循药方服用药片，并且不能有任何的浪费？</p><h3 id="答案-11"><a href="#答案-11" class="headerlink" title="答案"></a>答案</h3><ol><li>把手上的三片药各自切成两半，分成两堆摆放。</li><li>再取出一粒药片A，也把它切成两半，然后在每一堆里加上半片的A。</li><li>现在，每一堆药片恰好包含两个半片的A和两个半片的B。一天服用其中一堆即可。</li></ol><h2 id="硬币问题"><a href="#硬币问题" class="headerlink" title="硬币问题"></a>硬币问题</h2><p>如何用一枚硬币等概率地产生一个1到3之间的随机整数？如果这枚硬币是不公正的呢？</p><h3 id="答案-12"><a href="#答案-12" class="headerlink" title="答案"></a>答案</h3><ol><li>公正硬币，投掷两次，”正反”为1，”反正”为2，”正正”为3，”反反”重来。</li><li>不公正硬币，其<code>正反</code>和<code>反正</code>的概率还是一样，因此令”正反反正”、”反正正反”、”正反正反”分别为1、2、3，其余情况重来。</li><li>若能投掷三次，则”正反反”为1，”反正反”为2，”反反正”为3，其余情况重来。</li></ol>]]></content>
    
    
    <categories>
      
      <category>智力题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>智力题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大数据场景题</title>
    <link href="/2020/05/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%BA%E6%99%AF%E9%A2%98/"/>
    <url>/2020/05/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%BA%E6%99%AF%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>海量数据判重，找中位数和拆分策略。</p><a id="more"></a><h1 id="1-容量计算"><a href="#1-容量计算" class="headerlink" title="1. 容量计算"></a>1. 容量计算</h1><p>解决海量数据问题前，先对数据的容量进行计算。</p><ul><li>1 byte = 8 bit</li><li>1 KB = 2^10 byte = 1024 byte ≈ 10^3 byte</li><li>1 MB = 2^20 byte ≈ 10^6 byte</li><li>1 GB = 2^30 byte ≈ 10^9 byte</li><li>1 亿 = 10^8</li><li>1 个int整数占 4 byte，1 亿个整数占 4*10^8 byte ≈ 400 MB。</li></ul><h1 id="2-海量数据判重"><a href="#2-海量数据判重" class="headerlink" title="2. 海量数据判重"></a>2. 海量数据判重</h1><h2 id="2-1-HashSet"><a href="#2-1-HashSet" class="headerlink" title="2.1 HashSet"></a>2.1 HashSet</h2><p>答：将海量数据拆分到多台机器上，每台机器用HashSet存储，最好是用hash取模方式将一类数据都存放在同一机器上。</p><h2 id="2-2-BitSet"><a href="#2-2-BitSet" class="headerlink" title="2.2 BitSet"></a>2.2 BitSet</h2><p>答：构建一定大小的比特数组，让每个整数都映射到比特数组上，从而得知某个整数是否存在。</p><ul><li>适用范围是海量整数数据，且范围不大。</li></ul><h2 id="2-3-布隆过滤器"><a href="#2-3-布隆过滤器" class="headerlink" title="2.3 布隆过滤器"></a>2.3 布隆过滤器</h2><p>答：铁则：<strong>布隆过滤器说对其实可能不对，但说不对那就是不对。</strong></p><p>布隆过滤器是基于BitSet/BitMap的，每次插入数据都要经过k个哈希函数得到k个索引位置，把对应索引置为1。</p><p>查找数据时，也是相同流程，得到k个位置，若有一个不为1，则不存在，若都为1，可能存在也可能误判。</p><ul><li>布隆过滤器只能插入不能删除。</li><li>优点在于利用很少的空间达到较高的精确率。</li><li>多个hash函数，增大随机性，减少碰撞概率。</li><li>扩大BitMap范围，使hash值均匀分布，减少碰撞。</li></ul><h2 id="2-4-前缀树"><a href="#2-4-前缀树" class="headerlink" title="2.4 前缀树"></a>2.4 前缀树</h2><p>答：利用字符串的公共前缀减少查询时间，查询效率高。</p><p>前缀树特性是：</p><ol><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符；</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；</li><li>每个节点的所有子节点包含的字符都不相同。</li></ol><ul><li>适用范围是海量字符串数据。</li></ul><h1 id="3-海量整数找中位数"><a href="#3-海量整数找中位数" class="headerlink" title="3. 海量整数找中位数"></a>3. 海量整数找中位数</h1><p>1亿个整数是400M，100亿个就是40GB，所以要分为内存足够和不足两种情况。</p><ol><li>内存足够，有40G。</li></ol><p>将所有数加载进内存，用快排，每次划分后将索引和50亿比较，去左/右继续排序。<br>2. 内存不够，有4G。</p><p>用 2^32=4GB 的数组存储100亿个数出现的次数。统计结束后，从0开始类加桶内的数的索引，直到累加值为50亿对应元素就是中位数。<br>3. 内存不够，有512MB。</p><p><strong>第一次确定中位数的区间，第二次确定中位数的索引</strong>。int整数的范围是[-2^31,2^31-1]划分 10w 组，每 43000 个数为一组，每次装载1亿个数，遍历放进对应区间，计数++。找到sum累加大于50亿的区间，记录区间的首尾。再按之前的方式遍历一遍100亿个整数，对之前找到的区间设置一个桶用来统计元素个数。</p><h1 id="4-海量数据拆分"><a href="#4-海量数据拆分" class="headerlink" title="4. 海量数据拆分"></a>4. 海量数据拆分</h1><p>答：将数据拆分到多台机器上/将大文件拆分成小文件，让多台机器一起工作/对小文件求解。</p><h2 id="4-1-拆分策略"><a href="#4-1-拆分策略" class="headerlink" title="4.1 拆分策略"></a>4.1 拆分策略</h2><ol><li>到达顺序：每次来的数据都放进当前Server，放满再放新增机器。</li></ol><ul><li>优点：充分利用系统资源；</li><li>缺点：需要查找表来存放数据-机器映射。</li></ul><ol start="2"><li>哈希值：用数据的key进行hash取模 N(机器数量) 得到应放入的机器序号。</li></ol><ul><li>优点：不需要查找表；</li><li>缺点：hash分配不均匀；增加新机器全部重新算hash。</li><li>改进就是一致性hash(hash环) + 虚拟节点</li></ul><ol start="3"><li>实际含义：例如，社交网站，将来自一个地区的用户尽可能存储在同一个机器上。</li></ol><ul><li>优点：避免多台机器查找，降低延迟；</li><li>缺点：使用查找表。</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式基础</title>
    <link href="/2020/05/01/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/05/01/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>分布式系统的基础理论如CAP和BASE，分布式事务，一致性算法Paxos和Raft。</p><a id="more"></a><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><p>分布式系统的目的是提升系统的整体性能和吞吐量，并尽量保证容错性。</p><h2 id="1-1-设计思路"><a href="#1-1-设计思路" class="headerlink" title="1.1 设计思路"></a>1.1 设计思路</h2><h3 id="1-1-1-中心化"><a href="#1-1-1-中心化" class="headerlink" title="1.1.1 中心化"></a>1.1.1 中心化</h3><ul><li>两个角色。将集群的节点分为<strong>领导者</strong>和<strong>工作者</strong>。</li><li>角色职责。领导者负责分发任务，监督工作者，工作者宕机后将任务重新分配。工作者就是干活的。</li><li>出现问题。领导者GG了，整个集群都GG。领导者能力不够，集群性能就低。</li><li>解决方案。多个领导者备份。选举机制。</li></ul><h3 id="1-1-2-去中心化"><a href="#1-1-2-去中心化" class="headerlink" title="1.1.2 去中心化"></a>1.1.2 去中心化</h3><ul><li><strong>众生平等</strong>。没有角色分别。</li><li>自由选择中心。集群成员自发选举领导者。</li><li>出现问题。脑裂，一个集群因为网络故障，被分成多个彼此无法通信的单独集群，各自为战。</li><li>解决方案。较小的集群自杀或拒绝服务。</li></ul><h3 id="1-1-3-集群和分布式"><a href="#1-1-3-集群和分布式" class="headerlink" title="1.1.3 集群和分布式"></a>1.1.3 集群和分布式</h3><p>集群偏向物理状态，让多个服务器跑同一个服务。</p><p>分布式偏向逻辑状态，把一个服务拆分多个子服务，并部署在不同的服务器上。</p><p>粗暴理解：单机-&gt;一个全栈；集群-&gt;多个全栈；分布式-&gt;前后端分离。</p><h2 id="1-2-CAP定理"><a href="#1-2-CAP定理" class="headerlink" title="1.2 CAP定理"></a>1.2 CAP定理</h2><p>对于一个分布式计算系统来说，不能同时满足以下三点。</p><ul><li><strong>一致性Consistence</strong>。系统在操作数据后能从一个一致性状态转移到另一个一致性状态。</li><li><strong>可用性Availability</strong>。系统提供的服务一直处于可用状态，对用户的请求都能在有限时间返回。</li><li><strong>分区容忍性Partition tolerance</strong>。系统在遇到网络分区故障时，仍能对外提供一致性和可用性服务。</li></ul><p>所以分区容忍性必不可少，CAP实际上是在一致性和可用性间权衡。</p><ul><li>一致性 + 分区容忍性。不能访问未同步完成的节点，失去部分可用性。</li><li>可用性 + 分区容忍性。允许访问全部节点，但数据可能不一致。</li></ul><h2 id="1-3-BASE理论"><a href="#1-3-BASE理论" class="headerlink" title="1.3 BASE理论"></a>1.3 BASE理论</h2><p>BASE是对CAP中一致性和可用性权衡的结果，用来保证 <code>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当方式使系统达到最终一致性。</code></p><ul><li><strong>基本可用Basically Available</strong>。系统出现故障时，保证核心可用，允许损失部分可用性。</li><li><strong>软状态Soft State</strong>。允许系统数据存在中间状态，即允许系统各个节点间的数据同步存在时延。</li><li><strong>最终一致性Eventually Consistent</strong>。系统所有的数据副本，在一段时间的同步后，最终能达到一致的状态。</li></ul><h1 id="2-事务"><a href="#2-事务" class="headerlink" title="2. 事务"></a>2. 事务</h1><p>事务要满足ACID的特性，分布式事务指事务的操作在不同的节点上。</p><h2 id="2-1-2PC"><a href="#2-1-2PC" class="headerlink" title="2.1 2PC"></a>2.1 2PC</h2><p>两阶段提交。引入协调者来协调参与者的行为，并决定参与者执行的事务。</p><h3 id="2-1-1-过程"><a href="#2-1-1-过程" class="headerlink" title="2.1.1 过程"></a>2.1.1 过程</h3><ul><li>准备阶段。协调者询问参与者事务是否执行成功，参与者返回执行结果。</li><li>提交阶段。若都成功，协调者通知参与者提交事务，否则协调者通知回滚。</li></ul><p>理解为 中央集权。</p><h3 id="2-1-2-问题"><a href="#2-1-2-问题" class="headerlink" title="2.1.2 问题"></a>2.1.2 问题</h3><ol><li><strong>同步阻塞</strong>。事务参与者在等待其他事务参与者响应时处于同步阻塞状态，无法做其他事。</li><li><strong>单点故障</strong>。协调者GG，特别是提交阶段GG，所有参与者都一直阻塞。</li><li><strong>数据不一致</strong>。提交阶段产生网络波动，部分参与者没有收到消息，导致只有部分提交，数据不一致。</li><li><strong>保守</strong>。一个节点失败，整个流程回滚。不适用高并发场景。 </li></ol><h2 id="2-2-3PC"><a href="#2-2-3PC" class="headerlink" title="2.2 3PC"></a>2.2 3PC</h2><p>三阶段提交。通过<strong>超时机制解决阻塞问题，增加询问阶段</strong>。</p><h3 id="2-2-1-过程"><a href="#2-2-1-过程" class="headerlink" title="2.2.1 过程"></a>2.2.1 过程</h3><ul><li>询问阶段。协调者询问参与者是否能完成事务，只用回答是或不是。</li><li>准备阶段。和2pc类似。区别是若有参与者回答 no 或 超时，中断事务。</li><li>提交阶段。和2pc类似。若参与者等待超时，则默认成功，继续事务提交。</li></ul><h3 id="2-2-2-问题"><a href="#2-2-2-问题" class="headerlink" title="2.2.2 问题"></a>2.2.2 问题</h3><p>一旦超时，系统就可能发生<strong>数据不一致</strong>的情况。</p><p>比如协调者发送的中止命令没有及时被接收，参与者在等待超时后执行了提交事务，导致和回滚事务的参与者间存在数据不一致。</p><h2 id="2-3-本地消息表"><a href="#2-3-本地消息表" class="headerlink" title="2.3 本地消息表"></a>2.3 本地消息表</h2><p>本地消息表和业务数据表放在同一数据库，保证本地事务，用MQ保证最终一致性。</p><h3 id="2-3-1-过程"><a href="#2-3-1-过程" class="headerlink" title="2.3.1 过程"></a>2.3.1 过程</h3><ul><li>消息生成方完成写数据操作后向本地消息表发送一个消息，本地事务保证这个消息一定会被写入本地消息表中。</li><li>将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li><li>消息消费方从消息队列中读取一个消息，并执行消息中的操作。</li></ul><h3 id="2-3-2-问题"><a href="#2-3-2-问题" class="headerlink" title="2.3.2 问题"></a>2.3.2 问题</h3><p>消息表耦合到业务系统中，复杂性增加。</p><h1 id="3-一致性算法"><a href="#3-一致性算法" class="headerlink" title="3. 一致性算法"></a>3. 一致性算法</h1><h2 id="3-1-Paxos"><a href="#3-1-Paxos" class="headerlink" title="3.1 Paxos"></a>3.1 Paxos</h2><p>对于多个节点产生的值，能<strong>保证选出唯一值</strong>。</p><h3 id="3-1-1-组成"><a href="#3-1-1-组成" class="headerlink" title="3.1.1 组成"></a>3.1.1 组成</h3><ul><li>提议者Proposer：提议一个值；</li><li>接受者Acceptor：对每个提议进行投票；</li><li>告知者Learner：被告知投票的结果，不进行投票。</li></ul><h3 id="3-1-2-过程"><a href="#3-1-2-过程" class="headerlink" title="3.1.2 过程"></a>3.1.2 过程</h3><p>提议格式为 [n,v]，n为唯一序号，v为提议值。</p><ol><li>Prepare阶段。<ul><li>Proposer向所有Acceptor发送Prepare请求；</li><li>Acceptor第一次收到请求，则发送Prepare响应，设置当前接受的提议为 [n1,v1]，并保证之后不会接受序号小于 n1 的提议。</li><li>后续收到 [n2,v2]，若 n2&lt;n1，直接丢弃；否则，发送Prepare响应，设置当前接受提议为 [n2,v2]，并保证之后不会接受序号小于 n2 的提议。</li></ul></li><li>Accept阶段。<ul><li>一个Proposer接收到超过一半的Acceptor的响应时，发送Accept请求。</li></ul></li><li>Learn阶段。<ul><li>Acceptor收到Accept请求时，若序号 &gt; 承诺的最小序号，就发送Learn提议给所有的Learner。</li><li>Learner发现大多数的Acceptor接受了某个提议，则该提议值就是选出的唯一值。</li></ul></li></ol><h3 id="3-1-3-特点"><a href="#3-1-3-特点" class="headerlink" title="3.1.3 特点"></a>3.1.3 特点</h3><ul><li>正确性。最后只有一个提议值生效。因为接受者只能接受一个提议，且每个提议需要大多数接受者接受。</li><li>可终止性。最后总有一个提议生效。</li></ul><h2 id="3-2-Raft"><a href="#3-2-Raft" class="headerlink" title="3.2 Raft"></a>3.2 Raft</h2><p>用来<strong>竞选主节点</strong>。</p><p>有三种节点：Follower，Candidate和Leader。</p><h3 id="3-2-1-单个候选者"><a href="#3-2-1-单个候选者" class="headerlink" title="3.2.1 单个候选者"></a>3.2.1 单个候选者</h3><ul><li>Leader周期性发送心跳包给所有Follower；</li><li>每个Follower设置随机的超时时间，超过这个时间没有收到心跳包，则变成Candidate，进入竞选。</li><li>Candidate发送投票请求给其它所有节点。</li><li>其它节点对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</li><li>Leader 周期性地发送心跳包给 Follower，Follower 接收到心跳包，重新开始计时。</li></ul><h3 id="3-2-2-多个候选者"><a href="#3-2-2-多个候选者" class="headerlink" title="3.2.2 多个候选者"></a>3.2.2 多个候选者</h3><ul><li>如果有多个 Follower 成为 Candidate，并获得票数相同，就重新投票。</li><li>因为每个节点的竞选超时时间随机，所以下一次再次出现多个 Candidate 并获得同样票数的概率很低。</li></ul><h3 id="3-2-3-数据同步"><a href="#3-2-3-数据同步" class="headerlink" title="3.2.3 数据同步"></a>3.2.3 数据同步</h3><ul><li>客户端的修改被传入 Leader，并写入修改日志。</li><li>Leader 把修改复制给所有 Follower。</li><li>Leader 等待大多数的 Follower 也进行了修改，然后提交修改。</li><li>Leader 通知所有 Follower 也提交修改，此时所有节点的值达成一致。</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列基础</title>
    <link href="/2020/05/01/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/05/01/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>介绍消息队列的优缺点，常见中间件和重复消费、乱序消费问题。</p><a id="more"></a><h1 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="1. 消息队列"></a>1. 消息队列</h1><h2 id="1-1-优缺点"><a href="#1-1-优缺点" class="headerlink" title="1.1 优缺点"></a>1.1 优缺点</h2><p>优点/使用场景：</p><ul><li><strong>解耦</strong>。生产消息后直接给MQ，不用关心其他事务，监听返回消息就行。</li><li><strong>异步</strong>。异步执行，提高吞吐量。发送者将消息给MQ后，不需要同步等待处理完毕，而是可以进行其它操作。</li><li><strong>削峰</strong>。请求放在MQ里，Server根据处理能力处理消息，缓解服务器压力，不至于GG。</li></ul><p>缺点：</p><ul><li><strong>系统可用性降低</strong>。MQ挂了，整个系统通信GG。</li><li><strong>系统复杂度增加</strong>。加入MQ，引出一致性、传输可靠性、消息不被重复消费等等问题。</li><li><strong>数据一致性问题</strong>。A处理结束返回，BC写库成功，D失败，数据不一致。</li></ul><h2 id="1-2-消息中间件"><a href="#1-2-消息中间件" class="headerlink" title="1.2 消息中间件"></a>1.2 消息中间件</h2><p>答：主要是ActiveMQ、RabbitMQ、RocketMQ和KafKa。</p><ul><li>ActiveMQ：老技术，现在用得不多。主从架构。</li><li>RabbitMQ：开源，中小型用这个。主从架构。</li><li>RocketMQ：阿里开发，和Dubbo RPC框架很像。分布式架构。</li><li>Kafaka：专门做大数据。分布式架构。</li></ul><h2 id="1-3-常见问题"><a href="#1-3-常见问题" class="headerlink" title="1.3 常见问题"></a>1.3 常见问题</h2><h3 id="1-3-1-重复消费"><a href="#1-3-1-重复消费" class="headerlink" title="1.3.1 重复消费"></a>1.3.1 重复消费</h3><p>因为网络问题导致Customer收到两条一样的消息，或者是消费模块处理失败请求重发消息。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>保证幂等性，即不管多少重复消息，最后处理结果还是一样。分为强校验和弱检验。</p><ol><li>强校验：把多个流程放在一个事务，成功一起成功失败一起失败。通过<strong>唯一编号标识消息或者日志表记录去重</strong>。</li><li>弱检验：不重要的场景就用 id + 场景号放在redis中，有效时间内用redis判断。</li></ol><h3 id="1-3-2-顺序消费"><a href="#1-3-2-顺序消费" class="headerlink" title="1.3.2 顺序消费"></a>1.3.2 顺序消费</h3><p>因为延迟等原因，使得消息消费顺序和发送顺序不同。</p><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li><strong>保证生产者-MQ-消费者，一一对应</strong>，消费成功一个再发下一个。</li><li>缺陷问题：吞吐量不够；耦合度太高。从业务层面保证消息顺序。</li></ul>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo搭建博客</title>
    <link href="/2020/04/29/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/04/29/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>本站使用 hexo 建站的实现步骤。</p><p>视频教程可以参照 <a href="https://www.bilibili.com/video/BV1Yb411a7ty?from=search&seid=16077203723452169370" target="_blank" rel="noopener">CodeSheep</a>，感谢羊哥。</p><a id="more"></a><h1 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>安装 Node.js。<a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网下载</a></li><li>安装 Git。<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">官网下载</a></li><li>使用 npm 或者 cnpm，进行 hexo 的安装。<pre><code class="hljs shell">npm install -g hexo-cli</code></pre>npm太慢就用cnpm，设置为淘宝源。<pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install -g hexo-cli</code></pre></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>初始化 hexo。</li></ol><p>先建立存放日后博客的文件夹，在文件夹路径下打开 bash 窗口，进行 hexo 安装。</p><pre><code class="hljs shell">hexo init</code></pre><ol start="2"><li>新建文章<pre><code class="hljs shell">// 在 source/_posts 目录下生成对应的 md 文件hexo new "文章名称"</code></pre></li><li>清理缓存<pre><code class="hljs shell">hexo clean</code></pre></li><li>生成静态文件<pre><code class="hljs shell">hexo g</code></pre></li><li>启动博客<pre><code class="hljs shell">hexo s</code></pre></li></ol><p>注：每次修改主题或修改文章，强力建议都要<code>hexo clean</code> 清理下，再进行生成和重新启动。</p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="github-io-白嫖"><a href="#github-io-白嫖" class="headerlink" title="github.io 白嫖"></a><code>github.io</code> 白嫖</h2><ol><li>生成github.io仓库</li></ol><p>首先注册并登录 GitHub，创建新的 public 仓库，仓库名称一定要是：<br><code>YourGitHubName.github.io</code></p><p>注：<strong>YourGitHubName是你的GitHub昵称，大小写敏感</strong>！部署好后，链接都是小写。</p><ol start="2"><li><p>本地安装 Hexo 的 git 部署插件</p><pre><code class="hljs yml"><span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">--save</span> <span class="hljs-string">hexo-deployer-git</span></code></pre></li><li><p>本地修改 _config.yaml 文件</p></li></ol><p>在 Hexo 目录下的 _config.yaml 文件中，对 #Deployment 做如下修改：</p><pre><code class="hljs yml"><span class="hljs-comment"># Deployment</span><span class="hljs-comment">## Docs: https://hexo.io/docs/deployment.html</span><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/YourGitHubName/YourGitHubName.github.io</span>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span></code></pre><p>注：type、repo 和 branch 冒号后都有一个空格。</p><ol start="4"><li>部署<pre><code class="hljs shell">hexo d</code></pre>部署成功后，浏览器输入 <code>YourGitHubName.github.io</code> 即可访问。</li></ol><h1 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h1><p>hexo 有很多主题能进行页面美化，常见的有 next、Yilia、Melody。</p><p>我使用的是国人制作的 Fluid，功能多样，文档详实，还有微信群…</p><p>Fluid 的 <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">GitHub</a> 和 <a href="https://hexo.fluid-dev.com/docs/guide/" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java虚拟机</title>
    <link href="/2020/04/29/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2020/04/29/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>详细叙述Java内存区域，HotSpot虚拟机，内存分配回收，GC判断，GC算法，GC器和类加载流程。</p><p>参考：《深入理解java虚拟机(第三版)》，<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md" target="_blank" rel="noopener">JavaGuide_Java内存区域</a></p><a id="more"></a><h1 id="0-JVM组成部分"><a href="#0-JVM组成部分" class="headerlink" title="0. JVM组成部分"></a>0. JVM组成部分</h1><p><img src="/img/java/JVM%E7%BB%84%E6%88%90" srcset="/img/loading.gif" alt="JVM组成"></p><p>JVM包括两个子系统和两个组件。</p><ul><li>Class Loader类装载：根据全限定类名装载.class文件到运行时数据区域。</li><li>Runtime Data Area运行时数据区域：即JVM内存区域。</li><li>Execution Engine执行引擎：执行class指令，JIT和GC。</li><li>Native Interface本地接口：和本地方法库交互，与其他语言交互的接口。</li></ul><p><strong>流程</strong></p><ol><li>Class Loader读取.class文件转换成java.lang.Class的一个实例；</li><li>Runtime Date Area把字节码加载到内存；</li><li>Execution Engine把字节码翻译成底层系统指令，交给CPU执行；</li><li>过程中调用Native Interface实现功能。</li></ol><h1 id="1-Java内存区域"><a href="#1-Java内存区域" class="headerlink" title="1. Java内存区域"></a>1. Java内存区域</h1><p>答：JVM中内存主要划分为5个区域，即方法区，堆内存，虚拟机栈，本地方法栈和程序计数器。<br><img src="/img/java/jvm%E5%86%85%E5%AD%98.png" srcset="/img/loading.gif" alt="JVM内存"></p><h2 id="1-1-组成"><a href="#1-1-组成" class="headerlink" title="1.1 组成"></a>1.1 组成</h2><h3 id="1-1-1-方法区"><a href="#1-1-1-方法区" class="headerlink" title="1.1.1 方法区"></a>1.1.1 方法区</h3><p>答：方法区是一个线程之间共享的区域，用于存储已被虚拟机加载的类信息、常量、静态变量等。也被称为“永远代”，二者的关系类似接口和类的关系，即标准和实现。通过-XX：MaxPermSize控制上限。</p><h3 id="元空间替换方法区"><a href="#元空间替换方法区" class="headerlink" title="元空间替换方法区"></a>元空间替换方法区</h3><p>答：JDK1.8后，元空间代替了方法区。方法区本身由JVM设定固定的大小上限，元空间直接使用直接内存，受本机可用内存限制，溢出可能性小。</p><h3 id="1-1-2-堆内存"><a href="#1-1-2-堆内存" class="headerlink" title="1.1.2 堆内存"></a>1.1.2 堆内存</h3><p>答：堆内存是GC的主要场所，线程共享的区域，用来存储创建的对象实例即分配内存。</p><h3 id="1-1-3-虚拟机栈"><a href="#1-1-3-虚拟机栈" class="headerlink" title="1.1.3 虚拟机栈"></a>1.1.3 虚拟机栈</h3><p>答：栈内存主要保存实例方法、基本数据类型变量和对象的引用变量，为Java方法服务。内部由栈帧(一个关于方法和运行期数据的数据集)组成，存储局部变量表(单位是slot)、操作数栈、引用等信息。生命周期和线程相同。</p><p>栈中，一个对象只对应一个 4byte 的引用。</p><p>总结一下：<strong>栈管运行数据(基本数据类型、对象引用)保存，堆管实例分配内存。</strong></p><h3 id="1-1-4-程序计数器-PC寄存器"><a href="#1-1-4-程序计数器-PC寄存器" class="headerlink" title="1.1.4 程序计数器/PC寄存器"></a>1.1.4 程序计数器/PC寄存器</h3><p>答：程序计数器其实就是一个<strong>指针，指向程序中下一句要执行的指令</strong>。字节码解释器通过改变程序计数器来选取下一条需要执行的字节码指令，多线程时程序计数器用来记录当前线程执行位置，方便多线程切换。其随线程创建而创建，消亡而消亡。</p><h3 id="1-1-5-本地方法栈"><a href="#1-1-5-本地方法栈" class="headerlink" title="1.1.5 本地方法栈"></a>1.1.5 本地方法栈</h3><p>答：为JVM提供使用到的native方法服务。HotSpot中本地方法栈和虚拟机栈合二为一。</p><h2 id="1-2-堆栈区别"><a href="#1-2-堆栈区别" class="headerlink" title="1.2 堆栈区别"></a>1.2 堆栈区别</h2><table><thead><tr><th></th><th>堆</th><th>栈</th></tr></thead><tbody><tr><td>物理地址</td><td>不连续</td><td>连续</td></tr><tr><td>内存分别</td><td>运行时确认，大小不定</td><td>编译时确定，大小固定</td></tr><tr><td>存放内容</td><td>对象实例</td><td>局部变量</td></tr><tr><td>透明度</td><td>整个进程可见</td><td>线程私有</td></tr></tbody></table><h2 id="1-3深拷贝和浅拷贝"><a href="#1-3深拷贝和浅拷贝" class="headerlink" title="1.3深拷贝和浅拷贝"></a>1.3深拷贝和浅拷贝</h2><ul><li>深拷贝：增加一个指针并申请一个新内存，让指针指向新的内存地址；</li><li>浅拷贝：增加一个指针，指向已存在的内存地址，即引用传递。</li></ul><h1 id="2-HotSpot虚拟机"><a href="#2-HotSpot虚拟机" class="headerlink" title="2. HotSpot虚拟机"></a>2. HotSpot虚拟机</h1><h2 id="2-1-对象创建"><a href="#2-1-对象创建" class="headerlink" title="2.1 对象创建"></a>2.1 对象创建</h2><p>答：5个步骤。<br><img src="/img/java/java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" alt="创建对象过程"></p><h3 id="2-1-1-类加载检查"><a href="#2-1-1-类加载检查" class="headerlink" title="2.1.1 类加载检查"></a>2.1.1 类加载检查</h3><p>虚拟机遇到一条new指令时，先去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并检查这个类是否被加载解析和初始化，若没有则进行类加载。</p><h3 id="2-1-2-分配内存"><a href="#2-1-2-分配内存" class="headerlink" title="2.1.2 分配内存"></a>2.1.2 分配内存</h3><p>把一块大小确定的内存从Java堆中划分出来.</p><h3 id="2-1-3-初始化零值"><a href="#2-1-3-初始化零值" class="headerlink" title="2.1.3 初始化零值"></a>2.1.3 初始化零值</h3><p>虚拟机将分配到的内存空间都初始化零值，保证对象实例字段不赋初试值就能使用。</p><h3 id="2-1-4-设置对象头"><a href="#2-1-4-设置对象头" class="headerlink" title="2.1.4 设置对象头"></a>2.1.4 设置对象头</h3><p>虚拟机要对对象进行必要设置，将信息放在对象头中。包括哈希码，GC分代年龄，元数据指针等。</p><h3 id="2-1-5-执行init方法"><a href="#2-1-5-执行init方法" class="headerlink" title="2.1.5 执行init方法"></a>2.1.5 执行init方法</h3><p>从JVM角度看，对象已经新建完毕。从程序角度看，还需执行init方法。</p><h2 id="2-2-内存分配方式"><a href="#2-2-内存分配方式" class="headerlink" title="2.2 内存分配方式"></a>2.2 内存分配方式</h2><p>答：指针碰撞和空闲列表。</p><ul><li><strong>指针碰撞</strong>：堆内存中没有内存碎片，将<strong>用过</strong>的内存<strong>放在一边</strong>，<strong>没用过</strong>的<strong>放</strong>在<strong>另一边</strong>，<strong>中间</strong>有一个<strong>分界指针</strong>，内存分配就是将指针往没用过内存的方向移动对象内存大小。</li><li><strong>空闲列表</strong>：堆内存中有内存碎片，虚拟机维护一个<strong>列表记录可用内存块</strong>，内存分配就是找到一块足够大的空闲块划分给对象。</li></ul><h2 id="2-3-内存分配的线程安全"><a href="#2-3-内存分配的线程安全" class="headerlink" title="2.3 内存分配的线程安全"></a>2.3 内存分配的线程安全</h2><ul><li><strong>CAS+失败重试</strong>：假设没有冲突去完成某个操作，若有冲突而失败则不断重试直到成功。保证操作原子性。</li><li><strong>TLAB</strong>：为每一个线程都分配一块内存，每次分配内存时，先在TLAB(Thread Local Allocation Buffer)中分配，不够时再用第一种方法。</li></ul><h2 id="2-4-对象的访问定位"><a href="#2-4-对象的访问定位" class="headerlink" title="2.4 对象的访问定位"></a>2.4 对象的访问定位</h2><p>答：栈内存有一个引用去访问定位堆中的具体对象，这个访问方式有两种。</p><ul><li><strong>句柄访问</strong>：在堆内存中划分一块内存作为句柄池，<strong>引用</strong>中<strong>存储</strong>的是对象的<strong>句柄地址(指向指针的指针)</strong>，每个句柄包含对象实例数据和类型数据的具体地址信息。优点是对象改变只改变句柄，不动引用。</li><li><strong>直接指针</strong>：<strong>引用</strong>中<strong>存储</strong>的是<strong>对象的直接地址</strong>，通过指针直接访问对象。优点是速度快。</li></ul><h2 id="2-5-Java内存泄漏"><a href="#2-5-Java内存泄漏" class="headerlink" title="2.5 Java内存泄漏"></a>2.5 Java内存泄漏</h2><h3 id="2-5-1-概念"><a href="#2-5-1-概念" class="headerlink" title="2.5.1 概念"></a>2.5.1 概念</h3><p>答：内存泄漏就是存在一些不能被 GC 回收，但仍占用内存的对象。</p><h3 id="2-5-2-原因"><a href="#2-5-2-原因" class="headerlink" title="2.5.2 原因"></a>2.5.2 原因</h3><p>答：一般就是<strong>长生命周期的对象持有短生命周期对象的强引用</strong>，导致短生命周期对象无法被GC回收。</p><h3 id="2-5-3-情况举例"><a href="#2-5-3-情况举例" class="headerlink" title="2.5.3 情况举例"></a>2.5.3 情况举例</h3><ol><li>静态集合类；</li><li>监听器。删除对象时没有删除监听器；</li><li>各种连接。数据库连接,socket连接,IO连接没有手动 close()；</li><li>单例模式。若持有外部引用，无法被 GC。</li></ol><h3 id="2-5-4-解决方案"><a href="#2-5-4-解决方案" class="headerlink" title="2.5.4 解决方案"></a>2.5.4 解决方案</h3><ol><li>尽量少用 static，减少生命周期长度；</li><li>用完就关闭 close()；</li><li>不用的对象，手动设置为空。</li></ol><h1 id="3-内存分配和回收"><a href="#3-内存分配和回收" class="headerlink" title="3.内存分配和回收"></a>3.内存分配和回收</h1><p>答：堆内存分为新生代，老生代。新生代又分为Eden(伊甸)，Survivor、To Survive(幸存)。//这里有个延伸问题，见GC算法。<br><img src="/img/java/%E5%A0%86%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84.png" srcset="/img/loading.gif" alt="分代"></p><h2 id="3-1-过程"><a href="#3-1-过程" class="headerlink" title="3.1 过程"></a>3.1 过程</h2><ol><li>创建的对象优先在Eden分配(年龄为0)，大对象(需要大量连续内存空间的对象)直接进入老年代。</li><li>经过一次新生代GC，对象还存活便进入s0(From Survivor)或s1(To Survivor)，且年龄+1。</li><li>每次GC，年龄++，默认 &gt; 15岁，对象进入老年代。</li></ol><blockquote><p>Q：为何是15? A：分配的空间是4位，最大就是15。</p></blockquote><h2 id="3-2-垃圾回收"><a href="#3-2-垃圾回收" class="headerlink" title="3.2 垃圾回收"></a>3.2 垃圾回收</h2><p>答：垃圾回收主要是完成清理对象，整理内存的工作。根据区域不同分为两种：</p><ul><li>Minor GC(年轻代GC)：优先Eden分配，没有足够空间便发生一次Minor GC。次数频繁。</li><li>Full GC(老年代GC)：老年代没有足够空间发生Full GC。</li></ul><h2 id="3-3-动态年龄判定"><a href="#3-3-动态年龄判定" class="headerlink" title="3.3 动态年龄判定"></a>3.3 动态年龄判定</h2><p>答：若Survivor空间中相同年龄的对象大小总和 &gt; Survivor空间的一半，则年龄 &gt;= 该对象年龄的对象自动晋升老年代。</p><h2 id="3-4-空间分配担保"><a href="#3-4-空间分配担保" class="headerlink" title="3.4 空间分配担保"></a>3.4 空间分配担保</h2><p>答：在发生minor gc之前，虚拟机会检测 : 老年代最大可用的连续空间 &gt; 新生代all对象总空间？</p><ol><li>满足，minor gc是安全的，可以进行minor gc。</li><li>不满足，虚拟机查看HandlePromotionFailure参数：<br>（1）为true，允许担保失败，会继续检测老年代最大可用的连续空间 &gt; 历次晋升到老年代对象的平均大小? minor gc ：full gc。<br>（2）为false，则不允许，要进行full gc。</li></ol><h1 id="4-如何判断对象是否需要被回收"><a href="#4-如何判断对象是否需要被回收" class="headerlink" title="4. 如何判断对象是否需要被回收"></a>4. 如何判断对象是否需要被回收</h1><h2 id="4-1-引用计数法"><a href="#4-1-引用计数法" class="headerlink" title="4.1 引用计数法"></a>4.1 引用计数法</h2><p>答：给堆中的对象实例添加一个<strong>引用计数器</strong>，每当有一个地方引用它，计数器+1；引用失效，计数器-1；计数器为0的对象被GC。</p><p>缺点是<strong>无法解决循环引用</strong>的问题。eg. A和B相互引用，计数器一直++，不为0。</p><h2 id="4-2-可达性分析-root根搜索"><a href="#4-2-可达性分析-root根搜索" class="headerlink" title="4.2 可达性分析/root根搜索"></a>4.2 可达性分析/root根搜索</h2><p>答：思想是通过被称为root的对象为起点，向下搜索，节点走过的路径为引用链，当<strong>对象到root没有引用链相连则被GC</strong>。<br><img src="/img/java/root%E6%A0%B9%E6%90%9C%E7%B4%A2.png" srcset="/img/loading.gif" alt="root根搜索"></p><p>可以作为 GC Roots的对象：</p><ol><li>虚拟机栈引用的对象；</li><li>方法区中常量引用对象；</li><li>方法区中类静态属性引用的对象；</li><li>本地方法栈中 JNI 引用对象。</li></ol><h2 id="4-3-引用类型"><a href="#4-3-引用类型" class="headerlink" title="4.3 引用类型"></a>4.3 引用类型</h2><p>答：分为四种。</p><ul><li>强引用：最常用的，只要强引用存在，GC就<strong>不会回收</strong>被引用对象；</li><li>软引用：可有可无，每次<strong>内存不够</strong>，GC<strong>就回收</strong>，内存足够就不动；(省心常用)</li><li>弱引用：可有可无，每次只要GC就会回收弱引用，<strong>不管内存够不够都回收</strong>；</li><li>虚引用：形同虚设，主要是当对象被回收时有一个系统通知。</li></ul><h2 id="4-4-废弃常量和无用类"><a href="#4-4-废弃常量和无用类" class="headerlink" title="4.4 废弃常量和无用类"></a>4.4 废弃常量和无用类</h2><p>答：各自的判断标准：</p><ul><li>常量池回收废弃常量的判断标准是，当前没有任何类型对象引用该常量。</li><li>方法区回收无用类的判断标准是，类的实例被回收、ClassLoader被回收、类对象没有任何引用和访问。</li></ul><h1 id="5-GC算法"><a href="#5-GC算法" class="headerlink" title="5. GC算法"></a>5. GC算法</h1><p>答：虚拟机中用root根搜索方法进行内存回收，常见的回收算法有标记清除、复制和标记整理算法。</p><h2 id="5-1-标记-清除算法-Mark-Sweep"><a href="#5-1-标记-清除算法-Mark-Sweep" class="headerlink" title="5.1 标记-清除算法(Mark-Sweep)"></a>5.1 标记-清除算法(Mark-Sweep)</h2><ul><li>标记阶段，标记出所有需要被回收的对象；</li><li>清除阶段，遍历整个堆，清除被标记对象。</li></ul><p>缺点：产生内存碎片且需要暂停应用stop the world，效率慢。<br><img src="/img/java/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95.png" srcset="/img/loading.gif" alt="标记清除"></p><h2 id="5-2-复制算法"><a href="#5-2-复制算法" class="headerlink" title="5.2 复制算法"></a>5.2 复制算法</h2><ul><li>将内存空间分成相等的两块，每次只用其中一个。</li><li>GC时，把当前使用区域中存活的对象复制到另一个区域中。</li></ul><p>优点：不会产生碎片；缺点：两倍内存空间。<br><img src="/img/java/%E5%A4%8D%E5%88%B6%E6%B3%95.png" srcset="/img/loading.gif" alt="复制法"></p><h2 id="5-3-标记-整理算法"><a href="#5-3-标记-整理算法" class="headerlink" title="5.3 标记-整理算法"></a>5.3 标记-整理算法</h2><p>结合上两种算法。</p><ul><li>标记阶段，标记出所有需要被回收的对象；</li><li>整理阶段，让所有存活的对象都向一端移动，按序排放。</li></ul><p>优点：不会产生碎片；缺点：需要进行对象移动。<br><img src="/img/java/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" srcset="/img/loading.gif" alt="标记整理法"></p><h2 id="5-4-分代收集"><a href="#5-4-分代收集" class="headerlink" title="5.4 分代收集"></a>5.4 分代收集</h2><ul><li>根据对象生命周期，将内存划分为新生代，老年代和永久代。</li><li>新生代变动频繁采用复制算法，老年代因对象存活几率大且没有其他空间进行担保采用标记清除或标记整理。</li></ul><p>注：这里可以提问JVM为什么要分新生代和老生代？</p><p>答：不同对象的生命周期不一样，根据生命周期采用不同的回收策略，提高回收效率。</p><h1 id="6-垃圾回收器"><a href="#6-垃圾回收器" class="headerlink" title="6. 垃圾回收器"></a>6. 垃圾回收器</h1><p>答：GC算法是方法论，垃圾回收器就是具体的实现。JVM中主要包括7种。</p><ul><li>新生代：Serial、ParNew，Parallel Scavenge</li><li>老年代：Serial Old、Parallel Old、CMS</li><li>整堆：G1</li></ul><p>新生代一般用复制，老年代一般用标记整理(CMS-标记清除)</p><h2 id="6-1-Serial串行收集器"><a href="#6-1-Serial串行收集器" class="headerlink" title="6.1 Serial串行收集器"></a>6.1 Serial串行收集器</h2><p>单线程收集器，GC时必须Stop the world。简单高效。Client模式下的默认新生代收集器。</p><h2 id="6-2-Serial-Old收集器"><a href="#6-2-Serial-Old收集器" class="headerlink" title="6.2 Serial Old收集器"></a>6.2 Serial Old收集器</h2><p>Serial Old是串行收集器的老年代版本，单线程收集器。作用是Service模式下作为CMS的备案。标记整理算法。</p><h2 id="6-3-ParNew收集器"><a href="#6-3-ParNew收集器" class="headerlink" title="6.3 ParNew收集器"></a>6.3 ParNew收集器</h2><p>ParNew是串行收集器的多线程版本，新生代是并行，老年代是串行。</p><h2 id="6-4-Parallel-Scavenge收集器"><a href="#6-4-Parallel-Scavenge收集器" class="headerlink" title="6.4 Parallel Scavenge收集器"></a>6.4 Parallel Scavenge收集器</h2><p>Parallel Scavenge是使用复制算法的多线程收集器，更加关注吞吐量(CPU运行用户代码时间/总时间)，高效率利用CPU。</p><h2 id="6-5-Parallel-Old收集器"><a href="#6-5-Parallel-Old收集器" class="headerlink" title="6.5 Parallel Old收集器"></a>6.5 Parallel Old收集器</h2><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记整理算法。</p><h2 id="6-6-CMS收集器"><a href="#6-6-CMS收集器" class="headerlink" title="6.6 CMS收集器"></a>6.6 CMS收集器</h2><p>CMS(Concurrent Mark Sweep)是一种<strong>牺牲吞吐量以获取<br>最短回收停顿时间</strong>为目标的老年代收集器。标记清除算法，与ParNew一起使用。</p><p>整个过程分为四个步骤：</p><ol><li>初始标记：Stop the world，<strong>标记</strong>GC root<strong>直接关联</strong>的对象；</li><li>并发标记：<strong>同时开启</strong>GC和用户线程。用闭包结构记录可达对象和引用更新；</li><li>重新标记：Stop the world，<strong>更新</strong>并发标记阶段因用户程序运行而导致变动的对象<strong>标记</strong>记录；</li><li>并发清除：开启用户线程，基于标记清除对象。<br><img src="/img/java/CMS%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" alt="CMS"></li></ol><p>优点：停顿时间少，并发收集；</p><p>缺点：</p><ul><li>对CPU资源敏感，CPU变小，性能会出问题；</li><li><strong>无法处理浮动垃圾</strong>。浮动垃圾指在GC完成时产生的垃圾，这些垃圾只能在下一GC周期回收；</li><li>标记清除方式会产生<strong>内存碎片</strong>。</li></ul><h2 id="6-7-G1收集器"><a href="#6-7-G1收集器" class="headerlink" title="6.7 G1收集器"></a>6.7 G1收集器</h2><p>传统分代垃圾回收方式无法解决 Full GC 的应用暂停。</p><ul><li>G1 吸取增量收集优点，把堆划分为一个一个等大小的区域 region；</li><li>同时吸取 CMS 特点，将 GC 分为几个阶段；</li><li>认同分代回收的理念，对于不同生命周期对象，采用不同收集方式；</li><li>维护一个<strong>垃圾价值优先列表</strong>，根据停顿时间从表中选择价值最大的区域回收。</li></ul><blockquote><p>特点：</p><ul><li>并行和并发：充分利用CPU和多核环境，缩短Stop the World的时间。</li><li>分代收集：不用其他收集器就可管理整个GC，且保留了分代；</li><li>空间整合：整体上是标记-整理算法，局部上是复制算法；</li><li>可预测的停顿：能让用户明确指定停顿时间长度，来进行GC。</li></ul></blockquote><h1 id="7-类加载机制"><a href="#7-类加载机制" class="headerlink" title="7. 类加载机制"></a>7. 类加载机制</h1><p>答：类加载机制包括：加载，验证，准备，解析，初始化。最终形成能被虚拟机使用的Java类型。</p><h2 id="7-1-流程"><a href="#7-1-流程" class="headerlink" title="7.1 流程"></a>7.1 流程</h2><h3 id="7-1-1-加载"><a href="#7-1-1-加载" class="headerlink" title="7.1.1 加载"></a>7.1.1 加载</h3><p>加载通过全类名将<strong>类的.class文件转二进制数据加载到内存</strong>，放在方法区内，然后在堆上创建一个java.lang.Class对象，用来封装静态数据结构在方法区中运行时的数据结构。</p><h3 id="7-1-2-验证"><a href="#7-1-2-验证" class="headerlink" title="7.1.2 验证"></a>7.1.2 验证</h3><p>验证的作用是<strong>确保被加载类的正确性</strong>，符合JVM的规范和安全，包括文件格式验证，元数据验证，字节码验证和符号引用验证。<br><img src="/img/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%AA%8C%E8%AF%81.png" srcset="/img/loading.gif" alt="类加载验证"></p><h3 id="7-1-3-准备"><a href="#7-1-3-准备" class="headerlink" title="7.1.3 准备"></a>7.1.3 准备</h3><p>准备阶段为类的<strong>静态变量</strong>在方法区中<strong>分配内存</strong>，并<strong>初始化</strong>为默认值。<br>eg. public static int value=3，初始值是0；public static final int value=3，初始值为3。</p><h3 id="7-1-4-解析"><a href="#7-1-4-解析" class="headerlink" title="7.1.4 解析"></a>7.1.4 解析</h3><p>解析阶段将常量池中的<strong>符号引用转换为直接引用</strong>。符号引用是以一组符号来描述引用的目标，直接引用就是直接指向内存的地址。</p><h3 id="7-1-5-初始化"><a href="#7-1-5-初始化" class="headerlink" title="7.1.5 初始化"></a>7.1.5 初始化</h3><p>初始化阶段就是一个赋值的操作，为类的变量赋予正确的初始值。</p><h2 id="7-2-类加载器"><a href="#7-2-类加载器" class="headerlink" title="7.2 类加载器"></a>7.2 类加载器</h2><p>答：JVM内置了三个类加载器和用户自定义类加载器。</p><ul><li><strong>启动类加载器</strong>BootstrapClassLoader：最顶层的加载类，负责加载 %JAVA_HOME%/lib 目录下的jar包或被 -Xbootclasspath 参数指定路径中的类；</li><li><strong>扩展类加载器</strong>ExtensionClassLoader：负责加载 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包；</li><li><strong>应用类加载器</strong>AppClassLoader：面向用户的加载器，负责加载当前应用的classpath下的jar包和类。</li><li>自定义类加载器CustomClassLoader：需要继承ClassLoader，重写loadClass()。</li></ul><h3 id="7-2-1-类和类加载器的关系"><a href="#7-2-1-类和类加载器的关系" class="headerlink" title="7.2.1 类和类加载器的关系"></a>7.2.1 类和类加载器的关系</h3><p>答：比较两个类是否相等，得在两个类是由同一个类加载器加载的前提下才有意义。否则即使来自同一个class，只要类加载器不同，则必不相等。</p><h2 id="7-3-双亲委派模型"><a href="#7-3-双亲委派模型" class="headerlink" title="7.3 双亲委派模型"></a>7.3 双亲委派模型</h2><p>答：协同工作时ClassLoader默认使用双亲委派模式。</p><ul><li>简单来说就是，类加载时，将请求委派给父类的ClassLoader，父类不能处理时，再由子类自己去完成类的加载。</li><li>所有的请求<strong>最终都会传送给最顶层的BootstrapClassLoader</strong></li><li>当父加载器为空，则默认 BootstrapClassLoader 作为父类加载器。</li></ul><p>优点：避免类重复加载，保证API不被篡改。(相同类文件被不同类加载器加载产生两个不同类，同时若让类加载器自己加载自己的，容易产生多个不同的类，如Object类)</p><p><img src="/img/java/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" alt="双亲委派"></p><h3 id="7-3-1-打破双亲委派"><a href="#7-3-1-打破双亲委派" class="headerlink" title="7.3.1 打破双亲委派"></a>7.3.1 打破双亲委派</h3><ol><li>自己写一个类加载器，继承 java.lang.ClassLoader；</li><li>重写 loadClass()；</li><li>重写 findClass()。</li></ol><h1 id="8-JVM常用内存调优命令"><a href="#8-JVM常用内存调优命令" class="headerlink" title="8. JVM常用内存调优命令"></a>8. JVM常用内存调优命令</h1><p>答：命令在JDK安装目录的bin文件夹下。</p><ul><li>jps(JVM Process Status)：查看所有Java进程的pid、启动类、参数等信息；</li><li>jstat(JVM statistics Monitoring Tool)：查看虚拟机的运行数据 ；</li><li>jinfo(Configuration Info for Java)：显示虚拟机配置信息；</li><li>jmap(Memory Map for Java)：查看堆内存的使用情况；</li><li>jhat：分析heapdump文件，建立一个HTTP服务器，在浏览器中查看分析结果；</li><li>jstack(Stack Trace for Java)：查看进程内的线程堆栈信息。</li></ul><h2 id="8-1-排查线上的服务异常"><a href="#8-1-排查线上的服务异常" class="headerlink" title="8.1 排查线上的服务异常"></a>8.1 排查线上的服务异常</h2><p>答：简单介绍：</p><ul><li>首先查看当前进程的JVM参数，有没有设置问题；</li><li>查看GC日志，看GC频率和时间有无异常；</li><li>jps查看进程的具体信息；</li><li>jstack pid查看线程状态，是否有死锁；</li><li>jstat -gcutil pid查看进程的GC情况；</li><li>jmap -heap pid查看进程的堆信息；</li><li>jhat查看dump文件，分析异常。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础</title>
    <link href="/2020/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>计网基础知识，详细总结了tcp、http协议，以及其他常用到的应用层和网络层协议。</p><p>参考书目：《计算机网络》(谢希仁)，《计算机网络：自顶向下》，《王道计算机网络》</p><a id="more"></a><h1 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1. 网络结构"></a>1. 网络结构</h1><p>答：一般采用中和了OSI和TCP/IP体系的五层的协议体系。</p><ul><li>应用层：为应用程序提供交互服务。包含协议有DNS、HTTP、SMTP等。</li><li>运输层：向主机进程提供通用的数据传输服务。主要包括TCP(传输控制协议)和UDP(用户数据协议)。</li><li>网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。</li><li>数据链路层：将网络层传下来的IP数据包组装成帧，并再相邻节点的链路上传送帧。</li><li>物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。</li></ul><h2 id="1-1-TCP-IP协议簇"><a href="#1-1-TCP-IP协议簇" class="headerlink" title="1.1 TCP/IP协议簇"></a>1.1 TCP/IP协议簇</h2><p>互联网协议套件IPS是一个网络通讯模型，以及一整个网络传输协议家族，是网际网络的基础通讯架构。因为TCP和IP是最早制定的标准，所以又被称为TCP/IP协议簇。</p><ul><li>应用协议：HTTP、SMTP、FTP、TELNET；</li><li>传输协议：TCP、UDP；</li><li>网际协议：IP、ICMP、ARP；</li><li>路由控制协议：RIP、OSPF、BGP。</li></ul><h1 id="2-TCP"><a href="#2-TCP" class="headerlink" title="2. TCP"></a>2. TCP</h1><h2 id="2-1-首部格式"><a href="#2-1-首部格式" class="headerlink" title="2.1 首部格式"></a>2.1 首部格式</h2><p>答：包含如下:</p><ol><li>源端口号</li><li>目的端口号</li><li>序号：对字节流编号。</li><li>确认号：期望收到的下一个报文段序号。eg.B收到A的序号201，长度100，则B发给A的确认报文段的确认号为301。</li><li>数据偏移：指首部的长度。</li><li>标志位：总共有6个。<ul><li>确认ACK：当ACK=1时，确认号字段有效，否则无效。<strong>连接建立后，ACK都为1</strong>。</li><li>同步SYN：建立连接时同步序号。当SYN=1 ACK=0时，为请求连接报文，SYN=1 ACK=1为建立连接的响应报文。</li><li>终止FIN：释放连接。当FIN=1时，为此报文端的发送方数据发送完毕，请求关闭连接。</li><li>重置RST</li><li>数据传输PSH：有报文需要传递给应用层</li><li>紧急指针URG：设置紧急指针有效</li></ul></li><li>窗口：作为接收方让发送方设置其发送窗口的依据。</li></ol><p>注：确认方ack = 发送方seq + 1<br><img src="/img/network/TCP%E9%A6%96%E9%83%A8.png" srcset="/img/loading.gif" alt="TCP首部"></p><h2 id="2-1-三次握手"><a href="#2-1-三次握手" class="headerlink" title="2.1 三次握手"></a>2.1 三次握手</h2><p><img src="/img/network/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" srcset="/img/loading.gif" alt="三次握手"></p><h3 id="2-1-1-流程"><a href="#2-1-1-流程" class="headerlink" title="2.1.1 流程"></a>2.1.1 流程</h3><ul><li>客户端—发送连接请求报文SYN=1，ACK=0，初始序号随机seq=x—服务端</li><li>服务端—发送连接确认报文SYN=1，ACK=1，确认号ack=x+1，初始序号随机seq=y—客户端</li><li>客户端—发出连接确认报文，ACK=1，确认号ack=y+1，序号seq=x+1</li></ul><h3 id="2-1-2-为什么要三次握手"><a href="#2-1-2-为什么要三次握手" class="headerlink" title="2.1.2 为什么要三次握手"></a>2.1.2 为什么要三次握手</h3><p>答：确保可靠的通信通道，<strong>让双方都确认对方和自己的接收和发送功能是正常的</strong>。</p><p>将三次握手通俗的说。</p><ol><li>第一次握手，Server知道Client的发送能力和自己的接收能力是正常的。</li><li>第二次握手，Client知道Server的发送和接收能力和自己的发送和接收能力是正常的，但是Server还不知道我的接收和他的发送能力正常与否。</li><li>第三次握手，Client回馈，让Server知道自己的发送能力和Client的接收能力正常。</li></ol><h3 id="2-1-3-为什么不是两次握手"><a href="#2-1-3-为什么不是两次握手" class="headerlink" title="2.1.3 为什么不是两次握手"></a>2.1.3 为什么不是两次握手</h3><p>答：<strong>防止失效连接请求报文段被服务端接收</strong>，避免浪费服务端资源。</p><p>例子：因为网络拥堵客户端重发连接请求进行通信，结束后释放连接。此时原来失效的请求到达服务端，直接进入 establish 状态，等待客户端的请求数据。但客户端早就关闭了，服务端会一直等待直到进行下面的操作。</p><h3 id="2-1-4-检测连接失效"><a href="#2-1-4-检测连接失效" class="headerlink" title="2.1.4 检测连接失效"></a>2.1.4 检测连接失效</h3><p>答：通过<strong>保活计时器和探测报文</strong>实现。</p><ul><li>TCP设有保活计时器，Server每收到一次Client的请求，就复位计时器，通常是设置为2小时；</li><li>若2小时内还没有收到Client的任何数据，Server每隔75s发送一个探测报文段，若连发10个探测报文仍没反应，Server认为Client故障，关闭连接。</li></ul><h2 id="2-2-四次挥手"><a href="#2-2-四次挥手" class="headerlink" title="2.2 四次挥手"></a>2.2 四次挥手</h2><p><img src="/img/network/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" srcset="/img/loading.gif" alt="四次挥手"></p><ul><li>Client状态变化：Fin-Wait-1 -&gt; Fin-Wait-2 -&gt; Time-Wait -&gt; Closed</li><li>Server状态变化：Close-Wait -&gt; Last-Ack -&gt; Closed</li></ul><h3 id="2-2-1-流程"><a href="#2-2-1-流程" class="headerlink" title="2.2.1 流程"></a>2.2.1 流程</h3><p>ACK在连接建立后都为1。</p><ul><li>客户端—发送连接释放报文FIN=1，序号(握手时初始序号 + 发送的字节数据数量 + 1)seq=u—服务器</li><li>服务器—发出确认收到报文ACK=1，确认序号ack=u+1，序列号(握手时初始序号 + 回复的字节数据)seq=v—客户端</li><li>服务器—关闭连接，发送连接释放报文FIN=1，确认序号ack=u+1，初始序号seq=w—客户端</li><li>客户端—发回确认收到报文ACK=1，确认序号seq=w+1，初始序号ack=u+1—服务器</li></ul><h3 id="2-2-2-为什么要四次挥手"><a href="#2-2-2-为什么要四次挥手" class="headerlink" title="2.2.2 为什么要四次挥手"></a>2.2.2 为什么要四次挥手</h3><p>答：<strong>Server端可能还有数据没有发送完毕</strong>。Client发出连接释放通知，Server确认收到后，Client就进入半关闭状态（只收消息不发消息），Server把未发完的数据发送完毕后，发送连接释放通知，Client确认后就关闭连接。</p><h3 id="2-2-3-为什么Client要等待2msl"><a href="#2-2-3-为什么Client要等待2msl" class="headerlink" title="2.2.3 为什么Client要等待2msl"></a>2.2.3 为什么Client要等待2msl</h3><p>答：<strong>防止ack报文丢失，Server再次发送Fin报文</strong>，一来一回最长时间就是2MSL(Maximum Segment Lifetime最大报文生存周期)。</p><h2 id="2-3-可靠传输"><a href="#2-3-可靠传输" class="headerlink" title="2.3 可靠传输"></a>2.3 可靠传输</h2><h3 id="2-3-1-超时重传"><a href="#2-3-1-超时重传" class="headerlink" title="2.3.1 超时重传"></a>2.3.1 超时重传</h3><p>答：若一个已经发送的报文段在超时时间内没有收到确认，就重传这个报文段。超时时间RTO略大于加权往返时间RTTs。往返时间RTT指一个报文段从发送再到接收到确认所经过的时间。</p><h3 id="2-3-2-ARQ自动重传"><a href="#2-3-2-ARQ自动重传" class="headerlink" title="2.3.2 ARQ自动重传"></a>2.3.2 ARQ自动重传</h3><p>答：ARQ包括停止等待ARQ和连续ARQ。</p><ul><li><strong>停止等待ARQ</strong>协议：基本原理是每发完一个分组就停止发送，等待对方确认，收到确认后再发送下一组，没有收到就重传。优点是简单，缺点是信道利用率低。总结：<strong>发完一个就停止，确认后再发下一个</strong></li><li><strong>连续ARQ</strong>协议：维持一个<strong>发送窗口</strong>，在窗口内的分组可以连续发送不用等待确认，接收方对到达的最后一个分组发送确认。优点是信道利用率高，缺点是发送方无法知道接收方正确收到的分组信息，重传需要回退N。总结：<strong>不用确认就能发，对last one确认，失败需要回退N</strong>。 <strong>流水线技术</strong></li><li>选择重传协议：若发送方接收重复确认，就判断下一个报文段丢失，就立即重传下一报文段。</li></ul><h3 id="2-3-3-滑动窗口"><a href="#2-3-3-滑动窗口" class="headerlink" title="2.3.3 滑动窗口"></a>2.3.3 滑动窗口</h3><p>答：发送方的滑动窗口大小根据接收方来设置，接收方通过tcp告知自己的滑动窗口大小。</p><ul><li>发送窗口的最左部为已发送但未收到确认的第一个字节，接收窗口的最左部为已发送确认并交付主机。</li><li>接收窗口只对最后一个按序到达的字节进行确认。如：收到31,34,35，只对31进行确认。<br><img src="/img/network/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png" srcset="/img/loading.gif" alt="滑动窗口"></li></ul><h3 id="2-3-4-流量控制"><a href="#2-3-4-流量控制" class="headerlink" title="2.3.4 流量控制"></a>2.3.4 流量控制</h3><p>答：流量控制是为<strong>控制发送方发送速率，保证接收方能及时接收</strong>。通过滑动窗口实现流量控制。</p><h3 id="2-3-5-拥塞控制"><a href="#2-3-5-拥塞控制" class="headerlink" title="2.3.5 拥塞控制"></a>2.3.5 拥塞控制</h3><p>答：拥塞控制是为了<strong>防止过多数据注入网络，导致网络过载</strong>。TCP的拥塞控制采用四个算法实现：慢开始、拥塞避免、快重传、快恢复。<br>发送方维护一个拥塞窗口(cwnd)的状态变量。<br><img src="/img/network/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png" srcset="/img/loading.gif" alt="拥塞避免"></p><ul><li><strong>慢开始</strong>：cwnd初始值为1，每个轮次cwnd加倍</li><li><strong>拥塞避免</strong>：慢开始门限ssthresh，当cwnd&gt;ssthresh时，进入拥塞避免，让cwnd每个轮次+1。出现超时，就令ssthresh = cwnd/2，重新进行慢开始。</li><li><strong>快重传</strong>：接收方只对最后一个收到的有序报文段进行确认，若发送方介绍重复确认，就判断下一个报文段丢失，执行快重传，即立即重传下一报文段。</li><li><strong>快恢复</strong>：若丢失个别报文段，执行快恢复，令ssthresh = cwnd/2, cwnd = ssthresh，直接进入拥塞避免。<br><img src="/img/network/%E5%BF%AB%E9%87%8D%E4%BC%A0.png" srcset="/img/loading.gif" alt="快重传"></li></ul><h2 id="2-4-基于TCP-UDP的协议"><a href="#2-4-基于TCP-UDP的协议" class="headerlink" title="2.4 基于TCP/UDP的协议"></a>2.4 基于TCP/UDP的协议</h2><ol><li>基于TCP</li></ol><ul><li>HTTP超文本传输协议，主要用于普通浏览。</li><li>HTTPS安全超文本传输协议，HTTP协议的安全版本。</li><li>FTP文件传输协议，用于文件传输。端口20/21。</li><li>POP3邮局协议，从服务器中检索获取邮件。客户端行为不会影响服务器中邮件状态。</li><li>SMTP简单邮件传输协议，用来发送和中转电子邮件。</li><li>TELNET远程登录，通过一个终端登陆到网络。</li><li>SSH，用于加密安全登陆。</li><li>IMAP，<strong>保持Client和Server上邮件的同步</strong>，让用户随时都能访问服务器的邮件，客户端行为能影响服务器邮件的状态。</li></ul><ol start="2"><li>基于UDP</li></ol><ul><li>BOOTP启动协议，应用于无盘设备。</li><li>NTP网络时间协议，用于网络同步。</li><li>DHCP动态主机配置协议，动态配置IP地址。</li></ul><ol start="3"><li>同时都有</li></ol><ul><li>DNS域名服务，用于完成地址查找，邮件转发等工作。端口53。</li></ul><h1 id="3-UDP"><a href="#3-UDP" class="headerlink" title="3. UDP"></a>3. UDP</h1><h2 id="3-1-UDP首部格式"><a href="#3-1-UDP首部格式" class="headerlink" title="3.1 UDP首部格式"></a>3.1 UDP首部格式</h2><p>答：UDP首部只有8个字节，包括源端口、目的端口、长度、检验和。<br><img src="/img/network/UDP%E9%A6%96%E9%83%A8.png" srcset="/img/loading.gif" alt="UDP首部"></p><h2 id="3-2-TCP和UDP区别"><a href="#3-2-TCP和UDP区别" class="headerlink" title="3.2 TCP和UDP区别"></a>3.2 TCP和UDP区别</h2><p><img src="/img/network/TCP%E5%92%8CUDP%E6%AF%94%E8%BE%83.png" srcset="/img/loading.gif" alt="TCPUDP比较"><br>答：总结下：</p><ul><li>TCP：面向连接的可靠交付，以字节流传输，效率低，耗费资源多，适用于对通信数据严格的场景，如文件传输。首部20-60字节。</li><li>UDP：无连接的尽最大努力交付，以数据报文段传输，速度快，耗费资源少，适用于对通信速度要求高的场景，如在线视频。首部8个字节。</li></ul><h2 id="3-3-为什么视频用UDP"><a href="#3-3-为什么视频用UDP" class="headerlink" title="3.3 为什么视频用UDP"></a>3.3 为什么视频用UDP</h2><ol><li>TCP需要三次握手，建立会话需要时间；</li><li>TCP在网络拥塞时，会调整滑动窗口大小，影响传输速度；</li><li>UDP无连接，没有拥塞控制，会以恒定速度发送数据，缺点是造成丢包，优点是实时性好。</li></ol><h2 id="3-4-UDP处理丢包"><a href="#3-4-UDP处理丢包" class="headerlink" title="3.4 UDP处理丢包"></a>3.4 UDP处理丢包</h2><ol><li>发生丢包，就立即发送冗余包，尽快恢复数据；</li><li>建立长期参考帧，解决连贯性问题；</li><li>发生网络抖动，降低码率，保证传输数据小于网络带宽。</li></ol><h1 id="4-HTTP"><a href="#4-HTTP" class="headerlink" title="4. HTTP"></a>4. HTTP</h1><p>答：HTTP超文本传输协议，是一种<strong>无状态的面向连接的</strong>协议，规定了Client和Server间通信的格式。</p><h2 id="4-1-长连接和短连接"><a href="#4-1-长连接和短连接" class="headerlink" title="4.1 长连接和短连接"></a>4.1 长连接和短连接</h2><p>答：HTTP协议的长连接和短连接，实质上就是TCP协议的长连接和短连接。</p><ul><li>HTTP/1.0默认使用短连接，即Client和Server每进行一次HTTP操作，就建立一次连接，任务结束就中断。</li><li>HTTP/1.1起默认使用长连接，网页打开后，Client和Server间传输数据的TCP连接不会关闭，之后再进行访问就直接用已建立的连接。</li></ul><h2 id="4-2-如何理解无状态"><a href="#4-2-如何理解无状态" class="headerlink" title="4.2 如何理解无状态"></a>4.2 如何理解无状态</h2><p>答：HTTP的无状态，指<strong>协议对于事务处理没有记忆能力，不对通信状态进行保存，服务器无法判断用户身份</strong>。即打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。</p><h2 id="4-3-如何保持会话状态"><a href="#4-3-如何保持会话状态" class="headerlink" title="4.3 如何保持会话状态"></a>4.3 如何保持会话状态</h2><ol><li><p><strong>Cookie和Session保存会话状态，用Session来唯一标识用户，用Cookie当作用户通行证</strong>。</p><p> 流程：</p><ul><li>服务端收到请求处理后生成一个SessionId，将SessionId存入Cookie返回给客户端，将Session内容存储在服务器上。</li><li>下一次请求时，客户端带着Cookie来请求服务器，服务端从Cookie中取出SessionId，从而实现用户会话状态的保持。</li></ul></li><li><p>第一次登陆后，<strong>服务端生成Token给客户端，客户端之后带着Token请求数据</strong>即可。减轻服务器的压力，减少频繁查询数据库。</p></li></ol><h2 id="4-4-Cookie，Session和Token"><a href="#4-4-Cookie，Session和Token" class="headerlink" title="4.4 Cookie，Session和Token"></a>4.4 Cookie，Session和Token</h2><p>答：都是用来跟踪用户身份的会话方式。</p><ul><li><strong>Cookie：在客户端保存用户信息</strong>，安全性较差，并且浏览器会限制cookie数量。eg. 保存登录用户信息，下次自动填写登录信息；登录网 站后访问其他页面就不用登录。</li><li><strong>Session：在服务端记录用户状态</strong>，安全性较高，但占用服务器性能。eg. 购物车添加物品，根据Session知道用户的购物车。</li><li><strong>Token：在客户端保存认证授权状态</strong>，适合前后端分离的项目(处于不同服务器)。</li></ul><h2 id="4-5-Get和Post区别"><a href="#4-5-Get和Post区别" class="headerlink" title="4.5 Get和Post区别"></a>4.5 Get和Post区别</h2><p>答：HTTP定义了四种基本方法：Get、Post、Put和Delete。</p><ul><li>Get用来从服务器 查询 获取资源，Post用来 更新/创建 服务器资源；</li><li><strong>Get</strong>将参数拼接在URL后，<strong>明文显示</strong>，Post用于提交表单，非明文显示；</li><li>Get有长度限制，Post没有。</li></ul><h2 id="4-6-HTTP和HTTPS的区别"><a href="#4-6-HTTP和HTTPS的区别" class="headerlink" title="4.6 HTTP和HTTPS的区别"></a>4.6 HTTP和HTTPS的区别</h2><p>答：总结为：</p><ul><li><strong>HTTP</strong>超文本传输协议，<strong>明文传输</strong>。默认<strong>80端口</strong>。安全性低。</li><li><strong>HTTPS=HTTP+SSL/TLS</strong>，<strong>加密传输</strong>。默认<strong>443端口</strong>。消耗资源多，需要证书。</li></ul><h3 id="4-6-1-SSL安全套接字层协议"><a href="#4-6-1-SSL安全套接字层协议" class="headerlink" title="4.6.1 SSL安全套接字层协议"></a>4.6.1 SSL安全套接字层协议</h3><p>答：利用数据加密，身份验证和消息完整性检测，保证数据传输完整性。建立在 TCP 和 应用层之间。</p><ol><li>身份验证机制：数字签名。</li><li>数据加密：对称密钥算法。</li><li>完整性验证：MAC算法。</li><li>利用非对称加密算法加密密钥保证第三方无法获得密钥。</li></ol><p>流程：</p><ol><li>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密，进行握手协商。</li><li>双方协商生成对话密钥(握手产生的三个随机数)。</li><li>双方采用对话密钥进行加密通信。</li></ol><h2 id="4-7-HTTP1-0，1-1和2-0的区别"><a href="#4-7-HTTP1-0，1-1和2-0的区别" class="headerlink" title="4.7 HTTP1.0，1.1和2.0的区别"></a>4.7 HTTP1.0，1.1和2.0的区别</h2><p>答：总结如下：</p><ul><li>HTTP1.0：默认短连接，每次请求都建立TCP连接，服务完成立即断开，开销大；错误状态响应码少；不支持断点续传。</li><li>HTTP1.1：默认长连接；增加了响应码和缓存策略；支持传输部分数据。</li><li>HTTP2.0：引入多路复用，通过一个TCP就能传输所有请求，提高性能。</li></ul><h2 id="4-8-常见的HTTP-状态码"><a href="#4-8-常见的HTTP-状态码" class="headerlink" title="4.8 常见的HTTP 状态码"></a>4.8 常见的HTTP 状态码</h2><p>答：粗略地看。<strong>1xx：临时响应/请求正在处理。2xx：成功。3xx：重定向。4xx：请求错误。5xx：服务器错误。</strong><br>常见的状态码有：</p><ul><li>200：成功。</li><li>302：临时重定向到指定网页。</li><li>304：not modified服务器允许访问资源，但请求未满足条件。</li><li>400：bad request，请求报文存在语法错误。</li><li>401：unauthorized未授权，要求身份验证。</li><li>403：forbidden禁止，服务器拒绝访问。</li><li>404：not found未找到，服务器找不到请求的网页。</li><li>405：方法禁用，Post当成Get。</li><li>502：服务器网关错误。</li><li>503：service unavailable，服务器超负荷或停机维护。</li><li>504：网关超时，nginx请求超时。</li></ul><h1 id="5-IP协议"><a href="#5-IP协议" class="headerlink" title="5. IP协议"></a>5. IP协议</h1><h2 id="5-1-IP数据报格式"><a href="#5-1-IP数据报格式" class="headerlink" title="5.1 IP数据报格式"></a>5.1 IP数据报格式</h2><p><img src="/img/network/IP%E6%95%B0%E6%8D%AE%E6%8A%A5.png" srcset="/img/loading.gif" alt="IP数据报"></p><ul><li>版本：有4(IPv4)和6(IPv6)两个值；</li><li>首部长度：最大值为15，最小值为5(固定部分长度为20字节)；</li><li>区分服务：一般不用，用来获得不同的服务；</li><li>总长度：首部长度 + 数据部分长度；</li><li>标识：若长度过长而分片，相同数据报的不同分片就有相同的标识符；</li><li>片偏移：8字节，用于分片情况。</li><li>生存时间：TTL，为了防止数据报一直滞留在网络中不消亡；</li><li>协议：指明携带的数据交给传输层的哪个协议处理；</li><li>首部检验和：数据报每经过一个路由器，都要重新计算检验和；</li></ul><p><img src="/img/network/%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87.png" srcset="/img/loading.gif" alt="数据报分片"></p><h2 id="5-2-IP地址编制方式"><a href="#5-2-IP地址编制方式" class="headerlink" title="5.2 IP地址编制方式"></a>5.2 IP地址编制方式</h2><h3 id="5-2-1-分类"><a href="#5-2-1-分类" class="headerlink" title="5.2.1 分类"></a>5.2.1 分类</h3><p>答：IP地址 = {&lt;网络号&gt;，&lt;主机号&gt;}。不同分类由不同的网络长度。<br><img src="/img/network/%E7%BD%91%E7%BB%9C%E5%8F%B7%E4%B8%BB%E6%9C%BA%E5%8F%B7.png" srcset="/img/loading.gif" alt="主机号"></p><h3 id="5-2-2-子网划分"><a href="#5-2-2-子网划分" class="headerlink" title="5.2.2 子网划分"></a>5.2.2 子网划分</h3><p>答：把主机号字段的一部分作为子网号。<strong>IP地址 = {&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</strong>。使用子网，必须要配置子网掩码。</p><p>eg. B类地址，默认子网掩码为255.255.0.0，若子类占2个字节，则子网掩码为255.255.192.0(8个1 8个1 11000000 8个0)。</p><h3 id="5-2-3-无分类"><a href="#5-2-3-无分类" class="headerlink" title="5.2.3 无分类"></a>5.2.3 无分类</h3><p>答：无分类编址<strong>CIDR消除了分类和子网的概念</strong>。<strong>IP地址 = {&lt;网络前缀号&gt;,&lt;主机号&gt;}</strong>。一个CIDR能表示原来多个网络，且只要一个路由项，这种使用网络前缀减少路由表项的方式就是构成超网。<br>eg. 128.14.35.7/20表示前20位为网络前缀。</p><h1 id="6-应用层其他协议"><a href="#6-应用层其他协议" class="headerlink" title="6. 应用层其他协议"></a>6. 应用层其他协议</h1><h2 id="6-1-FTP"><a href="#6-1-FTP" class="headerlink" title="6.1 FTP"></a>6.1 FTP</h2><p>FTP 文件传输协议，使用TCP连接，通过控制连接和数据连接来传送文件。FTP 需要保存用户状态，记录用户在远程的操作。</p><ul><li>控制连接：独立的tcp传输，传输 FTP 命令。端口号21；</li><li>数据连接：传送文件数据，端口号20。</li></ul><p>控制连接贯穿始终，数据连接随着一个文件的传输而建立，随着传输结束而关闭。</p><h2 id="6-2-电子邮件协议"><a href="#6-2-电子邮件协议" class="headerlink" title="6.2 电子邮件协议"></a>6.2 电子邮件协议</h2><h3 id="6-2-1-电子邮件系统"><a href="#6-2-1-电子邮件系统" class="headerlink" title="6.2.1 电子邮件系统"></a>6.2.1 电子邮件系统</h3><p>由 <strong>用户代理、邮件服务器和SMTP</strong> 三个核心组成。</p><p>流程类似：</p><ol><li>发送方通过用户代理将邮件传送到发送方的邮件服务器；</li><li>再传输到接收方的邮件服务器；</li><li>之后被转发到接收方的邮箱里；</li><li>接收方从邮件服务器里获取自己的邮件时需要通过邮件服务器的验证。</li></ol><h3 id="6-2-2-SMTP"><a href="#6-2-2-SMTP" class="headerlink" title="6.2.2 SMTP"></a>6.2.2 SMTP</h3><p>SMTP 简单邮件传输协议，是用来在邮件服务器间发送邮件报文的协议。端口25。</p><p>SMTP 理解为 Push 协议，即是客户将信息推到服务器端，且 SMTP 只能用 ASCII 码，并将所有报文对象都放在一个报文中。</p><h3 id="6-2-3-POP3"><a href="#6-2-3-POP3" class="headerlink" title="6.2.3 POP3"></a>6.2.3 POP3</h3><p>POP3 负责从邮件服务器中检索邮件，让用户读取。但无法解决客户端和服务端的邮件状态同步。</p><p>比如：用户在一台设备查看邮件后，邮件在服务端删除，其他设备无法查看。</p><h3 id="6-2-4-IMAP"><a href="#6-2-4-IMAP" class="headerlink" title="6.2.4 IMAP"></a>6.2.4 IMAP</h3><p>IMAP 能保持 Client 和 Server 上邮件的同步，让用户随时都能访问服务器的邮件。</p><p>原理是将邮件和收件人的INBOX 或 文件夹关联。</p><h2 id="6-3-DNS"><a href="#6-3-DNS" class="headerlink" title="6.3 DNS"></a>6.3 DNS</h2><p>DNS 域名系统由一个分布式数据库和一个主机查询应用层协议组成。能提供主机名和IP地址间的相互转换。端口号53，使用UDP传输。</p><p>DNS 采用分布式的设计方案，服务器分为根服务器、顶级服务器、二级服务器、以此类推。查询分为递归查询和迭代查询，除了请求主机到本地 DNS 服务器是递归，其他都是迭代。</p><h2 id="6-4-DHCP动态主机配置协议"><a href="#6-4-DHCP动态主机配置协议" class="headerlink" title="6.4 DHCP动态主机配置协议"></a>6.4 DHCP动态主机配置协议</h2><p>答：DHCP提供动态配置主机信息的功能，如IP地址、子网掩码、网关地址等。</p><p>流程：</p><ul><li>Client通过UDP发送Discover报文，被广播到子网的所有主机上(不在同个子网则中继代理)</li><li>Server收到报文，发送Offer报文给Client，其中包括Client需要的信息</li><li>Client可能收到多个Offer报文，选择某个Server的报文后，发送Request报文给对应Server</li><li>Server收到后，发送Ack报文，表示Client能使用其发送的信息</li></ul><p>理解为：客户端海投简历，拿了多个offer，最后只会跟一家签约。</p><h2 id="6-5-TELNET远程登录协议"><a href="#6-5-TELNET远程登录协议" class="headerlink" title="6.5 TELNET远程登录协议"></a>6.5 TELNET远程登录协议</h2><p>答：TELNET用于登录远程主机并将远程主机上的输出返回。</p><h1 id="7-网络层其余协议"><a href="#7-网络层其余协议" class="headerlink" title="7. 网络层其余协议"></a>7. 网络层其余协议</h1><h2 id="7-1-ARP地址解析协议"><a href="#7-1-ARP地址解析协议" class="headerlink" title="7.1 ARP地址解析协议"></a>7.1 ARP地址解析协议</h2><p>答：ARP地址解析协议的作用就是<strong>由IP地址获得MAC地址。</strong><br>实现：每个主机都有一个<strong>ARP缓存表</strong>，存着局域网内主机和路由器的IP地址到MAC地址的映射表。<br>流程：</p><ul><li>若主机A知道主机B的IP地址，但ARP缓存中没有该地址的MAC映射；</li><li>主机A通过广播发送ARP请求；</li><li>主机B收到请求后，发送ARP响应给主机A告知MAC地址；</li><li>主机A向自己的ARP缓存中写入主机B的IP地址到MAC地址的映射。<br><img src="/img/network/arp.png" srcset="/img/loading.gif" alt="arp"></li></ul><h2 id="7-2-ICMP网际控制报文协议"><a href="#7-2-ICMP网际控制报文协议" class="headerlink" title="7.2 ICMP网际控制报文协议"></a>7.2 ICMP网际控制报文协议</h2><p>答：ICMP网际控制报文协议，是为了<strong>更有效地转发IP数据报和提高交付能力</strong>，被封装在IP数据报中。分为差错报告报文和询问报文。</p><h3 id="7-2-1-ICMP报文格式"><a href="#7-2-1-ICMP报文格式" class="headerlink" title="7.2.1 ICMP报文格式"></a>7.2.1 ICMP报文格式</h3><p><img src="/img/network/icmp%E6%8A%A5%E6%96%87.png" srcset="/img/loading.gif" alt="icmp报文"></p><h3 id="7-2-2-ICMP应用"><a href="#7-2-2-ICMP应用" class="headerlink" title="7.2.2 ICMP应用"></a>7.2.2 ICMP应用</h3><ol><li>Ping</li></ol><ul><li>用来<strong>测试两台主机间的连通性</strong>。</li><li>原理是向目的主机发送<strong>ICMP Echo请求</strong>报文，目的主机收到后发送ICMP Echo回答报文。</li><li>Ping根据时间计算往返时间，根据成功的响应次数计算丢包率。</li></ul><ol start="2"><li>Traceroute</li></ol><ul><li>用来<strong>跟踪一个分组从源点到终点的路径</strong>。</li><li>原理是IP数据报封装的是无法交付UDP，设置TTL，每经过一个路由器TTL–，到达目的主机时向源主机发送ICMP终点不可达差错报文。源主机就知道一路上经过的路由器地址和往返时间。</li></ul><h2 id="7-3-NAT网络地址转换"><a href="#7-3-NAT网络地址转换" class="headerlink" title="7.3 NAT网络地址转换"></a>7.3 NAT网络地址转换</h2><p>答：NAT网络地址转换用来<strong>将本地IP转换为全球IP</strong>。NAPT让多个内网的主机共用一个全球IP。<br><img src="/img/network/nat.png" srcset="/img/loading.gif" alt="nat"></p><h2 id="7-4-路由选择"><a href="#7-4-路由选择" class="headerlink" title="7.4 路由选择"></a>7.4 路由选择</h2><p>路由器的功能是<strong>路由选择和分组转发</strong>。路由选择协议分为自治系统内部的路由选择(RIP,OSPF)和自治系统间(BGP)的路由选择。</p><h3 id="7-4-1-RIP路由信息协议"><a href="#7-4-1-RIP路由信息协议" class="headerlink" title="7.4.1 RIP路由信息协议"></a>7.4.1 RIP路由信息协议</h3><p>答：RIP协议是基于<strong>距离向量</strong>的路由选择协议。距离指<strong>跳数</strong>，超过15为不可达。</p><ul><li>原理：RIP协议让路由器按固定时间<strong>和相邻路由器交换路由表</strong>，经过若干次交换后，所有路由器都会知道自治系统中任何一个网络的最短距离和下一跳路由器地址。</li><li>优点：实现简单，开销小。</li><li>缺点：最大距离为15，限制了网络规模。</li></ul><h3 id="7-4-2-OSPF开放最短路径优先"><a href="#7-4-2-OSPF开放最短路径优先" class="headerlink" title="7.4.2 OSPF开放最短路径优先"></a>7.4.2 OSPF开放最短路径优先</h3><p>答：OSPF采用<strong>洪泛法</strong>向自治系统中<strong>和所有路由器发送链路状态信息</strong>，之后各自根据最短路径算法算出路由，放在OSPF路由表，OSPF路由与其他路由比较后优的加入全局路由表。</p><h3 id="7-4-3-BGP边界网关协议"><a href="#7-4-3-BGP边界网关协议" class="headerlink" title="7.4.3 BGP边界网关协议"></a>7.4.3 BGP边界网关协议</h3><p>答：BGP是一种用于AS自治系统间的动态路由协议，用于<strong>AS间交换路由信息</strong>。每个AS都要有一个BGP发言人，代表AS与其他AS交换信息。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>tcp</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RestFul API</title>
    <link href="/2020/04/28/RestFul-API/"/>
    <url>/2020/04/28/RestFul-API/</url>
    
    <content type="html"><![CDATA[<p>敏捷开发的一次课程内容，介绍 RESTFul 架构。</p><p>参考 阮一峰 <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a>，<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">RESTful API 设计指南</a></p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>REST 即 <code>Respresentational State Transfer</code>，<strong>(资源)表现层状态转化</strong>。若一个架构符合 REST 原则，则称为 RESTFul 架构。</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ol><li>资源</li></ol><p>所谓资源，理解为网络上的一个实体，可以是文本、图片、音频、服务，可以使用一个特定的 URI(统一资源定位符) 访问。</p><ol start="2"><li>表现层</li></ol><p>资源呈现出的形式称为表现层。比如文本可以用txt，也可以用json、html。</p><ol start="3"><li>状态转化</li></ol><p>HTTP是无状态的协议，客户端想操作服务器，必须要让服务端发生状态转化，这个前提是建立在表现层之上。具体手段就是HTTP中的GET、POST、PUT和DELETE。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RESTFul架构可以定义为：</p><ol><li>每一个URI代表一种资源；</li><li>C端和S端中间有传递资源的表现层；</li><li>客户端通过HTTP的4个动词，对服务端进行操作。</li></ol><h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><ol><li>协议：HTTP或HTTPS；</li><li>版本：将版本号放在HTTP头信息中或者URL中；</li><li>路径：只能有名词，返回集合的需要用复数形式；</li><li>动词：HTTP的四种 + PATCH(更新资源，改变部分属性)；</li><li>过滤：提供参数，过滤返回结果，只返回部分。limit、offset、page、perpage等；</li><li>状态码：HTTP协议提供的状态码；</li><li>Hypermedia API：返回结果中提供其他/相关的API方法；</li><li>数据格式：能用json用json，不能就xml或yaml。</li></ol>]]></content>
    
    
    <categories>
      
      <category>开发思想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Socket相关</title>
    <link href="/2020/04/28/Socket%E7%9B%B8%E5%85%B3/"/>
    <url>/2020/04/28/Socket%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>Socket的五种IO模型，Linux的唤醒回调机制以及IO复用的select、poll、epoll。</p><a id="more"></a><h1 id="1-IO模型"><a href="#1-IO模型" class="headerlink" title="1. IO模型"></a>1. IO模型</h1><p>Socket的输入操作有两步。</p><ol><li>wait for data - 等待网络传输数据到达，到达后复制到内核缓冲区；</li><li>copy data from kernel to user - 把数据从内核缓冲区复制到应用进程缓冲区。</li></ol><p>涉及到两个对象：application调用这个IO的进程/线程，kernel系统内核。</p><h2 id="1-1-同步阻塞IO"><a href="#1-1-同步阻塞IO" class="headerlink" title="1.1 同步阻塞IO"></a>1.1 同步阻塞IO</h2><p>用户线程发出请求后就一直被阻塞，直到数据到达并从内核缓冲区复制到进程缓冲区才返回。</p><p><img src="/img/network/%E9%98%BB%E5%A1%9E%E5%BC%8FIO.png" srcset="/img/loading.gif" alt="阻塞式IO"></p><h2 id="1-2-同步非阻塞IO"><a href="#1-2-同步非阻塞IO" class="headerlink" title="1.2 同步非阻塞IO"></a>1.2 同步非阻塞IO</h2><p>用户线程发出请求后，内核立即返回错误码，但用户线程需要不断发出IO请求询问内核数据到达没，到达了才进行第二阶段。这个过程叫做轮询。</p><p><img src="/img/network/%E9%9D%9E%E9%98%BB%E5%A1%9EIO.png" srcset="/img/loading.gif" alt="非阻塞IO"></p><h2 id="1-3-IO多路复用-异步阻塞IO"><a href="#1-3-IO多路复用-异步阻塞IO" class="headerlink" title="1.3 IO多路复用/异步阻塞IO"></a>1.3 IO多路复用/异步阻塞IO</h2><p>又称为事件驱动IO，单个进程有处理多个IO的能力，避免一个socket一个线程的开销和切换。<strong>用户注册多个socket，reactor一对多监听，不断调用select读取激活的socket，再通知对应用户进程进行第二阶段</strong>。<del>再一对多分发给对应处理器处理</del>。</p><p><img src="/img/network/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" srcset="/img/loading.gif" alt="IO多路复用"></p><p>使用了 Reactor 反应堆模型。</p><ul><li>将用户线程轮询IO操作状态的工作交给事件处理器，用户线程可以继续执行做其他的工作，Reactor线程负责调用内核的select函数检查socket状态。</li><li>当有socket被激活时，则通知相应的用户线程，执行handle_event进行数据读取、处理的工作。</li><li>由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。</li></ul><h2 id="1-4-信号驱动IO-异步非阻塞IO"><a href="#1-4-信号驱动IO-异步非阻塞IO" class="headerlink" title="1.4 信号驱动IO/异步非阻塞IO"></a>1.4 信号驱动IO/异步非阻塞IO</h2><p>sigaction系统调用，内核立即返回，应用进程可以去干其他事，<strong>数据到达后</strong>，内核发送SIGIO信号给应用进程<strong>通知应用进程可以进行第二阶段</strong>，IO的数据复制。</p><p>相比于轮询方式，CPU利用率更高。<br><img src="/img/network/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO.png" srcset="/img/loading.gif" alt="信号驱动IO"></p><h2 id="1-5-异步IO"><a href="#1-5-异步IO" class="headerlink" title="1.5 异步IO"></a>1.5 异步IO</h2><p>aio_read系统调用立即返回，应用进程可以去干其他事，内核在<strong>完成所有操作后，通知应用进程</strong>IO已经完成。<br><img src="/img/network/%E5%BC%82%E6%AD%A5IO.png" srcset="/img/loading.gif" alt="异步IO"></p><h2 id="1-6-比较"><a href="#1-6-比较" class="headerlink" title="1.6 比较"></a>1.6 比较</h2><ul><li>同步IO：将数据从内核缓冲区复制到应用进程缓冲区时，应用进程会阻塞。</li><li>异步IO：第二阶段不会阻塞。</li><li>阻塞IO：第一阶段就阻塞线程，直到获得数据。</li><li>非阻塞IO：线程发出请求立即返回，但需要轮询或者再次进行系统调用进行第二阶段。</li></ul><h1 id="2-wakeup-callback机制"><a href="#2-wakeup-callback机制" class="headerlink" title="2. wakeup callback机制"></a>2. wakeup callback机制</h1><p>Linux 内核的事件唤醒回调机制是IO多路复用的本质。</p><p>概括来说，Linux<strong>通过睡眠队列管理所有等待 Socket 事件的线程，通过 wakeup 机制异步唤醒整个睡眠队列上等待事件的线程，通知线程事件发生</strong>。</p><ol><li>睡眠等待<ul><li>select、poll、epoll 陷入内核，判断监控的 socket 是否有关心的事件发生，如果没，则为当前 process 构建一个 wait_entry 节点，插入到监控 socket 的 sleep_list；</li><li>进入循环的 schedule 直到关心的事件发生；</li><li>事件发生后，将当前线程的 wait_entry 节点从 socket 的 sleep_list 中删除。</li></ul></li><li>异步唤醒<ul><li>socket 顺序遍历其睡眠队列，依次调用每个节点的 callback 函数；</li><li>直到完成遍历或者遇到某个排他节点。</li></ul></li></ol><h1 id="3-IO复用机制"><a href="#3-IO复用机制" class="headerlink" title="3. IO复用机制"></a>3. IO复用机制</h1><p>fd 文件描述符，用于表述指向文件的引用的抽象化概念。</p><h2 id="3-1-select"><a href="#3-1-select" class="headerlink" title="3.1 select"></a>3.1 select</h2><p>底层通过一个long类型的数组 fd_set，存放文件句柄。</p><p>每次调用select时，把 fd_set 集合从用户态复制到内核态，在内核轮询遍历集合，且对集合有 1024 的大小限制。</p><p>内部的轮询，是通过为每个 socket 添加 poll 逻辑，用来收集该 socket 发生的事件。轮询就是遍历 socket 调用 poll 逻辑，直到有事件发生。</p><p>所以存在三个问题：</p><ol><li>fd 集合限制为 1024；</li><li>fd 集合每次都要从用户态拷贝到内核态；</li><li>每次都在遍历集合收集可读数据。</li></ol><h2 id="3-2-poll"><a href="#3-2-poll" class="headerlink" title="3.2 poll"></a>3.2 poll</h2><p>本质上和select一样，解决了 fd 集合大小限制问题。底层通过链表形式 pollfd 实现，所以没有最大连接数的限制。</p><p>其他两个缺点并没有改进，不适用大并发场景。</p><h2 id="3-3-epoll"><a href="#3-3-epoll" class="headerlink" title="3.3 epoll"></a>3.3 epoll</h2><p>只适用于Linux。</p><ol><li>针对集合拷贝。<ul><li>使用<strong>事件回调通知</strong>，通过 <strong>epoll_ctl() 注册fd进行增删改，调用 epoll_wait() 等待事件产生</strong>。</li><li>内核 2.6.8 之前底层使用哈希表存储，之后使用红黑树</li><li>epoll_wait() 通过<strong>将内核空间和用户空间(都是虚拟地址)映射到同一块物理内存地址</strong>，用来减少用户态和内核态间的数据交换。</li></ul></li><li>针对集合遍历。<ul><li>引入中间层，<strong>为每个 socket 提供单独的回调函数，当其就绪时将自身加入准备队列</strong> ready_list 中；</li><li><strong>等待线程的回调函数遍历 ready_list</strong> 上所有的 socket，调用 poll 逻辑收集事件，唤醒线程。</li></ul></li></ol><h3 id="3-3-1-工作模式"><a href="#3-3-1-工作模式" class="headerlink" title="3.3.1 工作模式"></a>3.3.1 工作模式</h3><ul><li>Level Triggered 水平触发。默认模式，只要fd还有事件，每次 epoll_wait() 都会再次通知进程。</li><li>Edge Triggered 边沿触发。通知之后进程必须立即处理事件，下次 epoll_wait() 不会收到该fd的通知。</li></ul><h2 id="3-4-比较"><a href="#3-4-比较" class="headerlink" title="3.4 比较"></a>3.4 比较</h2><p> 方式 |select | poll | epoll|<br>|—|—|—|—|<br>操作方式|遍历 |遍历|回调|<br>底层实现|数组| 链表|哈希表/红黑树|<br>最大连接数|1024 or 2048| 无上限|无上限|<br>IO效率|轮询O(n)|轮询O(n)|事件回调，将就绪的fd放进就绪队列，每次只用判断队列是否为空O(1)<br>fd拷贝|每次调用都把fd集合从用户态拷贝到内核态|每次调用都把fd集合从用户态拷贝到内核态|调用epoll_ctl()时fd拷贝进内核并保存</p><h2 id="3-5-适用场景"><a href="#3-5-适用场景" class="headerlink" title="3.5 适用场景"></a>3.5 适用场景</h2><ol><li>select的时间精度是微秒，适用实时性要求高的场景。</li><li>poll没有最大描述符限制，若实时性要求不高且平台支持，用poll。</li><li>epoll适用Linux平台，且有大量描述符需要同时轮询。</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2020/04/27/Redis/"/>
    <url>/2020/04/27/Redis/</url>
    
    <content type="html"><![CDATA[<p>总结了Redis的优缺点、数据类型、线程模式，持久化方式，过期策略，内存淘汰机制，事务实现，集群方案和缓存异常的集中情况，如缓存雪崩、击穿、穿透、降级等，简单说了分布式锁。</p><a id="more"></a><h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><h2 id="1-1-NoSQL"><a href="#1-1-NoSQL" class="headerlink" title="1.1 NoSQL"></a>1.1 NoSQL</h2><p>答：NoSQL(Not Only SQL)，泛指非关系型的数据库，目的是解决高并发、高拓展和大数据储存问题。细分为：键值型(Redis)，列存储(HBase)，文档型(MongoDB)，图形(Neo4j)。</p><h2 id="1-2-Redis"><a href="#1-2-Redis" class="headerlink" title="1.2 Redis"></a>1.2 Redis</h2><p>答：Redis(Remote Dictionary Server远程字典服务)是一款<strong>高性能、高并发</strong>的<strong>key-value型分布式内存数据库</strong>，基于内存运行且支持<strong>持久化</strong>的NoSQL数据库。常被用于缓存和消息队列。</p><h3 id="1-2-1-优缺点"><a href="#1-2-1-优缺点" class="headerlink" title="1.2.1 优缺点"></a>1.2.1 优缺点</h3><p>优点</p><ul><li>高性能/读写性能优异。用户第一次访问数据后，数据存储在缓存中，之后再访问直接从缓存中获得，相当于直接操作内存。</li><li>高并发。操作缓存能承受的请求远大于直接访问数据库，将部分数据放在redis中，能提高并发程度。</li><li>支持数据持久化，AOF和RDB两种方式。</li><li>支持事务，所有操作都是原子性的。</li><li>数据类型丰富，string、hash、set、list、sorted set。</li><li>支持集群模式，如主从复制做到读写分离。</li></ul><p>缺点</p><ul><li>数据库容量受到物理内存的限制；</li><li>不具备自动容错和恢复功能。如主机宕机，部分数据未能同步到从机，切换IP后会导致数据不一致；</li><li>扩容难。</li></ul><h3 id="1-2-2-为什么执行速度快"><a href="#1-2-2-为什么执行速度快" class="headerlink" title="1.2.2 为什么执行速度快"></a>1.2.2 为什么执行速度快</h3><p>答：总结如下：</p><ul><li>基于内存实现，轻量级数据库；</li><li>单线程操作，避免切换上下文，也没有线程安全问题；</li><li>多路IO复用模型，一个线程监控多个IO流，事件放队列，派发器分发，对应处理器处理。</li></ul><h3 id="1-2-3-Redis和map区别"><a href="#1-2-3-Redis和map区别" class="headerlink" title="1.2.3 Redis和map区别"></a>1.2.3 Redis和map区别</h3><p>答：缓存分为本地缓存和分布式缓存。</p><ul><li>map是本地缓存，优点是轻量快速，缺点是多实例情况下，每个实例都有一个缓存。</li><li>Redis是分布式缓存，多实例情况下，每个实例共用一个缓存，具有一致性，缺点是架构复杂。</li></ul><h3 id="1-2-4-Redis和memcached区别"><a href="#1-2-4-Redis和memcached区别" class="headerlink" title="1.2.4 Redis和memcached区别"></a>1.2.4 Redis和memcached区别</h3><p>答：主要是四点：</p><ul><li>Redis数据类型丰富，memcached只支持String类型；</li><li>Redis支持数据持久化，RDB和AOF，memcached全部存在内存；</li><li>Redis支持集群模式(主从，哨兵)，memcached没有原生的集群模式；</li><li>Redis是单线程的多路IO复用模型，memcached是多线程的非阻塞IO复用模型</li></ul><h2 id="1-3-数据类型和应用场景"><a href="#1-3-数据类型和应用场景" class="headerlink" title="1.3 数据类型和应用场景"></a>1.3 数据类型和应用场景</h2><p>答：支持五种数据类型作为value，key值都是字符串类型。</p><ul><li>string：最大为512M。用作计数器，缓存，用户的Session等；</li><li>list：有序列表，基于链表实现。用作分页查询，列表功能，消息队列/异步队列(左进右出)；</li><li>set：自动去重的列表。用作全局去重等功能，比如共同好友；</li><li>sorted set：多了权重参数。用来做排序，比如排行榜Top10功能，延时队列(时间戳做排序，内容做key，消费者根据score获取数据)；</li><li>hash：存储特定结构的信息/结构化数据。比如用户信息。</li><li>pub/sub：主题订阅者模式，实现1:N的消息队列，但消费者下线后，生产的消息就丢失了。</li></ul><h2 id="1-4-底层数据类型"><a href="#1-4-底层数据类型" class="headerlink" title="1.4 底层数据类型"></a>1.4 底层数据类型</h2><p>Redis底层的数据类型有</p><ol><li>动态字符串SDS：Redis封装的字符串，具有良好的伸缩性。O(1)获取字符串长度，空间预分配防止溢出。</li><li>链表：顺序存储对象信息，双端链表，保证无环。</li><li>字典：key-value 存储方式。通过hash值计算存储位置，使用拉链法解决哈希冲突，容量过大rehash重新分配。</li><li>跳跃表：sort set 的底层实现之一，基于多个有序链表实现。查找时，从上层指针开始，找到对应的区间后再到下一层查找。因为不用旋转维护平衡所以，插入速度比红黑树快。<br><img src="/img/db/%E8%B7%B3%E8%B7%83%E8%A1%A8%E6%9F%A5%E6%89%BE.png" srcset="/img/loading.gif" alt="跳跃表查找"></li><li>整数集合：只能存储少量整数数据的特殊集合。</li><li>压缩列表：为节约内存而存在的结构，当列表项为小整数或短字符串，就用压缩列表。列表键和哈希键的底层实现之一。</li></ol><h2 id="1-5-Redis线程模型"><a href="#1-5-Redis线程模型" class="headerlink" title="1.5 Redis线程模型"></a>1.5 Redis线程模型</h2><p>答：Redis是<strong>单线程</strong>的。</p><ul><li>内部使用了单线程的<strong>文件事件处理器</strong> file event handler。</li><li>采用<strong>IO多路复用</strong>机制同时监听多个socket，将socket上的事件放入队列，事件派发器每次从队列中取出一个事件，交给对应的事件处理器处理。</li><li>文件事件处理器包含4个部分：多个socket，IO多路复用程序，文件事件派发器，事件处理器。</li></ul><p>总结：<strong>一对多监听，事件放队列，派发器分发，对应处理器处理</strong></p><h1 id="2-持久化"><a href="#2-持久化" class="headerlink" title="2. 持久化"></a>2. 持久化</h1><p>答：把内存数据写入磁盘，保证宕机再重启数据能恢复。有RDB和AOF两种持久化方式。</p><h2 id="2-1-RDB-快照持久化"><a href="#2-1-RDB-快照持久化" class="headerlink" title="2.1 RDB-快照持久化"></a>2.1 RDB-快照持久化</h2><p>答：<strong>将内存中的数据集以快照形式写入磁盘，恢复时载入快照到内存。</strong> Redies<strong>默认采用</strong>。</p><h3 id="2-1-1-触发方式"><a href="#2-1-1-触发方式" class="headerlink" title="2.1.1 触发方式"></a>2.1.1 触发方式</h3><ul><li>自动触发：每隔多少秒，有多少数据发生变化，就自动触发持久化；</li><li>手动触发：bgsave命令，异步进行创建快照。</li></ul><h3 id="2-1-2-优缺点"><a href="#2-1-2-优缺点" class="headerlink" title="2.1.2 优缺点"></a>2.1.2 优缺点</h3><ul><li>优点：只有一个.rdb文件，恢复快，随时可以转移，性能好。</li><li>缺点：安全性差，没法实时持久化。(隔段时间持久化一次，频繁手动性能低)</li></ul><h3 id="2-1-3-原理"><a href="#2-1-3-原理" class="headerlink" title="2.1.3 原理"></a>2.1.3 原理</h3><ul><li>fork：redis通过创建子进程来进行RDB操作</li><li>cow：copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</li><li>当父进程要更改其中某片数据时（如执行一个写命令），操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的RDB文件存储的是执行fork一刻的内存数据。</li></ul><h2 id="2-2-AOF-增量持久化"><a href="#2-2-AOF-增量持久化" class="headerlink" title="2.2 AOF-增量持久化"></a>2.2 AOF-增量持久化</h2><p>答：<strong>将redis执行的所有写命令记录到日志文件中，恢复时将AOF文件载入内存。</strong>一般采用<strong>每秒钟同步一次</strong>everysec的方式。默认关闭，appendonly yes 开启配置。</p><h3 id="2-2-1-AOF重写"><a href="#2-2-1-AOF重写" class="headerlink" title="2.2.1 AOF重写"></a>2.2.1 AOF重写</h3><p>答：AOF文件随着服务器运行时间增长而越来越大，AOF重写能<strong>减小文件大小</strong>，而且<strong>数据库状态一致</strong>。</p><ul><li>读取数据库现有的键值对状态，<strong>用一条命令替代</strong>之前对键值对操作的<strong>多条命令</strong>，再用bgrewriteaof实现重写。</li><li>在<strong>子进程中执行</strong>。redis会维护一个AOF重写缓冲区，在子进程创建AOF期间，记录写命令；当子进程重写完成后，服务器将重写缓冲区内的内容添加到AOF文件的末尾，以保持状态一致。</li></ul><p>流程</p><ul><li>从主进程中fork出子进程，并拿到fork时的AOF文件数据写到一个临时AOF文件中</li><li>在重写过程中，redis收到的命令会同时写到AOF缓冲区和重写缓冲区中，这样保证重写不丢失重写过程中的命令</li><li>重写完成后通知主进程，主进程会将AOF缓冲区中的数据追加到子进程生成的文件中</li><li>redis会原子的将旧文件替换为新文件，并开始将数据写入到新的aof文件上</li></ul><p>总结：<strong>用个缓冲区，暂时存操作，完成重写后，再添文件末。</strong></p><h3 id="2-2-2-优缺点"><a href="#2-2-2-优缺点" class="headerlink" title="2.2.2 优缺点"></a>2.2.2 优缺点</h3><ul><li>优点：安全性好，秒级持久化。</li><li>缺点：需要更多的IO资源，AOF文件也较大，恢复慢；</li></ul><p>注：redis4.0后，支持RDB和AOF的混合持久化，RDB作为全量备份，AOF作为增量备份。</p><h1 id="3-过期策略和内存淘汰"><a href="#3-过期策略和内存淘汰" class="headerlink" title="3. 过期策略和内存淘汰"></a>3. 过期策略和内存淘汰</h1><p>Redis是键值型数据库，缓存的key总是会有过期时间，过期策略就是回收这些过期的key。</p><p>内存淘汰是在Redis缓存内存不足时，又有新写入，需要淘汰过期内存的策略。</p><p><strong>注：过期回收针对过期key，内存淘汰针对内存不足。</strong></p><h2 id="3-1-过期回收策略"><a href="#3-1-过期回收策略" class="headerlink" title="3.1 过期回收策略"></a>3.1 过期回收策略</h2><p>答：redis中的数据过期使用了<strong>定期删除和惰性删除相结合</strong>的方式。</p><ul><li>定期删除：redis默认每隔100ms就随机抽取一定量的数据判断是否过期，过期就删除；</li><li>惰性删除：在获取一个key时，redis会检查这个key是否过期，若过期则删除。</li></ul><p>如果定期删除漏掉很多过期key，用户也没及时去查，没用惰性删除，导致大量过期key积压在内存中，消耗资源，所以需要内存淘汰。</p><h2 id="3-2-内存淘汰-保存热点数据"><a href="#3-2-内存淘汰-保存热点数据" class="headerlink" title="3.2 内存淘汰/保存热点数据"></a>3.2 内存淘汰/保存热点数据</h2><h3 id="3-2-1-淘汰策略"><a href="#3-2-1-淘汰策略" class="headerlink" title="3.2.1 淘汰策略"></a>3.2.1 淘汰策略</h3><p>答：redis提供了6种数据淘汰策略。</p><p>设置过期时间的key</p><ul><li><strong>volatile-lru</strong>：用LRU算法移除设置了过期时间的key；</li><li><strong>volatile-ttl</strong>：移除设置了过期时间的有更早过期时间的key；</li><li><strong>volatile-random</strong>：随机移除设置了过期时间的key；</li></ul><p>全局的key</p><ul><li><strong>allkeys-lru</strong>：内存不足时，用LRU算法移除任意key；</li><li><strong>allkeys-random</strong>：随机移除任意key；</li><li><strong>no-eviction</strong>：不移除任何key，只返回错误信息。默认。</li></ul><h3 id="3-2-2-回收流程"><a href="#3-2-2-回收流程" class="headerlink" title="3.2.2 回收流程"></a>3.2.2 回收流程</h3><ol><li>客户端执行新命令</li><li>Redis检查内存使用情况，大于maxmemory则按设定的内存淘汰策略回收内存</li><li>继续执行命令</li></ol><h1 id="4-事务"><a href="#4-事务" class="headerlink" title="4. 事务"></a>4. 事务</h1><h2 id="4-1-Redis事务"><a href="#4-1-Redis事务" class="headerlink" title="4.1 Redis事务"></a>4.1 Redis事务</h2><p>答：redis事务本质是通过MULTI、EXEC、WATCH和DISCARD等一组命令集合执行。执行过程是<strong>一次性的</strong>(不会中断一直运行)，<strong>顺序性的</strong>(串行化执行)，<strong>排他性的</strong>(不会在中间插入别的命令)。</p><h2 id="4-2-相关命令"><a href="#4-2-相关命令" class="headerlink" title="4.2 相关命令"></a>4.2 相关命令</h2><ul><li>MULTI：标记一个事务块的开始。</li><li>EXEC：执行所有事务块内的命令。</li><li>DISCARD：取消事务，放弃执行事务块内的所有命令。</li><li>UNWATCH：取消 WATCH 命令对所有 key 的监视。</li><li>WATCH key [key …]：监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</li></ul><h2 id="4-3-内部实现"><a href="#4-3-内部实现" class="headerlink" title="4.3 内部实现"></a>4.3 内部实现</h2><ol><li>redis<strong>不支持回滚，不保证原子性</strong>，事务失败也继续执行。</li><li>单条命令是原子性，但整个事务不是原子性。</li><li>命令语法错误或操作类型不规范才停止执行。</li></ol><h1 id="5-集群方案"><a href="#5-集群方案" class="headerlink" title="5. 集群方案"></a>5. 集群方案</h1><h2 id="5-1-主从复制机制"><a href="#5-1-主从复制机制" class="headerlink" title="5.1 主从复制机制"></a>5.1 主从复制机制</h2><p>答：主从(Master-Slave)机制，主机以写为主，从机以读为主，有效避免单点故障导致的数据丢失，主从数据库的数据实时同步。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol><li>从数据库启动，向主数据库发送同步请求；</li><li>主数据库收到后，进行RDB快照，并将快照过程中的收到命令缓存起来；</li><li>快照完成后，将.rdb文件和所有缓存的命令发给从数据库；</li><li>从数据库收到后，进行快照同步并执行收到的缓存命令。<br><img src="/img/db/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></li></ol><h2 id="5-2-哨兵模式"><a href="#5-2-哨兵模式" class="headerlink" title="5.2 哨兵模式"></a>5.2 哨兵模式</h2><p>答：哨兵(Sentinel)模式，用于管理多个Redis服务器。哨兵至少需要3个实例才能保持健壮性。一般都使用哨兵 + 主从架构保证<strong>高可用</strong>。</p><h3 id="5-2-1-功能"><a href="#5-2-1-功能" class="headerlink" title="5.2.1 功能"></a>5.2.1 功能</h3><p>主要有三个功能：</p><ul><li><strong>监控</strong>：哨兵会不断检查主机和从机是否运行正常；</li><li><strong>通知</strong>：当被监控的某个redis发生问题，哨兵会发送通知；</li><li><strong>故障迁移</strong>：当主机不能正常工作，哨兵会选择主机的一个从机升级为主机，让其他从机改为复制新主机。旧主机复活时，将其变为新主机的从机，最后向客户端通知主机的变化。</li></ul><h3 id="5-2-2-节点下线"><a href="#5-2-2-节点下线" class="headerlink" title="5.2.2 节点下线"></a>5.2.2 节点下线</h3><ul><li>主观下线：哨兵认为此redis节点发生了故障，就主观下线该节点。通过心跳包检测实现。</li><li>客观下线：所有哨兵中的多数(&gt;quorum)认为此redis节点主观下线，则该节点客观下线。</li></ul><h3 id="5-2-3-Leader选举"><a href="#5-2-3-Leader选举" class="headerlink" title="5.2.3 Leader选举"></a>5.2.3 Leader选举</h3><p>故障转移时，需要哨兵选出一个leader进行后续操作。</p><p>流程为：每个主管下线的哨兵向其他哨兵发出设置他为Leader的命令，当票数达到设定值时，称为领导者。若有多个哨兵当选Leader，则等待一段时间再选举。<br><img src="/img/db/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" srcset="/img/loading.gif" alt=""></p><h1 id="6-分布式锁"><a href="#6-分布式锁" class="headerlink" title="6. 分布式锁"></a>6. 分布式锁</h1><p>当多客户端并发操作Redis，可能出现并发竞争，需要分布式锁帮助管理顺序。</p><h2 id="6-1-实现"><a href="#6-1-实现" class="headerlink" title="6.1 实现"></a>6.1 实现</h2><ul><li>用 setnx (set if not exists)争抢锁。key不存在就设为value，存在不做动作。</li><li>抢到后，用 expire 给锁加一个过期时间防止锁忘记了释放。</li><li>可以通过参数将setnx和expire合成一条指令。</li></ul><h2 id="6-2-举例"><a href="#6-2-举例" class="headerlink" title="6.2 举例"></a>6.2 举例</h2><ol><li>每个系统通过 Zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个Key。</li><li>写入/查询MySQL时必须保存一个时间戳，每次都要判断当前 Value 的时间戳是否比缓存里的 Value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</li></ol><h1 id="7-缓存异常"><a href="#7-缓存异常" class="headerlink" title="7. 缓存异常"></a>7. 缓存异常</h1><h2 id="7-1-缓存雪崩"><a href="#7-1-缓存雪崩" class="headerlink" title="7.1 缓存雪崩"></a>7.1 缓存雪崩</h2><p>答：缓存雪崩是指缓存同一时间大面积失效，这时有一波请求访问数据库，导致数据库崩掉。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>事前：保证redis服务器的高可用，发现宕机就立马补上，内部选择恰当的内存淘汰机制，设置随机的key失效时间(保证不会同时大面积失效)；</li><li>事中：本地ehcache缓存 + 限流和降级处理，避免数据库崩溃；</li><li>事后：redis持久化尽快恢复缓存数据。<br><img src="/img/db/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></li></ul><h2 id="7-2-缓存穿透"><a href="#7-2-缓存穿透" class="headerlink" title="7.2 缓存穿透"></a>7.2 缓存穿透</h2><p>答：故意请求不在缓存也不在数据库中的数据，导致大量请求直接打到数据库上，导致崩溃。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>参数校验：将不合法的参数请求直接抛异常。</li><li>缓存无效key：若缓存和数据库都查不到数据，就写一个到redis中并设置过期时间。</li><li><strong>布隆过滤器</strong>：把所有可能的请求值放在布隆过滤器中，用户请求时先判断是否存在，不存在直接返回错误信息。<br><img src="/img/db/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F+%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></li></ul><h2 id="7-3-缓存击穿"><a href="#7-3-缓存击穿" class="headerlink" title="7.3 缓存击穿"></a>7.3 缓存击穿</h2><p>答：缓存击穿是指缓存中没有但数据库中有的数据，同时大并发去数据库查询同一条数据，导致崩溃。比如缓存热点数据key失效后的处理。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>设置热点数据永不过期</li><li>对缓存查询加互斥锁。key不存在就加锁查DB写缓存，然后解锁；其他进程发现有锁就等待，等解锁后从缓存中拿数据。</li></ul><h2 id="7-4-缓存降级"><a href="#7-4-缓存降级" class="headerlink" title="7.4 缓存降级"></a>7.4 缓存降级</h2><p>答：缓存降级是指服务出现问题或非核心服务影响到核心流程的性能时，弃车保帅，保证核心服务可用，即使是有损服务。</p><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>必须对系统进行梳理排序，从而确定可以降级的模块。</li><li>一般对不重要的缓存数据，可以直接返回默认值，而不去访问数据库。</li></ul><h2 id="7-5-双写一致性"><a href="#7-5-双写一致性" class="headerlink" title="7.5 双写一致性"></a>7.5 双写一致性</h2><p>答：高并发情况下很容易因为操作失败而导致数据不一致。</p><h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p>强一致性：<strong>读写请求串行化</strong>，每次只能进行一个操作，保证数据库和缓存时刻相同。</p></li><li><p>最终一致性：数据库和缓存可以存在不一致的情况。</p><ul><li><strong>双删延迟</strong>：先删除缓存数据，再更新数据库数据，最后隔段时间再删除缓存。</li><li>原理：如果数据库更新失败，那么数据库中是旧数据，缓存中是空的，数据不会不一致。因为读的时候没有缓存，所以去读了数据库中的旧数据，然后更新到缓存中。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合</title>
    <link href="/2020/04/27/Java%E9%9B%86%E5%90%88/"/>
    <url>/2020/04/27/Java%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>详细介绍Java的常见集合，包括HashMap、ArrayList的一系列问题，以及介绍快速失败和安全失败机制。</p><p>参考CSDN、掘金的相关帖子和1.8源码。</p><a id="more"></a><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><h2 id="1-1-List-Set-Map区别"><a href="#1-1-List-Set-Map区别" class="headerlink" title="1.1 List,Set,Map区别"></a>1.1 List,Set,Map区别</h2><p>答：Java容器分为Collection和Map两大类。List和Set是Collection的子接口。</p><ul><li>List（解决顺序问题）：存储一组有序可重复的对象，实现类有ArrayList、LinkedList和Stack等。</li><li>Set（元素独一无二）：不存在重复的元素，实现类有HashSet、TreeSet等。</li><li>Map（Key值搜索）：键值对存储，Key值不能重复，但能引用相同的对象，实现类有HashMap、ConcurrentHashMap等。</li></ul><h2 id="1-2-快速失败"><a href="#1-2-快速失败" class="headerlink" title="1.2 快速失败"></a>1.2 快速失败</h2><p>答：快速失败(fail-fast)是Java集合中的<strong>错误检测机制</strong>。遍历集合过程中，若线程对集合进行增删改，会抛出并发修改异常。</p><p>原理</p><ul><li>迭代器遍历过程中，使用一个modCount变量。若集合在遍历期间发生改变，modCount就会变化。hasNext()前都会检测modCount变量是否为exceptedModCount值，不是就抛出异常。</li><li>无法处理并发。</li><li>可以在所有涉及改变modCount的地方加synchronized同步锁避免fail-fast。</li></ul><p>还可以将其理解为一种设计原则，当有某种条件导致模块无法正常运行，就立即终止运行，避免下游脏数据/便于排查。</p><h2 id="1-3-安全失败"><a href="#1-3-安全失败" class="headerlink" title="1.3 安全失败"></a>1.3 安全失败</h2><p>答：安全失败(fail-safe)的集合(JUC包)是多线程下使用的。遍历前先拷贝原有集合内容，在拷贝的集合上遍历。</p><ul><li>迭代时是对拷贝集合操作，不会出现并发修改异常；</li><li>无法保证读取的数据是最新的数据。(迭代器只有开始遍历时才拿到拷贝，之后原数据发生变动是不知道的)</li></ul><p>还可以理解为一种设计原则，当模块遇到错误，不终止执行，而是采用降级策略，尽量往下走。适用于主模块的分支流程。</p><h1 id="2-Map接口"><a href="#2-Map接口" class="headerlink" title="2.Map接口"></a>2.Map接口</h1><h1 id="2-Map接口-1"><a href="#2-Map接口-1" class="headerlink" title="2.Map接口"></a>2.Map接口</h1><h2 id="2-1-HashMap"><a href="#2-1-HashMap" class="headerlink" title="2.1 HashMap"></a>2.1 HashMap</h2><p>答：HashMap是基于Hash算法实现的由数组和链表组合的数据结构，允许使用null值和null键。</p><p>总结：用数组存储，将冲突的key对象放入链表中，再发生冲突就在链表中顺序做对比。</p><h3 id="2-1-1-插入元素"><a href="#2-1-1-插入元素" class="headerlink" title="2.1.1 插入元素"></a>2.1.1 插入元素</h3><p>根据源码是 putVal() 进行添加元素的操作。</p><ul><li>利用key的hashCode计算出当前对象的元素在数组中的下标；</li><li>如果位置上没有元素，就直接插入；</li><li>如果位置上有元素，则比较key，若key相同，则覆盖原始值；若key不同，先判断是否是树节点，是就用 putTreeVal() 添加元素，不是就拉链法插入链表。</li><li>若插入后链表长度 &gt; 8，转成红黑树或者扩容。</li></ul><ol><li>java8前用头插法，新来的值代替原有值，原有值被往后推。问题是，扩容后容易形成环形链表。</li><li>java8后用尾插法。在扩容同时保证链表元素原来的顺序，避免形成环。</li></ol><h3 id="2-1-2-读取元素"><a href="#2-1-2-读取元素" class="headerlink" title="2.1.2 读取元素"></a>2.1.2 读取元素</h3><ul><li>get元素时，找hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li></ul><h3 id="2-1-3-多线程"><a href="#2-1-3-多线程" class="headerlink" title="2.1.3 多线程"></a>2.1.3 多线程</h3><p>答：hashmap线程不安全。put/get方法没有同步锁，容易出现上一秒put值，下一秒get的还是原值。</p><h3 id="2-1-4-初始化"><a href="#2-1-4-初始化" class="headerlink" title="2.1.4 初始化"></a>2.1.4 初始化</h3><ul><li>new HashMap() 不传值，默认为16，负载因子为0.75。</li><li>传k，则为 <code>大于k的2的整数次方</code>。比如传10，大小为16。</li></ul><h3 id="2-1-5-hash函数设计"><a href="#2-1-5-hash函数设计" class="headerlink" title="2.1.5 hash函数设计"></a>2.1.5 hash函数设计</h3><p>拿到 key 的32位 hashCode，将<strong>hashCode高16位与低16位异或</strong>。</p><ol><li>降低哈希碰撞，混合高半区和低半区的特征，加大低区随机性；</li><li>之后与 length-1，进行与运算，获得最低的 x 位，即下标。</li></ol><h2 id="2-2-HashMap和HashTable的区别"><a href="#2-2-HashMap和HashTable的区别" class="headerlink" title="2.2 HashMap和HashTable的区别"></a>2.2 HashMap和HashTable的区别</h2><ol><li>线程安全：HashMap线程不安全；HashTable内部使用synchronized关键字，线程安全。</li><li>Null Key支持：HashMap中null可作为Key；HashTable中null不能作key也不能作value。</li><li>效率：HashMap比HashTable效率高一点，而且HashTable基本淘汰了。</li><li>初始容量：HashMap是16，HashTable是11。</li><li>扩容机制：HashMap是当前容量翻倍，Hashtable是当前容量翻倍+1。</li></ol><h3 id="2-2-1-为什么HashTable的null不能做key和value"><a href="#2-2-1-为什么HashTable的null不能做key和value" class="headerlink" title="2.2.1 为什么HashTable的null不能做key和value"></a>2.2.1 为什么HashTable的null不能做key和value</h3><p>答：两点原因。</p><ul><li>HashTable在put空值时会抛空指针异常。HashMap做了三目运算的处理，null就设0。</li><li>安全失败机制。让此次读取的数据不一定是最新，同时key为null就无法判断key是不存在还是空。</li></ul><h3 id="2-2-2-线程不安全"><a href="#2-2-2-线程不安全" class="headerlink" title="2.2.2 线程不安全"></a>2.2.2 线程不安全</h3><ul><li>HashMap线程不安全。因为多线程环境下扩容，导致hash规则变化，可能形成环形链表，死循环。多线程下数据覆盖问题，A线程判断index为空挂起，B线程写入index，这时A线程恢复线程，进行赋值操作，把B线程数据覆盖。</li><li>HashTable线程安全。因为内部实现put和remove方法时使用synchronized同步，所以对单个方法的使用是线程安全的。但对多个方法复合操作时，无法保证安全性。</li></ul><h2 id="2-3-HashMap的底层结构"><a href="#2-3-HashMap的底层结构" class="headerlink" title="2.3 HashMap的底层结构"></a>2.3 HashMap的底层结构</h2><p>答：JDK1.8之前，用数组+链表用链地址法实现。所谓拉链法，就是数组链表，数组的每一格就是一个链表，遇到哈希冲突，则将冲突值加入链表。</p><p>JDK1.8之后使用数组+链表+红黑树实现，解决链表过长而查询速度变慢。<br><img src="/img/java/HashMap.png" srcset="/img/loading.gif" alt="HashMap"></p><p>流程：</p><ul><li>hash后算出下标，没有冲突就直接放进node；</li><li>有冲突，链地址法，用链表链接相同hash值的数据；</li><li>链表长度&gt;8且数组长度&lt;64，先进行扩容；</li><li>链表长度&gt;8且数组长度&gt;64，转为红黑树，加速遍历。</li></ul><h2 id="2-4-扩容"><a href="#2-4-扩容" class="headerlink" title="2.4 扩容"></a>2.4 扩容</h2><p>答：HashMap的<strong>初始容量16，加载因子0.75，扩容增量是原容量的1倍</strong>。HashMap中的元素个数超过 初始容量16 * 加载因子0.75 = 12 后进行扩容。扩容分为两步。</p><ul><li>创建新数组：创建原来HashMap大小两倍的bucket数组。</li><li>ReHash：遍历原数组，将对象重新hash后放入新数组中。</li></ul><h3 id="2-4-1-为啥要rehash"><a href="#2-4-1-为啥要rehash" class="headerlink" title="2.4.1 为啥要rehash"></a>2.4.1 为啥要rehash</h3><p>答：因为长度扩大后，hash规则也改变。key &amp; (length-1)</p><ul><li>1.8 前，需要重新hash计算在新数组的位置；</li><li>1.8 后，只需要逻辑判断，位置不变或者索引+原容量大小。</li></ul><blockquote><p>扩容是两倍大小，所以相当于 01111 -&gt; 11111，高位为0，则hash值不变，高位为1，则hash值为原索引+16。</p></blockquote><h3 id="2-4-2-长度为什么是2的幂-初始长度为什么是16"><a href="#2-4-2-长度为什么是2的幂-初始长度为什么是16" class="headerlink" title="2.4.2 长度为什么是2的幂/初始长度为什么是16"></a>2.4.2 长度为什么是2的幂/初始长度为什么是16</h3><p>答：有助于减少碰撞次数，提高查询效率。 </p><ul><li><strong>hash%length == hash&amp;(length-1)的前提是 length 是2^n</strong>。</li><li>扩容后也能降低计算新的下标的复杂度。</li></ul><p>eg.一个key的hash在第5位，为0则扩容后，位置不变，为1则扩容后，原位置+16。</p><ul><li>2的幂时，length-1所有位都是1，哈希结果等同hashCode后四位的值，只要hashcode本身均匀，hash结果就均匀。即实现均匀分布。</li></ul><p>eg.length为15，则length-1为14，对应二进制为1110，进行与操作后，最后一位为0，则最后一位为1的位置都不能存放元素。</p><h3 id="2-4-3-加载因子为什么是0-75"><a href="#2-4-3-加载因子为什么是0-75" class="headerlink" title="2.4.3 加载因子为什么是0.75"></a>2.4.3 加载因子为什么是0.75</h3><p>从结果来推导，加载因子为0.75时，能保证和任何2的幂乘积结果都是整数，即负载因子*容量的结果是一个整数，</p><h2 id="2-5-一致性哈希"><a href="#2-5-一致性哈希" class="headerlink" title="2.5 一致性哈希"></a>2.5 一致性哈希</h2><p>答：就是哈希环。服务器平均放环上，一个服务器负责自己顺时针的一片hash区域上的对象。通过增加虚拟节点防止hash环偏移。</p><h2 id="2-6-ConcurrentHashMap"><a href="#2-6-ConcurrentHashMap" class="headerlink" title="2.6 ConcurrentHashMap"></a>2.6 ConcurrentHashMap</h2><ul><li><strong>底层数据结构</strong>：ConcurrentHashMap是数组+链表+红黑树</li><li><strong>实现线程安全</strong>：</li></ul><ol><li><p>在JDK1.8之前，ConcurrentHashMap使用分段锁将Hash表分割为16个桶，每个分段锁维护着几个桶，多线程访问不同分段锁上的桶，提高并发度。(并发度就是分段锁个数)<br><img src="/img/java/Segment.png" srcset="/img/loading.gif" alt="Segment"></p></li><li><p>在JDK1.8之后，使用Node数组+链表+红黑树的数据结构，并发控制用synchronized和CAS操作。</p></li></ol><p><strong>synchronized锁定当前链表/红黑树的头节点，只要hash不碰撞，就不会并发</strong>，效率大幅提升。</p><p><img src="/img/java/ConcurrentHashMap.png" srcset="/img/loading.gif" alt="ConcurrentHashMap"></p><h3 id="2-6-1-put操作流程"><a href="#2-6-1-put操作流程" class="headerlink" title="2.6.1 put操作流程"></a>2.6.1 put操作流程</h3><ul><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。</li><li>如果都不满足，则利用 synchronized 锁写入数据。</li><li>如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。</li></ul><h3 id="2-6-2-get操作流程"><a href="#2-6-2-get操作流程" class="headerlink" title="2.6.2 get操作流程"></a>2.6.2 get操作流程</h3><ul><li>根据算出的hashcode寻址，在桶上就直接返回值。</li><li>如果是红黑树，就按树的方式获取值。</li><li>都不满足，就是按链表遍历获取值。</li></ul><h3 id="2-6-3-为什么用synchronized"><a href="#2-6-3-为什么用synchronized" class="headerlink" title="2.6.3 为什么用synchronized"></a>2.6.3 为什么用synchronized</h3><p>答：JAVA8优化了同步锁，最初都是轻量级锁慢慢升级为重量级锁。</p><ul><li>先用偏向锁，优先同一线程获取锁。</li><li>失败，就升级为CAS，失败后短暂自旋。</li><li>都失败，就升级为重量级锁。</li></ul><h2 id="2-7-LinkedHashMap和LinkedHashSet"><a href="#2-7-LinkedHashMap和LinkedHashSet" class="headerlink" title="2.7 LinkedHashMap和LinkedHashSet"></a>2.7 LinkedHashMap和LinkedHashSet</h2><p>答：</p><ul><li>LinkedHashMap能记录元素的插入顺序和访问顺序。</li></ul><p>具体实现：</p><ol><li>内部通过<strong>双向链表</strong>，保证元素的插入顺序。</li><li>accessOrder默认为false，维护插入顺序，若为true，指定LRU(最近最少使用)顺序。</li><li>afterNodeAccess() 节点被访问后，将该节点移到链表末尾，保证链表首部为最近最久未使用节点；</li><li>afterNodeInsertion() 移除最近最久未使用节点，保证缓存空间足够。</li></ol><ul><li>LinkedHashSet底层使用LinkedHashMap实现。</li><li>二者关系类似HashMap和HashSet。</li></ul><h2 id="2-8-HashSet-HashMap和TreeSet区别"><a href="#2-8-HashSet-HashMap和TreeSet区别" class="headerlink" title="2.8 HashSet,HashMap和TreeSet区别"></a>2.8 HashSet,HashMap和TreeSet区别</h2><p>答：总结如下：</p><ul><li>HashMap底层使用Hash表实现，通过元素的hashCode值和equals()方法保证元素唯一性；</li><li>TreeSet底层使用红黑树实现，通过comparable或comparator接口保证元素唯一性；</li><li>HashSet底层是基于HashMap实现的，基本都是调用hashmap的方法。</li></ul><h2 id="2-9-TreeMap-红黑树"><a href="#2-9-TreeMap-红黑树" class="headerlink" title="2.9 TreeMap/红黑树"></a>2.9 TreeMap/红黑树</h2><p>TreeMap存储键值对，底层是红黑树，可以实现元素的自动排序。了解 TreeMap 必须理解红黑树！</p><p>红黑树是一种二叉搜索树，也是均衡二叉树，当不满足红黑树规则时，自动调整节点平衡。</p><p>规则有：</p><ul><li>节点分为红色和黑色；</li><li>根节点必为黑色；</li><li>叶子节点都为黑色，且都为null；</li><li>连接红色节点的两个子节点都为黑色，即不出现相邻的红色节点；</li><li>从任意节点出发，到任意叶子节点的路径中包含相同数量的黑色节点；</li><li>新加入红黑树的节点都是红色节点。</li></ul><p>维持平衡的方式：变色，左旋，右旋。<a href="https://www.cnblogs.com/LiaHon/p/11203229.html/" target="_blank" rel="noopener">具体操作</a></p><h1 id="3-List接口"><a href="#3-List接口" class="headerlink" title="3. List接口"></a>3. List接口</h1><h2 id="3-1-迭代器Iterator"><a href="#3-1-迭代器Iterator" class="headerlink" title="3.1 迭代器Iterator"></a>3.1 迭代器Iterator</h2><p>答：Iterator是为了实现<strong>遍历Collection的接口</strong>。相当于把一个Collection容器的所有对象，做成一个线性表（List），而iterator本身是一个指针，开始时位于第一个元素之前。有三个主要方法：hasNext(),next(),remove()。</p><h3 id="3-1-1-Iterator和ListIterator区别"><a href="#3-1-1-Iterator和ListIterator区别" class="headerlink" title="3.1.1 Iterator和ListIterator区别"></a>3.1.1 Iterator和ListIterator区别</h3><p>答：区别如下：</p><ul><li>Iterator能遍历list和set集合；ListIterator只能遍历list集合。</li><li>Iterator只能后向遍历；ListIterator是双向遍历。</li><li>ListIterator也是继承了Iterator，再添加新的功能。</li></ul><h2 id="3-2-数组和List的转换"><a href="#3-2-数组和List的转换" class="headerlink" title="3.2 数组和List的转换"></a>3.2 数组和List的转换</h2><p>答：Arrays.asList和List.toArray方法。注意事项:</p><ol><li>Arrays.asList()<ul><li>转换后，不能修改集合，add/remove/clear会报错。因为转化后，本质上仍是一个数组，返回的是Arrays内部的ArrayList类。</li><li>传递数组必须是对象数组，而不能是基本类型。eg.用Integer替代int。</li><li>正确的方法有：<pre><code class="hljs java">List list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>));<span class="hljs-comment">//使用 Java8 的Stream(推荐)</span>Integer [] myArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;List myList = Arrays.stream(myArray).collect(Collectors.toList());<span class="hljs-comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span><span class="hljs-keyword">int</span> [] myArray2 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</code></pre></li></ul></li><li>List.toArray转换<ul><li>无参方法默认返回值是Object[];</li><li>有参方法传入list.size()/指定的数据类型。</li></ul></li></ol><h2 id="3-3-ArrayList"><a href="#3-3-ArrayList" class="headerlink" title="3.3 ArrayList"></a>3.3 ArrayList</h2><p>答：ArrayList是数组列表，用来存储数据。</p><ul><li>优点：数组实现，支持随机访问。</li><li>缺点：删除和插入元素效率低，线程不安全。</li></ul><p>正常使用中，不会频繁增删，不会多线程，所以选ArrayList。频繁增删就用LinkedList。线程安全就用Vector。</p><h3 id="3-3-1-ArrayList和LinkedList区别"><a href="#3-3-1-ArrayList和LinkedList区别" class="headerlink" title="3.3.1 ArrayList和LinkedList区别"></a>3.3.1 ArrayList和LinkedList区别</h3><p>答：总结如下：</p><ul><li>底层数据结构：ArrayList底层是Object动态数组；LinkedList底层使用双向链表。</li><li>随机访问和插入删除元素：ArrayList支持随机访问（相当于get(int index)方法）但删除插入元素慢；LinkedList不支持随机访问但支持随机插入删除元素。</li><li>内存空间占用：ArrayList必须预留一定的空间；LinkedList要存储前驱后继和节点信息，开销大。</li></ul><p>注：ArrayList和LinkedList都是非线程安全的，Vector保证线程安全所有方法都是同步，但耗费大量时间。</p><h3 id="3-3-2-多线程下的ArrayList"><a href="#3-3-2-多线程下的ArrayList" class="headerlink" title="3.3.2 多线程下的ArrayList"></a>3.3.2 多线程下的ArrayList</h3><p>答：ArrayList不是线程安全的。需要通过<code>Collections.synchronizedList()</code>方法转换成线程安全容器。</p><h3 id="3-3-3-扩容"><a href="#3-3-3-扩容" class="headerlink" title="3.3.3 扩容"></a>3.3.3 扩容</h3><ul><li>新建一个<strong>原始长度 * 1.5</strong>的数组；<code>oldCapacity + (oldCapacity &gt;&gt; 1)</code></li><li>把原数组的数据复制到新数组中；</li><li>最后更新地址。</li></ul><h3 id="3-3-4-新增元素"><a href="#3-3-4-新增元素" class="headerlink" title="3.3.4 新增元素"></a>3.3.4 新增元素</h3><ol><li>判断长度，不够就扩容；</li><li>新建数组，复制原数组，在index位开始把元素放进index+1位；</li><li>最后在index放入新增元素。</li></ol><h3 id="3-3-5-删除元素"><a href="#3-3-5-删除元素" class="headerlink" title="3.3.5 删除元素"></a>3.3.5 删除元素</h3><ol><li>新建数组，复制原数组，跳过index位，把index+1位放在index位；</li><li>相当于被覆盖。</li></ol><h2 id="3-4-CopyOnWriteArrayList"><a href="#3-4-CopyOnWriteArrayList" class="headerlink" title="3.4 CopyOnWriteArrayList"></a>3.4 CopyOnWriteArrayList</h2><ol><li>读写分离，写操作在复制的数组上，读操作在原始数组上。</li><li>写操作因为是并发所以需要加锁，结束后指针指向复制数组。</li><li>在写操作的同时允许读操作，适合读多写少的场景。</li></ol><p>缺点：</p><ul><li>内存敏感，因为写操作要复制数组；</li><li>数据不一致：读操作不能读到最新数据，因为写操作还未同步到数组中。</li></ul><h1 id="4-Set和Queue"><a href="#4-Set和Queue" class="headerlink" title="4. Set和Queue"></a>4. Set和Queue</h1><h2 id="4-1-HashSet原理"><a href="#4-1-HashSet原理" class="headerlink" title="4.1 HashSet原理"></a>4.1 HashSet原理</h2><p>答：基于HashMap实现，HashSet值存放在HashMap的key上，value统一为PRESENT。HashSet通过比较hash值和equals()判断key是否重复。底部基本都是调用HashMap的方法。</p><h3 id="4-1-1-hashCode-和equals-区别"><a href="#4-1-1-hashCode-和equals-区别" class="headerlink" title="4.1.1 hashCode()和equals()区别"></a>4.1.1 hashCode()和equals()区别</h3><p>答：总结为：</p><ul><li>两对象相等，则hashcode一定相同，equals也返回相同；</li><li>hashcode相同，对象可能不同，equals也可能返回不同；</li><li>重写equals()时，hashcode一定也得重写。</li></ul><h3 id="4-1-2-和equals"><a href="#4-1-2-和equals" class="headerlink" title="4.1.2 ==和equals()"></a>4.1.2 ==和equals()</h3><p>答：提一嘴。==判断内存地址，equals()判断内容值。</p><h2 id="4-2-Queue方法"><a href="#4-2-Queue方法" class="headerlink" title="4.2 Queue方法"></a>4.2 Queue方法</h2><h3 id="4-2-1-poll-和remove"><a href="#4-2-1-poll-和remove" class="headerlink" title="4.2.1 poll()和remove()"></a>4.2.1 poll()和remove()</h3><p>答：都能弹出第一个元素并把对象从队列中删除。区别是没有元素时poll()返回null，remove()抛出异常。</p><h3 id="4-2-2-BlockingQueue"><a href="#4-2-2-BlockingQueue" class="headerlink" title="4.2.2 BlockingQueue"></a>4.2.2 BlockingQueue</h3><p>答：BlockingQueue是用来实现生产者-消费者模式的队列。添加元素时，等待队列有空间；移除元素时，等待队列为非空。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2020/04/27/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/04/27/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>Java 基础知识，包括Java平台、语法、面向对象、泛型、反射、异常等。</p><a id="more"></a><h1 id="1-Java概述"><a href="#1-Java概述" class="headerlink" title="1. Java概述"></a>1. Java概述</h1><p>Java是一种面向对象的编程语言，继承了之前语言的优点，还抛弃了指针等晦涩的内容，简单易用，功能强大。</p><h2 id="1-1-JDK、JRE和JVM"><a href="#1-1-JDK、JRE和JVM" class="headerlink" title="1.1 JDK、JRE和JVM"></a>1.1 JDK、JRE和JVM</h2><p>答：基本概念如下：</p><ul><li>JDK(Java Development Kit)开发工具包，java开发环境的核心组件，提供编译调试和运行java程序所有的工具和文件。</li><li>JRE(Java Runtime Environment)java运行时环境，包括JVM和核心类库。</li><li>JVM(Java Virtual Machine)java虚拟机，Java程序运行在JVM上，将字节码转为机器码，提供内存管理、GC等功能。</li></ul><h3 id="1-1-1-关系"><a href="#1-1-1-关系" class="headerlink" title="1.1.1 关系"></a>1.1.1 关系</h3><ul><li>JDK &gt; JRE &gt; JVM</li><li>只运行程序不编码，只装JRE；</li><li>JVM具有平台无关性，让java程序一次编译多个系统执行。</li></ul><h3 id="1-1-2-平台无关性实现"><a href="#1-1-2-平台无关性实现" class="headerlink" title="1.1.2 平台无关性实现"></a>1.1.2 平台无关性实现</h3><ul><li>Java程序基于JVM运行，JVM屏蔽了操作系统和底层硬件的差异；</li><li>Java先编译生成字节码文件，再交给JVM转为机器码；</li></ul><h2 id="1-2-字节码"><a href="#1-2-字节码" class="headerlink" title="1.2 字节码"></a>1.2 字节码</h2><p>答：字节码是Java源代码经过编译后生成的.class文件，只面向虚拟机。</p><h3 id="1-2-1-好处"><a href="#1-2-1-好处" class="headerlink" title="1.2.1 好处"></a>1.2.1 好处</h3><p>答：既保留了解释性语言的可移植性，又有编译型语言的高效率。</p><h3 id="1-2-2-流程"><a href="#1-2-2-流程" class="headerlink" title="1.2.2 流程"></a>1.2.2 流程</h3><p>Java源代码 -&gt; 编译器 -&gt; 字节码 -&gt; JVM的解释器 -&gt; 二进制代码 -&gt; 程序运行</p><h3 id="1-2-3-java是编译型还是解释型语言"><a href="#1-2-3-java是编译型还是解释型语言" class="headerlink" title="1.2.3 java是编译型还是解释型语言"></a>1.2.3 java是编译型还是解释型语言</h3><p>答：从上可以总结，java是先编译后解释执行的语言，不能单纯地归类。</p><h2 id="1-3-Java和C-区别"><a href="#1-3-Java和C-区别" class="headerlink" title="1.3 Java和C++区别"></a>1.3 Java和C++区别</h2><p>答：我也不知道，为什么面经都有这类题…</p><ul><li>都是面向对象的语言，支持封装继承和多态</li><li>java没有指针访问内存</li><li>java类是单继承，C++多重继承</li><li>java有自动GC机制</li><li>C/C++中的字符串和数组都自动加一个’\0’作为结束符，java中不需要</li></ul><h2 id="1-4-各版本特性"><a href="#1-4-各版本特性" class="headerlink" title="1.4 各版本特性"></a>1.4 各版本特性</h2><ol><li>Java 8<ul><li>Lambda 表达式，简化写法。</li><li>Streams流编程。中间操作返回Stream本身，能将多个操作串起，最终操作才返回结果。</li><li>Data API。Clock 提供访问当前日期和时间；时区设置；DateTimeFormatter 解决日期格式化；本地日期和本地时间。</li><li>注解。</li></ul></li><li>Java 9<ul><li>引入Java平台模块系统，将JDK分为若干模块，创建镜像只需要所依赖的JDK模块，减少JRE大小。</li><li>设置 G1 为默认垃圾收集器。</li><li>集合、Stream、Optional方法扩展。</li><li>接口私有方法。</li></ul></li><li>Java 10<ul><li>var关键字。只能用于局部变量和for循环。</li><li>G1 的FullGC变为并行的标记清除。</li></ul></li><li>Java 11<ul><li>新的长期支持版本。</li><li>增加一系列字符串处理方法。</li><li>ZGC 伸缩GC收集器。</li><li>HTTP Client API标准化，支持异步非阻塞。</li></ul></li><li>Java 12<ul><li>修改switch，变成类似lambda的形式。</li></ul></li><li>Java 13<ul><li>switch 加入 yield，用来跳出当前switch块。</li><li>文本块。</li></ul></li><li>Java 14<ul><li>将 switch 的增强转正。</li><li>移除 CMS 垃圾收集器。</li></ul></li></ol><h1 id="2-基础语法"><a href="#2-基础语法" class="headerlink" title="2.基础语法"></a>2.基础语法</h1><h2 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h2><p><img src="/img/java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" srcset="/img/loading.gif" alt="数据类型"></p><h3 id="2-1-1-BigDecimal"><a href="#2-1-1-BigDecimal" class="headerlink" title="2.1.1 BigDecimal"></a>2.1.1 BigDecimal</h3><p>浮点数的等值判断，基础类型不能用==，包装类型不能用equals()，会造成精度丢失。推荐使用BigDecimal操作浮点数，从而进行运算操作。</p><ul><li>大小判断：a.compareTo(b)，1为大于，0为等于，-1为小于；</li><li>保留小数：setScale()；</li><li>创建：new BigDecimal(“0.1”)/BigDecimal.valueOf(0.1)</li></ul><p>总结：BigDecimal操作(大)浮点数，BigInteger操作大整数(超过long)。</p><h2 id="2-2-运算符"><a href="#2-2-运算符" class="headerlink" title="2.2 运算符"></a>2.2 运算符</h2><h3 id="2-2-1-amp-和-amp-amp-区别"><a href="#2-2-1-amp-和-amp-amp-区别" class="headerlink" title="2.2.1 &amp;/|和&amp;&amp;/||区别"></a>2.2.1 &amp;/|和&amp;&amp;/||区别</h3><p>答：总结为：</p><ul><li>&amp;是按位与，|是逻辑或；</li><li>&amp;&amp;是与运算，||是或运算，都具有短路特性。eg.&amp;&amp;前面为false，右边表达式短路不访问。</li></ul><h3 id="2-2-2-equals-和-的区别"><a href="#2-2-2-equals-和-的区别" class="headerlink" title="2.2.2 equals()和==的区别"></a>2.2.2 equals()和==的区别</h3><p>答：区别：</p><ul><li>基本类型，==判断值相等，无equals()。</li><li>引用类型，==判断两个变量是否引用同一个变量即比较对象的地址，equals()判断引用对象是否等价。</li></ul><h2 id="2-3-关键字"><a href="#2-3-关键字" class="headerlink" title="2.3 关键字"></a>2.3 关键字</h2><h3 id="2-3-1-final"><a href="#2-3-1-final" class="headerlink" title="2.3.1 final"></a>2.3.1 final</h3><p>答：final关键字用于修饰类、变量和方法。</p><ul><li>final修饰的类，不能被继承；</li><li>final修饰的方法，不能被重写；</li><li>final修饰的变量，必须初始化，不能被改变。<strong>若修饰的是基础数据类型则其值不能变，若修饰引用类型则其内存地址不能变</strong>。</li></ul><h3 id="2-3-2-static"><a href="#2-3-2-static" class="headerlink" title="2.3.2 static"></a>2.3.2 static</h3><p>答：static的作用有:</p><ul><li>static修饰的类方法，不属于任何实例，但被类的实例对象共享。</li><li>static修饰的部分，只在第一次加载时初始化。</li></ul><h2 id="2-4-String"><a href="#2-4-String" class="headerlink" title="2.4 String"></a>2.4 String</h2><p>答：String是不可变的，创建后在常量池缓存。</p><h3 id="2-4-1-不可变"><a href="#2-4-1-不可变" class="headerlink" title="2.4.1 不可变"></a>2.4.1 不可变</h3><ul><li>String是final修饰的char数组，不可继承；</li><li>String不可变，但引用可变。eg.字符串拼接理解为开辟新的内存区域给新串。</li><li>用反射可以修改String。</li></ul><h3 id="2-4-2-StringBuffer与StringBuilder"><a href="#2-4-2-StringBuffer与StringBuilder" class="headerlink" title="2.4.2 StringBuffer与StringBuilder"></a>2.4.2 StringBuffer与StringBuilder</h3><ol><li>可变性：String底层用final char[]，不可变；StringBuffer和StringBuilder用char[]，可变。</li><li>线程安全：String不可变，安全；StringBuffer加了<strong>同步锁</strong>，线程安全；StringBuilder是非线程安全的。</li><li>性能：String改变时，生成新的String对象，将指针指向新的String；StringBuffer每次都对本身进行操作；StringBuilder速度会快一点。</li></ol><p>所以：</p><ul><li>操作少量的数据：适用String；</li><li>单线程操作字符串缓冲区下操作大量数据：适用StringBuilder；</li><li>多线程操作字符串缓冲区下操作大量数据：适用StringBuffer。</li></ul><p>注：记不清的话用safe来记忆，buffer有safe的一部分，所以它是线程安全的。</p><h3 id="2-4-3-缓存池"><a href="#2-4-3-缓存池" class="headerlink" title="2.4.3 缓存池"></a>2.4.3 缓存池</h3><p>答：new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用取同一个对象的引用。valueOf() 方法先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</li></ul><p>类似的new String(“i”)是在堆内存创建对象，String str=”i”是在常量池中存储。</p><h3 id="2-4-4-常用方法"><a href="#2-4-4-常用方法" class="headerlink" title="2.4.4 常用方法"></a>2.4.4 常用方法</h3><pre><code class="hljs java">indexOf()：返回指定字符的索引。charAt()：返回指定索引处的字符。replace()：字符串替换。trim()：去除字符串两端空白。split()：分割字符串，返回一个分割后的字符串数组。getBytes()：返回字符串的 <span class="hljs-keyword">byte</span> 类型数组。length()：返回字符串长度。toLowerCase()：将字符串转成小写字母。toUpperCase()：将字符串转成大写字符。substring()：截取字符串。equals()：字符串比较。</code></pre><h2 id="2-5-拆箱装箱"><a href="#2-5-拆箱装箱" class="headerlink" title="2.5 拆箱装箱"></a>2.5 拆箱装箱</h2><p>答：装箱就是自动将基本数据类型转换为包装类型；拆箱就是将包装类型转换为基本数据类型。</p><h3 id="2-5-1-分类"><a href="#2-5-1-分类" class="headerlink" title="2.5.1 分类"></a>2.5.1 分类</h3><p>答：Java为每个原始基本类型都提供了包装类。</p><ul><li>原始类型: boolean，char，byte，short，int，long，float，double</li><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li></ul><h3 id="2-5-2-Integer的坑"><a href="#2-5-2-Integer的坑" class="headerlink" title="2.5.2 Integer的坑"></a>2.5.2 Integer的坑</h3><p>答：写题时遇到。</p><ul><li>对于int，==比较的是值；</li><li>对于Integer，当-128~127时，==比较的是值；(直接引用常量池中内容)</li><li>当超过范围，==比较的是内存地址，要用 equals() 比较值。</li></ul><h1 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3. 面向对象"></a>3. 面向对象</h1><p>答：面向对象是一种思想，将复杂问题简单化模块化。</p><p>面向过程是具体化流程化。面向对象就是把过程抽象成类，封装成模块。</p><h2 id="3-1-三大特性"><a href="#3-1-三大特性" class="headerlink" title="3.1 三大特性"></a>3.1 三大特性</h2><ul><li>封装：将事物封装为一个类，隐藏细节，对外提供接口访问。当接口内部改变时，不影响外部调用。</li><li>继承：从已知类中派生新类，新类拥有父类的属性和方法，并能增加新功能或重写父功能。</li><li>多态：同一接口能有不同的解释，产生不同的结果。实现方式：继承、重载、向上转型。<br>多态是同一个行为具有多个不同表现形式或形态的能力。 </li></ul><h3 id="3-1-1-重写和重载"><a href="#3-1-1-重写和重载" class="headerlink" title="3.1.1 重写和重载"></a>3.1.1 重写和重载</h3><ul><li>重写，即父类有方法A，子类拓展了方法A并加了新功能，就是子类重写了A。</li><li>重载，即一个类中存在多个同名，但参数个数、顺序和类型不同的方法。</li></ul><p><strong>只有返回值不同，不构成重载！</strong></p><p><strong>构造器不能被重写，只能被重载</strong></p><h2 id="3-2-五大基本原则"><a href="#3-2-五大基本原则" class="headerlink" title="3.2 五大基本原则"></a>3.2 五大基本原则</h2><ul><li>单一职责原则SRP(Single Responsibility Principle)：类的功能要单一，不能包罗万象。</li><li>开放封闭原则OCP(Open－Close Principle)：对拓展开放，对修改封闭。</li><li>里式替换原则LSP(the Liskov Substitution Principle LSP)：子类可以替换父类且毫无察觉。</li><li>依赖倒置原则DIP(the Dependency Inversion Principle DIP)：高层模块不应依赖于低层模块，他们都应该依赖于抽象。抽象不应依赖于具体实现，具体实现应该依赖于抽象。</li><li>接口分离原则ISP(the Interface Segregation Principle ISP)：多个特殊接口比一个通用接口更好。</li></ul><h2 id="3-3-抽象类和接口"><a href="#3-3-抽象类和接口" class="headerlink" title="3.3 抽象类和接口"></a>3.3 抽象类和接口</h2><p><strong>抽象是对类的抽象，接口是对行为的抽象</strong></p><p>相同点:</p><ul><li>都不能实例化；</li><li>都包含抽象方法。</li></ul><p>不同点:</p><table><thead><tr><th></th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>构造方法</td><td>有</td><td>不存在</td></tr><tr><td>声明</td><td>abstract</td><td>interface</td></tr><tr><td>实现</td><td>extends继承抽象类</td><td>implements实现接口</td></tr><tr><td>构造器</td><td>有</td><td>无</td></tr><tr><td>继承方式</td><td>单继承</td><td>多继承3</td></tr><tr><td>字段声明</td><td>任意</td><td>默认static和final</td></tr><tr><td>修饰符</td><td>public、protected、default</td><td>public</td></tr></tbody></table><p>注：抽象类中不能有静态方法(final就不能被继承，矛盾)，JDK1.8后接口能有静态方法。</p><h3 id="3-3-1-静态与非静态的区别"><a href="#3-3-1-静态与非静态的区别" class="headerlink" title="3.3.1 静态与非静态的区别"></a>3.3.1 静态与非静态的区别</h3><p>答：静态是指用static关键字修饰的类、方法、字段等，非静态是指没有用static修饰的。</p><ul><li>静态只能访问静态的，非静态既能访问静态的也能访问非静态的</li><li>静态的直接可以用类名调用，非静态的需要先实例化再调用。</li><li>静态变量存在常量池中，非静态成员变量在堆中</li><li>静态变量随类的加载而加载，消失而消失，非静态成员变量随对象创建而存在，消失而消失</li></ul><h2 id="3-4-内部类"><a href="#3-4-内部类" class="headerlink" title="3.4 内部类"></a>3.4 内部类</h2><p>答：把一个类定义在另一个类的内部就是内部类，分为成员内部类、局部内部类、匿名内部类和静态内部类。</p><h3 id="3-4-1-优点"><a href="#3-4-1-优点" class="headerlink" title="3.4.1 优点"></a>3.4.1 优点</h3><ul><li>对包的其他类不透明，封装性好；</li><li>内部类能实现多重继承；</li><li>内部类能访问创建它的外部类对象。</li></ul><h3 id="3-4-2-匿名内部类"><a href="#3-4-2-匿名内部类" class="headerlink" title="3.4.2 匿名内部类"></a>3.4.2 匿名内部类</h3><ul><li>必须继承一个抽象类或者实现一个接口。</li><li>不能定义任何静态成员/方法。</li><li>匿名内部类使用的外部变量必须声明为 final。</li></ul><p>注：final是因为生命周期不一致。final可以确保局部/匿名内部类使用的变量与外层的局部变量区分开。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">new</span> Service() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;                    System.out.println(<span class="hljs-string">"匿名内部类"</span> );                &#125;            &#125;        &#125;.method();    &#125; &#125; <span class="hljs-comment">//匿名内部类必须继承或实现一个已有的接口 </span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Service</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h2 id="3-5-equals-和hashCode"><a href="#3-5-equals-和hashCode" class="headerlink" title="3.5 equals()和hashCode()"></a>3.5 equals()和hashCode()</h2><p>答：equals()判断两个对象是否相等，hashCode()获取对象的哈希码，根据哈希码确定对象在哈希表中的索引。</p><h3 id="3-5-1-关系"><a href="#3-5-1-关系" class="headerlink" title="3.5.1 关系"></a>3.5.1 关系</h3><ol><li>两个对象相等，hashCode()也一定相同；</li><li>hashCode值相同，对象不一定相等；</li><li>equals()重写时，hashcCode()也一定要被重写，为保证两个对象的哈希值也相等，避免hashmap逻辑冲突。</li></ol><h2 id="3-6-值传递"><a href="#3-6-值传递" class="headerlink" title="3.6 值传递"></a>3.6 值传递</h2><p>答：概括为：</p><ul><li>值传递，传递对象的副本，即修改副本，不影响源对象。</li><li>引用传递，传递对象的引用，即修改引用对象，会影响源对象。</li><li><strong>Java只有值传递，而这个值实际上是对象的引用</strong>！理解为共享传递。</li></ul><h2 id="3-7-拷贝"><a href="#3-7-拷贝" class="headerlink" title="3.7 拷贝"></a>3.7 拷贝</h2><ol><li>浅拷贝：对基础数据类型值传递，对引用数据类型引用传递；</li><li>深拷贝：对基础数据类型值传递，对引用数据类型，创建新对象，复制其内容。</li></ol><h1 id="4-反射"><a href="#4-反射" class="headerlink" title="4. 反射"></a>4. 反射</h1><p>答：反射机制是指在运行中，任意一个类，都能知道这个类的所有属性和方法；任意一个对象，都能调用它的属性和方法。简而言之，<strong>动态获取和调用对象的属性和方法。</strong> </p><p>优点是灵活度高，缺点是慢慢慢！</p><h2 id="4-1-相关类"><a href="#4-1-相关类" class="headerlink" title="4.1 相关类"></a>4.1 相关类</h2><ul><li>Class：类，用于获取类的相关信息</li><li>Field：成员变量，用于获取实例变量和静态变量</li><li>Method：方法，用于获取类中的方法参数和类型</li><li>Constructor：构造器，用于获取构造器的相关参数和类型</li></ul><h2 id="4-2-流程"><a href="#4-2-流程" class="headerlink" title="4.2 流程"></a>4.2 流程</h2><ol><li>获取class对象。Class.forName，getClass()，.class获得。</li><li>newInstance()获取class对象的实例，通过getFields,getConstructors,getMethods获取类成员，set/get访问字段，invoke()调用方法。</li></ol><h2 id="4-3-为什么慢"><a href="#4-3-为什么慢" class="headerlink" title="4.3 为什么慢"></a>4.3 为什么慢</h2><ol><li>class.getMethod()，遍历所有的方法，匹配不到就去找遍历父类。最耗时的地方，用备忘录将method记录能降低一个数量级的消耗。</li><li>method.invoke()，参数为Object数组，需要对基本类型装箱。</li></ol><h2 id="4-4-举例"><a href="#4-4-举例" class="headerlink" title="4.4 举例"></a>4.4 举例</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        User ming = <span class="hljs-keyword">new</span> Usetr();        String className = <span class="hljs-string">"com.bys.User"</span>;        <span class="hljs-comment">// 获取Class对象</span>        Class clazz = ming.getClass();        Class clazz = Class.forName(className);        Class clazz = User<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;        <span class="hljs-comment">// 创建User对象</span>        User user = (User)clazz.newInstance();        <span class="hljs-comment">// 和普通对象一样，可以设置属性值</span>        user.setUsername(<span class="hljs-string">"bys"</span>);        System.out.println(user);    &#125;&#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> String username;     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> username;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;        <span class="hljs-keyword">this</span>.username = username;    &#125;&#125;</code></pre><h1 id="5-元注解"><a href="#5-元注解" class="headerlink" title="5. 元注解"></a>5. 元注解</h1><p>答：提供了4个元注解，作用是负责注解其他注解。</p><ul><li>@Target，注明注解用于什么地方。</li><li>@Rentention，注明注解的生命周期，分为SOURCE, CLASS, RUNTIME三种策略。</li><li>@Documented，注明是否将注解信息添加在java文档中。</li><li>@Inherited，注明该注释和子类的关系。即一个类被@Inherited的注解标注，其子类也被这个注解标注。</li></ul><h2 id="5-1-注解的流程"><a href="#5-1-注解的流程" class="headerlink" title="5.1 注解的流程"></a>5.1 注解的流程</h2><p>答：作用：代替繁琐的配置文件，简化开发。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义注解类必须使用@interface</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>value就是属性。指定属性后，使用注解时需要给属性赋值。 </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnn &#123;     <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;     <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">value1</span><span class="hljs-params">()</span></span>; &#125;<span class="hljs-comment">// 使用注解MyAnn，可以设置属性</span><span class="hljs-meta">@MyAnn</span>(value1=<span class="hljs-number">100</span>,value=<span class="hljs-string">"hello"</span>) <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123; &#125;</code></pre><h1 id="6-泛型"><a href="#6-泛型" class="headerlink" title="6. 泛型"></a>6. 泛型</h1><p>答：泛型是当创建对象或调用方法时才去确定数据类型的特殊类型。</p><h2 id="6-1-好处"><a href="#6-1-好处" class="headerlink" title="6.1 好处"></a>6.1 好处</h2><p>不用进行强转；程序更加健壮；可读性更好；在创建集合时限定类型方便。</p><h2 id="6-2-泛型基础"><a href="#6-2-泛型基础" class="headerlink" title="6.2 泛型基础"></a>6.2 泛型基础</h2><h3 id="6-2-1-泛型类"><a href="#6-2-1-泛型类" class="headerlink" title="6.2.1 泛型类"></a>6.2.1 泛型类</h3><p>泛型类就是把泛型定义在类上，用户使用该类的时候，才把类型明确下来。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectTool</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> T obj;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getObj</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> obj;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setObj</span><span class="hljs-params">(T obj)</span> </span>&#123;        <span class="hljs-keyword">this</span>.obj = obj;    &#125;&#125;</code></pre><h3 id="6-2-2-泛型方法"><a href="#6-2-2-泛型方法" class="headerlink" title="6.2.2 泛型方法"></a>6.2.2 泛型方法</h3><p>外界调用时传进来什么类型，返回值就是什么类型。</p><pre><code class="hljs java"><span class="hljs-comment">//定义泛型方法..</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(T t)</span> </span>&#123;    System.out.println(t);&#125;</code></pre><h3 id="6-2-3-泛型类的子类"><a href="#6-2-3-泛型类的子类" class="headerlink" title="6.2.3 泛型类的子类"></a>6.2.3 泛型类的子类</h3><p>分为子类明确和子类不明确</p><pre><code class="hljs java"><span class="hljs-comment">//子类明确</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Inter</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(String s)</span> </span>&#123;        System.out.println(s);    &#125;&#125;<span class="hljs-comment">//子类不明确</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterImpl</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Inter</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(T t)</span> </span>&#123;        System.out.println(t);    &#125;&#125;</code></pre><h2 id="6-3-类型通配符’-’"><a href="#6-3-类型通配符’-’" class="headerlink" title="6.3 类型通配符’?’"></a>6.3 类型通配符’?’</h2><p>泛型提供了类型通配符 ? ，表示匹配任意类型。在用这个时，必须注意：<strong>只能调用和对象无关的方法，不能调用和对象有关的方法，直到外界确定了具体的类型。</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(List&lt;?&gt; list)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;list.size();i++)&#123;             System.out.println(list.get(i));      &#125;&#125;</code></pre><h3 id="6-3-1-通配符上限"><a href="#6-3-1-通配符上限" class="headerlink" title="6.3.1 通配符上限"></a>6.3.1 通配符上限</h3><p>表示List接收的元素只能是Number自身或子类。</p><pre><code class="hljs java">List&lt;? extends Number&gt;</code></pre><h3 id="6-3-2-通配符下限"><a href="#6-3-2-通配符下限" class="headerlink" title="6.3.2 通配符下限"></a>6.3.2 通配符下限</h3><p>表示传递进来的只能是Type或其父类。</p><pre><code class="hljs java">&lt;? <span class="hljs-keyword">super</span> Type&gt;</code></pre><h2 id="6-4-泛型擦除"><a href="#6-4-泛型擦除" class="headerlink" title="6.4 泛型擦除"></a>6.4 泛型擦除</h2><p>在已经确定泛型类型的集合赋值给普通集合时，发生泛型擦除，即<strong>保留类型参数的上限</strong>。如List<String> list传递给List list1，保留的是String的上限Object。</p><h1 id="7-JIT编译器"><a href="#7-JIT编译器" class="headerlink" title="7. JIT编译器"></a>7. JIT编译器</h1><p>答：JIT(Just In Time Compile)即时编译器，把经常运行的代码编译成和本地平台相关的机器码并优化，包括逃逸分析、锁消除、空值检测消除等。</p><h2 id="7-1-逃逸分析"><a href="#7-1-逃逸分析" class="headerlink" title="7.1 逃逸分析"></a>7.1 逃逸分析</h2><p>答：逃逸分析的基本行为就是分析对象动态作用域。当一个对象在方法中被定义时，它可能被外部方法引用，例如作为参数传递，这种称为方法逃逸。作用是，经过分析，发现对象不被外界访问，经过JIT优化，把对象拆解成若干标量替换。</p><h1 id="8-异常"><a href="#8-异常" class="headerlink" title="8. 异常"></a>8. 异常</h1><h2 id="8-1-分类"><a href="#8-1-分类" class="headerlink" title="8.1 分类"></a>8.1 分类</h2><ol><li>Throwable是所有错误Error和异常Exception的父类；</li><li>Error一般为程序运行错误，不能被动态处理，只能安全终止；</li><li>Exception分为运行时异常RuntimeException可以被捕获处理，非运行时异常CheckedException编译阶段强制要求处理(ide中标红)。</li></ol><h2 id="8-2-处理方式"><a href="#8-2-处理方式" class="headerlink" title="8.2 处理方式"></a>8.2 处理方式</h2><ol><li>抛出异常。遇到异常不做处理直接抛出，throws作用于方法上，throw作用于方法内。</li><li>try/catch/finally，try中的异常被catch捕获处理，finally无论是否发生异常都执行，一般用来释放资源。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>感悟</title>
    <link href="/2020/04/27/%E6%84%9F%E6%82%9F/"/>
    <url>/2020/04/27/%E6%84%9F%E6%82%9F/</url>
    
    <content type="html"><![CDATA[<p>后台的本质就是增删查改，学很多知识，都是为了更好的增删查改。</p><a id="more"></a><ol><li>后台的本质就是增删查改，学很多知识，都是为了更好的增删查改。</li><li>时间越长，代码越来越复杂，就会涉及到业务拆分，架构设计。</li><li>常用的静态资源占用带宽，用静态资源服务器。</li><li>文件上传下载太慢，要提高效率，FastDFS。</li><li>要保证消息推送的实时性，就得建立长连接，netty，websockt。</li><li>一台服务器撑不住并发，多台服务器就会涉及到负载均衡。</li><li>多台服务器下他们中间会有通信问题，又涉及到RPC远程调用。</li><li>敏感业务，像支付和认证，受网络原因调用慢，就需要异步。</li><li>使用人数过多，要让服务器减压，就要用到消息队列 + 分布式缓存。</li><li>数据库数据量过大，得建立索引，分表分库。</li><li>常用信息访问过多占用资源，得用缓存，像redis。</li><li>代码设计里面又包含设计模式，架构模式。</li><li>分布式里面除了CAP这样的理论基础，还有SOA，服务治理，WebService，通讯协议等等。</li></ol><p>学是学不完的，但总归是要学的。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口问题</title>
    <link href="/2020/04/26/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/"/>
    <url>/2020/04/26/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>滑动窗口问题的思路和基础代码模板。</p><a id="more"></a><h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ol><li>设置左右指针，初始化都为0，把[left,right]当成一个窗口；</li><li>不断增大right，直到窗口内的子串符合要求；</li><li>不断增大left，缩小窗口直到窗口内子串不符合要求，在缩小left时记录结果；</li><li>直到right到达字符串串尾。</li></ol><p>对于如何判断是否符合要求，建立两个哈希表，一个needs记录pattern子串中字符出现次数，一个windows记录当前窗口子串中字符出现次数。用一个match记录符合规则的字符数。</p><p>当match等于needs的长度时，表明满足条件，开始缩小窗口。每次缩小时，都要再次判断条件，更新match。</p><p>注：在java中除了设置hashmap还可以直接用数组建立char[256/128]，操作也简便些。</p><h1 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h1><p>基础思想的模板</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (right &lt; s.size()) &#123;    window.add(s[right]);    right++;        <span class="hljs-keyword">while</span> (valid) &#123;        window.remove(s[left]);        left++;    &#125;&#125;</code></pre><p>详细些</p><pre><code class="hljs java"><span class="hljs-comment">// 双指针</span><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = <span class="hljs-number">0</span>;<span class="hljs-comment">// 滑动窗口</span>HashMap/Character[] windows = &#123;&#125;;<span class="hljs-comment">// 匹配条件</span>HashMap/Character[] needs = &#123;&#125;;<span class="hljs-comment">// 条件判断操作</span><span class="hljs-keyword">var</span> valid;<span class="hljs-comment">// 符合条件的字符数</span><span class="hljs-keyword">int</span> match = <span class="hljs-number">0</span> ;<span class="hljs-comment">// 变化窗口</span><span class="hljs-keyword">while</span>(right &lt; A.length)&#123;    <span class="hljs-comment">// 增大窗口</span>    <span class="hljs-keyword">if</span>(valid)&#123;        windows.add(B[right]);    &#125;    right++;    <span class="hljs-comment">// 符合子串匹配条件</span>    <span class="hljs-keyword">while</span>(match === needs.length)&#123;        <span class="hljs-keyword">if</span>(valid)&#123;            <span class="hljs-comment">// 缩小窗口</span>            window.remove(B[left]);            <span class="hljs-comment">// 归位规则计数</span>            match--;            <span class="hljs-comment">// 继续下一轮、增大前进窗口</span>            left++;        &#125;    &#125;&#125;</code></pre><h1 id="题目举例"><a href="#题目举例" class="headerlink" title="题目举例"></a>题目举例</h1><table><thead><tr><th>题号</th><th>题目</th><th>难度</th></tr></thead><tbody><tr><td>3</td><td><a href="https://github.com/BarryBean/AlgorithmNotes/blob/master/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/3%E6%97%A0%E9%87%8D%E5%A4%8D%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.md" target="_blank" rel="noopener">无重复的最长子串</a></td><td>中等</td></tr><tr><td>76</td><td><a href="https://github.com/BarryBean/AlgorithmNotes/blob/master/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/76%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.md" target="_blank" rel="noopener">最小覆盖子串</a></td><td>困难</td></tr><tr><td>209</td><td><a href="https://github.com/BarryBean/AlgorithmNotes/blob/master/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/209%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.md" target="_blank" rel="noopener">长度最小的子数组</a></td><td>中等</td></tr><tr><td>438</td><td><a href="https://github.com/BarryBean/AlgorithmNotes/blob/master/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/438%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.md" target="_blank" rel="noopener">找到字符串中所有字母异位词</a></td><td>中等</td></tr><tr><td>567</td><td><a href="https://github.com/BarryBean/AlgorithmNotes/blob/master/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/567%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.md" target="_blank" rel="noopener">字符串的排列</a></td><td>中等</td></tr><tr><td>239</td><td><a href="https://github.com/BarryBean/AlgorithmNotes/blob/master/%E5%8D%95%E8%B0%83%E6%A0%88/239%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.md" target="_blank" rel="noopener">滑动窗口最大值</a></td><td>困难</td></tr><tr><td>480</td><td><a href="https://github.com/BarryBean/AlgorithmNotes/blob/master/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/480%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0.md" target="_blank" rel="noopener">滑动窗口中位数</a></td><td>困难</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
